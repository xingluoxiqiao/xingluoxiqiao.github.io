<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>星落溪桥</title>
  
  
  <link href="https://xlxq.fun/atom.xml" rel="self"/>
  
  <link href="https://xlxq.fun/"/>
  <updated>2024-01-13T11:18:02.000Z</updated>
  <id>https://xlxq.fun/</id>
  
  <author>
    <name>星落溪桥</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RocketMQ入门</title>
    <link href="https://xlxq.fun/posts/badb3e06.html"/>
    <id>https://xlxq.fun/posts/badb3e06.html</id>
    <published>2024-01-13T11:18:02.000Z</published>
    <updated>2024-01-13T11:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1>消息队列</h1><ol><li>消息（Message）是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象。</li><li>消息队列（Message Queue）是一种应用间的通信方式，消息发送后可以立即返回，由消息系统来确保消息的可靠传递。消息发布者只管把消息发布到 MQ 中而不用管谁来取，消息使用者只管从 MQ 中取消息而不管是谁发布的。这样发布者和使用者都不用知道对方的存在，从而实现模块间的解耦合。</li><li>消息队列是一种应用间的异步协作机制，同时消息队列中间件是分布式系统中重要的组件，主要解决<strong>应用耦合，异步消息，流量削锋</strong>等问题。实现高性能，高可用，可伸缩和最终一致性架构。</li></ol><h2 id="消息队列的作用">消息队列的作用</h2><ol><li><strong>解耦：</strong> 消息队列可以将系统内不同模块之间的通信解耦，使得模块之间不直接依赖于彼此的实现。这降低了系统的复杂性，使得各个组件可以独立演化。</li><li><strong>异步通信：</strong> 消息队列支持异步通信，发送方将消息放入队列后即可继续执行其他操作，而不需要等待接收方的处理。这提高了系统的响应性，特别是在处理大量请求或在网络延迟较高的情况下。</li><li><strong>流量削峰：</strong> 消息队列可以用于缓冲和平滑处理系统的流量，防止突发的高峰值请求对系统造成压力。通过控制消息的消费速率，可以有效地削平流量峰值。</li></ol><h2 id="常见消息队列对比">常见消息队列对比</h2><p>常见的消息队列系统包括RocketMQ、RabbitMQ和Kafka，它们在一些方面有一些共同点，但也有一些明显的区别。以下是它们的一些对比：</p><ol><li><strong>消息传递模型：</strong><ul><li><strong>RocketMQ：</strong> 提供点对点和发布/订阅两种消息传递模型。</li><li><strong>RabbitMQ：</strong> 同样支持点对点和发布/订阅模型，非常灵活。</li><li><strong>Kafka：</strong> 主要支持发布/订阅模型。</li></ul></li><li><strong>性能：</strong><ul><li><strong>RocketMQ：</strong> 注重高吞吐量和低延迟，适合实时消息处理。</li><li><strong>RabbitMQ：</strong> 相对较低的延迟，适用于一些对延迟敏感的场景。</li><li><strong>Kafka：</strong> 专注于高吞吐量和持久性，适用于大规模数据处理。</li></ul></li><li><strong>可靠性：</strong><ul><li><strong>RocketMQ：</strong> 提供了较好的消息可靠性，支持同步和异步复制。</li><li><strong>RabbitMQ：</strong> 可以配置为提供高可靠性，但需要在配置上更多的努力。</li><li><strong>Kafka：</strong> 通过分区和副本机制来确保消息的可靠性。</li></ul></li><li><strong>水平扩展性：</strong><ul><li><strong>RocketMQ：</strong> 支持较好的水平扩展性，可以通过添加节点来增加容量。</li><li><strong>RabbitMQ：</strong> 可以通过集群来实现水平扩展，但可能相对复杂。</li><li><strong>Kafka：</strong> 具有出色的水平扩展性，适用于大规模数据流处理。</li></ul></li><li><strong>使用场景：</strong><ul><li><strong>RocketMQ：</strong> 适用于大规模实时消息处理，例如电商交易系统。</li><li><strong>RabbitMQ：</strong> 适用于传统企业应用，也可以用于实时数据处理。</li><li><strong>Kafka：</strong> 适用于大规模数据流处理，如日志收集、事件流处理等。</li></ul></li></ol><h1>RocketMQ</h1><h2 id="架构设计">架构设计</h2><ol><li><strong>生产者（Producer）</strong>：消息的发送者，负责产生消息，生产者向消息服务器发送由业务应用程序系统生成的消息。</li><li><strong>消费者（Consumer）</strong>：消息接收者，负责消费消息，消费者从消息服务器拉取信息并将其输入用户应用程序。</li><li><strong>消息服务器（Broker）</strong>：暂存和传输消息；是消息存储中心，主要作用是接收来自 Producer 的消息并存储， Consumer 从这里取得消息。</li><li><strong>名称服务器（NameServer）</strong>：管理Broker，用来保存 Broker 相关 Topic 等元信息并给 Producer ，提供 Consumer 查找 Broker 信息。</li><li><strong>主题（Topic）</strong>：区分消息的种类；一个发送者可以发送消息给一个或者多个Topic；一个消息的接收者 可以订阅一个或者多个Topic消息</li><li><strong>消息队列（Message Queue）</strong>：相当于是Topic的分区；用于并行发送和接收消息</li><li><strong>标签（Tag）</strong>： 用于对消息进行二级分类。一个 Topic 可以有多个 Tag，用于更细粒度地过滤消息</li></ol><h2 id="启动流程">启动流程</h2><img src="/post-img/Pasted image 20240217160000.png" alt="图片损坏" style="zoom:100%;" /><ol><li><strong>启动 NameServer</strong>，NameServer 启动后监听端口，等待 Broker、Producer、Consumer 连接，相当于一个路由控制中心。</li><li><strong>启动 Broker</strong>，Broker启动后与所有 NameServer 保持长连接，定时发送心跳包。心跳包中包含当前 Broker 信息以及存储所有 Topic 信息。注册成功后，NameServer 集群中就有 Topic 跟 Broker 的映射关系。</li><li><strong>创建 Topic</strong>，创建 Topic 时需要指定该 Topic 要存储在哪些 Broker 上，也可以在发送消息时自动创建 Topic。</li><li><strong>生产者发送消息</strong>，启动时先跟 NameServer 集群中的其中一台建立长连接，并从 NameServer 中获取当前发送的 Topic 存在于哪些 Broker 上，轮询从队列列表中选择一个队列，然后与队列所在的 Broker 建立长连接从而向 Broker发消息。</li><li><strong>消费者接受消息</strong>，跟其中一台 NameServer 建立长连接，获取当前订阅 Topic 存在哪些 Broker 上，然后直接跟 Broker 建立连接通道，然后开始消费消息。</li></ol><h2 id="特点">特点</h2><h3 id="顺序消费">顺序消费</h3><p>顺序消息是 RocketMQ 提供的一种对消息发送和消费顺序有严格要求的消息。对于一个指定的 Topic，消息严格按照先进先出（FIFO）的原则进行消息发布和消费，即先发布的消息先消费，后发布的消息后消费。</p><h4 id="分区顺序消息">分区顺序消息</h4><p>对于指定的一个 Topic，所有消息根据 Sharding Key 进行区块分区，<strong>同一个分区内</strong>的消息按照严格的先进先出（FIFO）原则进行发布和消费。同一分区内的消息保证顺序，不同分区之间的消息顺序不做要求。</p><ol><li>适用场景：适用于性能要求高，以 Sharding Key 作为分区字段，在同一个区块中严格地按照先进先出（FIFO）原则进行消息发布和消费的场景。</li><li>示例：<ul><li>用户注册需要发送验证码，以用户 ID 作为 Sharding Key，那么同一个用户发送的消息都会按照发布的先后顺序来消费。</li><li>电商的订单创建，以订单 ID 作为 Sharding Key，那么同一个订单相关的创建订单消息、订单支付消息、订单退款消息、订单物流消息都会按照发布的先后顺序来消费。</li></ul></li></ol><h4 id="全局顺序消息">全局顺序消息</h4><p>对于指定的一个Topic，<strong>所有消息</strong>按照严格的先入先出（FIFO）的顺序来发布和消费。</p><ol><li>适用场景：适用于性能要求不高，所有的消息严格按照 FIFO 原则来发布和消费的场景。</li><li>示例：</li></ol><ul><li>在证券处理中，以人民币兑换美元为 Topic，在价格相同的情况下，先出价者优先处理，则可以按照 FIFO 的方式发布和消费全局顺序消息。</li></ul><ol start="3"><li>全局顺序消息实际上是<strong>一种特殊的分区顺序消息</strong>，即 Topic 中只有一个分区，因此全局顺序和分区顺序的实现原理相同。因为分区顺序消息有多个分区，所以分区顺序消息比全局顺序消息的并发度和性能更高。</li></ol><h3 id="消息可靠性">消息可靠性</h3><p>保证消息可靠性也就是保证消息一定会被消费，不会丢失，而消息丢失可能会在这三个阶段发生：<strong>生产阶段、存储阶段、消费阶段</strong></p><ol><li>生产阶段：<strong>请求确认机制</strong><ul><li>同步发送的时候，要注意处理响应结果和异常。如果返回响应OK，表示消息成功发送到了Broker，如果响应失败，或者发生其它异常，都应该重试。</li><li>异步发送的时候，应该在回调方法里检查，如果发送失败或者异常，都应该进行重试。</li><li>如果发生超时的情况，也可以通过查询日志的API，来检查是否在Broker存储成功。</li></ul></li><li>存储阶段：<strong>通过配置可靠性优先的 Broker 参数来避免因为宕机丢消息</strong>，也就是进行<strong>数据持久化</strong><ul><li>消息只要持久化到CommitLog（日志文件）中，即使Broker宕机，未消费的消息也能重新恢复再消费。</li><li>Broker的刷盘机制：<strong>同步刷盘和异步刷盘</strong>，不管哪种刷盘都可以保证消息一定存储在pagecache中（内存中），但是同步刷盘更可靠，它是Producer发送消息后等数据持久化到磁盘之后再返回响应给Producer。</li><li>Broker通过<strong>主从模式</strong>来保证高可用，Broker支持Master和Slave同步复制、Master和Slave异步复制模式，生产者的消息都是发送给Master，但是消费既可以从Master消费，也可以从Slave消费。同步复制模式可以保证即使Master宕机，消息肯定在Slave中有备份，保证了消息不会丢失。</li></ul></li><li>消费阶段<ul><li>Consumer保证消息成功消费的关键在于确认的时机，不要在收到消息后就立即发送消费确认，而是应该在执行完所有消费业务逻辑之后，再发送消费确认。</li></ul></li></ol><h3 id="死信队列">死信队列</h3><ol><li>死信队列用于处理无法被正常消费的消息，即死信消息。</li><li>当一条消息初次消费失败，消息队列 RocketMQ 会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，RocketMQ 不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中，该特殊队列称为死信队列。</li><li>死信消息的特点：<ul><li>不会再被消费者正常消费。</li><li>有效期与正常消息相同，均为 3 天，3 天后会被自动删除。因此，需要在死信消息产生后的 3 天内及时处理。</li></ul></li><li>死信队列的特点：<ul><li><strong>一个死信队列对应一个 Group ID</strong>， 而不是对应单个消费者实例。</li><li>如果一个 Group ID 未产生死信消息，消息队列 RocketMQ 不会为其创建相应的死信队列。</li><li>一个死信队列包含了对应 Group ID 产生的所有死信消息，不论该消息属于哪个 Topic。</li><li>RocketMQ 控制台提供对死信消息的<strong>查询、导出和重发</strong>的功能。</li></ul></li></ol><h3 id="延迟队列">延迟队列</h3><p>RocketMQ是支持延时消息的，只需要在生产消息的时候设置消息的延时级别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化一个生产者来产生延时消息</span></span><br><span class="line"><span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;ExampleProducerGroup&quot;</span>);</span><br><span class="line"><span class="comment">// 启动生产者</span></span><br><span class="line">producer.start();</span><br><span class="line"><span class="type">int</span> <span class="variable">totalMessagesToSend</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; totalMessagesToSend; i++) &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TestTopic&quot;</span>, (<span class="string">&quot;message &quot;</span> + i).getBytes());</span><br><span class="line">    <span class="comment">// 设置延时等级3,这个消息将在10s之后发送(现在只支持固定的几个时间)</span></span><br><span class="line">    message.setDelayTimeLevel(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    producer.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是目前RocketMQ支持的延时级别是有限的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">messageDelayLevel</span> <span class="operator">=</span> </span><br><span class="line"><span class="string">&quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;</span>;</span><br></pre></td></tr></table></figure><p>RocketMQ通过<strong>临时存储+定时任务</strong>来实现延时消息<br>Broker收到延时消息了，会先发送到主题（SCHEDULE_TOPIC_XXXX）的相应时间段的Message Queue中，然后通过一个定时任务轮询这些队列，到期后，把消息投递到目标Topic的队列中，然后消费者就可以正常消费这些消息。</p><h2 id="常见问题解决">常见问题解决</h2><h3 id="消息幂等性">消息幂等性</h3><p>对分布式消息队列来说，同时做到确保一定投递和不重复投递是很难的，就是所谓的“有且仅有一次” 。RocketMQ择了确保一定投递，保证消息不丢失，但有可能造成消息重复。<br>处理消息重复问题，主要由业务端保证，主要的方式有两种：<strong>业务幂等和消息去重</strong></p><ol><li>业务幂等：保证消费逻辑的幂等性，也就是多次调用和一次调用的效果是一样的。这样一来，不管消息消费多少次，对业务都没有影响。</li><li>消息去重：业务端对重复的消息就不再消费了。这种方法，需要保证每条消息都有一个唯一的编号，通常是业务相关的，比如订单号，消费的记录需要落库，而且需要保证和消息确认这一步的原子性。<br>基于以下两个方向思考：</li><li>接口只允许调用一次，比如mysql唯一索引，基于redis分布式锁机制</li><li>对数据的影响只会触发一次，比如乐观锁或状态机（数据的状态信息是向前变化的，因此如果数据的当前状态小于记录的状态，就可以忽略这次修改的信息）</li></ol><h3 id="消息积压">消息积压</h3><p>事前处理：上线之前对流量有个预估，压测得出消费者的消费能力上限，再根据实际情况进行部署以支撑整个服务<br>事中处理：先保证服务，进行消费者的临时扩容操作</p><ol><li>消费者扩容：<ul><li>如果当前Topic的Message Queue的数量大于消费者数量，就可以对消费者进行扩容，增加消费者，来提高消费能力，尽快把积压的消息消费玩。</li></ul></li><li>消息迁移Queue扩容：<ul><li>如果当前Topic的Message Queue的数量小于或者等于消费者数量，这种情况，再扩容消费者就没什么用，就得考虑扩容Message Queue。可以新建一个临时的Topic，临时的Topic多设置一些Message Queue，然后先用一些消费者把消费的数据丢到临时的Topic，因为不用业务处理，只是转发一下消息，还是很快的。接下来用扩容的消费者去消费新的Topic里的数据，消费完了之后，恢复原状。<br>事后处理：</li></ul></li><li>提高并行消费度，如：合理设置消费者组；增加队列分区，考虑把消息分散到多个队列中，避免单个队列出现积压</li><li>批量方式消费，提高消费吞吐量</li><li>调整消息处理的优先级：根据消息的重要性和紧急程度，调整消息处理的优先级。优先处理重要的消息，确保关键业务的及时性，而对于非关键的消息可以进行降级处理、跳过、或延后处理。</li><li>优化每条消息的消费过程（业务）<br>5. 合理设置超时机制</li><li>数据清理和重试：定期清理过期或无效信息</li><li>扩容：若MQ出现性能瓶颈，对MQ扩容</li><li>增加消费者数量：增加消费能力</li></ol><h3 id="消息过滤">消息过滤</h3><ol><li>在 Broker 端按照 Consumer 的去重逻辑进行过滤，这样做的好处是避免了无用的消息传输到 Consumer 端，缺点是加重了 Broker 的负担，实现起来相对复杂。</li><li>在 Consumer 端过滤，比如按照消息设置的 tag 去重，这样的好处是实现起来简单，缺点是有大量无用的消息到达了 Consumer 端只能丢弃不处理。</li><li>一般采用Cosumer端过滤，如果希望提高吞吐量，可以采用Broker过滤。</li><li>对消息的过滤有三种方式：<ul><li>根据Tag过滤：高效简单</li><li>SQL 表达式过滤：更加灵活</li><li>Filter Server 方式：最灵活，也是最复杂的一种方式，允许用户自定义函数进行过滤</li></ul></li></ol><h3 id="高可用（消息持久化）">高可用（消息持久化）</h3><ol><li>RocketMQ的高可用主要是在体现在Broker的读和写的高可用，Broker的高可用是通过<strong>主从集群</strong>实现的</li><li>Broker可以配置两种角色：Master和Slave<ul><li>Master角色的Broker支持读和写</li><li>Slave角色的Broker只支持读</li><li>Master会向Slave同步消息。</li><li>Producer只能向Master角色的Broker写入消息，Cosumer可以从Master和Slave角色的Broker读取消息。</li></ul></li><li>读的高可用：<strong>自动切换</strong><ul><li>Consumer 的配置文件中，并不需要设置是从 Master 读还是从 Slave读，当 Master 不可用或者繁忙的时候， Consumer 的读请求会被自动切换到从 Slave。有了自动切换 Consumer 这种机制，当一个 Master 角色的机器出现故障后，Consumer 仍然可以从 Slave 读取消息，不影响 Consumer 读取消息，这就实现了读的高可用。</li></ul></li><li>写的高可用：<strong>多Master</strong><ul><li>在创建 Topic 的时候，把 Topic 的多个Message Queue 创建在多个 Broker 组上（相同 Broker 名称，不同 brokerId机器组成 Broker 组），这样当 Broker 组的 Master 不可用后，其他组Master 仍然可用， Producer 仍然可以发送消息</li><li>RocketMQ 目前还不支持把Slave自动转成 Master ，如果机器资源不足，需要把 Slave 转成 Master ，则要手动停止 Slave 色的 Broker ，更改配置文件，用新的配置文件启动 Broker。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">消息队列RocketMQ简单了解</summary>
    
    
    
    <category term="中间件" scheme="https://xlxq.fun/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="消息队列，RocketMQ" scheme="https://xlxq.fun/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%8CRocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>消息队列概述</title>
    <link href="https://xlxq.fun/posts/487a8a3.html"/>
    <id>https://xlxq.fun/posts/487a8a3.html</id>
    <published>2024-01-12T11:18:02.000Z</published>
    <updated>2024-01-12T11:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1>消息队列</h1><p>消息队列源于消费者生产者模式，由生产者（Producer）、消息处理中心（Broker）、和消费者（Consumer）三者构成，一般有点对点和发布订阅两种模式：</p><ol><li>点对点模式：多个生产者向同一个队列发送消息，每个消息只能由一个消费者消费</li><li>发布订阅模式：每个消息都能被多个订阅者获取和处理</li></ol><h1>核心功能</h1><p>消息队列（MQ）提供三个核心功能：解耦、异步处理和削峰。</p><ol><li><strong>业务解耦</strong> 是指在分布式系统中，各组件或服务之间不直接通信，而是通过消息队列进行交互。这种方式使得各组件可以独立地进行更新和扩展，增强了系统的灵活性和可扩展性。例如，在电商平台中，订单服务和支付服务可以通过消息队列进行通信，互不影响，从而减少系统间的直接依赖。</li><li><strong>异步处理</strong> 意味着系统的不同部分可以在不同的时间处理信息，从而提高整体效率和响应速度。在异步模型中，一个服务可以发送消息到队列，而不需要等待接收服务的响应。这种模式在高流量应用中尤其重要，如社交媒体平台中的消息传递。</li><li><strong>流量削峰</strong> 指的是使用消息队列来应对短时间内的高流量。通过消息队列，可以平衡负载，确保系统在面对高峰流量时不会崩溃。例如，在促销或大型销售事件期间，消息队列可以帮助电子商务网站处理突发的大量订单请求。</li></ol><h1>特点</h1><p>作为消息队列中间件，需要具备以下能力：</p><ol><li><strong>消息持久化</strong>：确保在系统故障时消息不会丢失。</li><li><strong>高可用性和容错性</strong>：通过集群和故障转移机制确保系统的稳定运行。</li><li><strong>消息确认和可靠传递</strong>：保证消息被正确接收和处理。</li><li><strong>负载均衡</strong>：在多个生产者和消费者间有效分配消息。</li><li><strong>扩展性</strong>：支持根据负载增加节点以扩展系统。</li></ol><h1>常见消息队列</h1><h2 id="RabbitMQ">RabbitMQ</h2><p>少数几个支持 AMQP 协议的消息队列之一。很容易部署和使用。客户端支持多种编程语言。<br>但有以下缺点：</p><ul><li>对消息堆积的支持不好，当大量消息积压的时候，会导致 RabbitMQ 的性能急剧下降。</li><li>RabbitMQ的性能是这几个消息队列中最差的，大概每秒钟只能处理几万到十几万条消息。如果应用对消息队列的性能要求非常高，那么不要选择 RabbitMQ。</li><li>RabbitMQ使用的编程语言是Erlang，扩展和二次开发成本高。</li></ul><h2 id="Kafka">Kafka</h2><p>Kafka与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域，几乎所有的相关开源软件系统都会优先支持 Kafka。Kafka性能高效、可扩展良好并且可持久化。它的分区特性，可复制和可容错都是不错的。Kafka 使用 Scala 和Java 语言开发，设计上大量使用了批量和异步的思想，使得 Kafka能做到超高的性能。Kafka 的性能，尤其是异步收发的性能，是三者中最好的，但与 RocketMQ 并没有量级上的差异，大约每秒钟可以处理几十万条消息。<br>但有以下缺点：</p><ul><li>同步收发消息的响应时延比较高，因为当客户端发送消息的时候，Kafka 采用的是<strong>批量发送</strong>，在它的 Broker中，很多地方都会使用这种先攒一波再一起处理的设计。当业务场景中每秒钟消息数量没有那么多的时候，Kafka 的时延反而会比较高。所以，Kafka 不太适合在线业务场景。topic达到上百个时，吞吐量会大幅下降。<br>高性能的原因：</li></ul><ol><li>磁盘顺序读写：保证了消息的堆积<ul><li>顺序读写，磁盘会<strong>预读</strong>，预读即在读取的起始地址连续读取多个页面，比随机读写的速度快不少，因为免去了磁盘寻道的时间</li></ul></li><li>使用零拷贝：避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。</li><li>分区分段+索引：Kafka的message消息实际上是分布式存储在一个一个小的segment中的，每次文件操作也是直接操作的segment。为了进一步的查询优化，Kafka又默认为分段后的数据文件建立了索引文件，就是文件系统上的.index文件。这种分区分段+索引的设计，不仅提升了数据读取的效率，同时也提高了数据操作的并行度</li><li>批量压缩/读写：多条消息一起压缩，降低带宽</li><li>直接操作page cache，而不是JVM、避免GC耗时及对象创建耗时，且读写速度更高，进程重启缓存也不会丢</li></ol><h2 id="RocketMQ">RocketMQ</h2><p>RocketMQ 有着不错的性能，<strong>稳定性和可靠性</strong>，具备一个现代的消息队列应该有的几乎全部功能和特性，并且它还在持续的成长中。RocketMQ 有非常<strong>活跃的中文社区</strong>，大多数问题可以找到中文的答案。RocketMQ 使用 Java 语言开发，源代码相对比较容易读懂，容易对RocketMQ 进行扩展或者二次开发。RocketMQ 对<strong>在线业务</strong>的响应时延做了很多的优化，大多数情况下可以做到毫秒级的响应。</p>]]></content>
    
    
    <summary type="html">消息队列</summary>
    
    
    
    <category term="中间件" scheme="https://xlxq.fun/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="消息队列" scheme="https://xlxq.fun/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://xlxq.fun/posts/f1601c3e.html"/>
    <id>https://xlxq.fun/posts/f1601c3e.html</id>
    <published>2023-10-15T12:18:02.000Z</published>
    <updated>2023-10-15T12:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1>懒汉式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(singleton==<span class="literal">null</span>)&#123;  </span><br><span class="line">            singleton=<span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>饿汉式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton2 singleton2=<span class="keyword">new</span> <span class="title class_">Singleton2</span>();  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> singleton2;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>双重校验锁</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton3</span> &#123;  </span><br><span class="line"><span class="comment">//    创建一个对象，在JVM中会经过三步：  </span></span><br><span class="line"><span class="comment">//          （1）为singleton分配内存空间  </span></span><br><span class="line"><span class="comment">//          （2）初始化singleton对象  </span></span><br><span class="line"><span class="comment">//          （3）将singleton指向分配好的内存空间  </span></span><br><span class="line"><span class="comment">//在这个过程中2、3步可能发生指令重排序，因此需要使用volatile来修饰  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton3 singleton3;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">()</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="comment">// 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton   </span></span><br><span class="line">        <span class="keyword">if</span> (singleton3 == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="comment">// 线程A或线程B获得该锁进行初始化  </span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton3.class) &#123; </span><br><span class="line">            <span class="comment">// 其中一个线程进入该分支，另外一个线程则不会进入该分支</span></span><br><span class="line">                <span class="keyword">if</span> (singleton3 == <span class="literal">null</span>) &#123;   </span><br><span class="line">                    singleton3 = <span class="keyword">new</span> <span class="title class_">Singleton3</span>();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> singleton3;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>枚举</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton4</span> &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    Singleton4() &#123; System.out.println(<span class="string">&quot;枚举创建对象了&quot;</span>); &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>单例模式的线程安全问题</h1><p>在一般的单例模式实现中，如果没有特殊处理，是不具备线程安全性的。主要的问题在于多线程环境下可能会导致<strong>多个线程同时访问到未初始化完成的实例或者同时执行实例的创建操作</strong>，从而造成实例的不一致性或错误。<br>上述四种单例模式的实现中，饿汉式、双重校验锁、枚举都可以保证单例的线程安全</p><ol><li>饿汉式在类加载时就创建了实例，因此不会存在多线程环境下的竞争问题。但它可能会提前占用资源，因为无论是否使用，实例都会被创建</li><li>双重校验锁使用<code>volatile</code>关键字确保多线程环境下对<code>instance</code>变量的可见性，而双重检查锁定通过在锁内外都进行一次判空来提高性能</li><li>枚举类型在Java中天生就是单例的，且线程安全</li></ol>]]></content>
    
    
    <summary type="html">java基础知识</summary>
    
    
    
    <category term="java" scheme="https://xlxq.fun/categories/java/"/>
    
    
    <category term="java，设计模式" scheme="https://xlxq.fun/tags/java%EF%BC%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础</title>
    <link href="https://xlxq.fun/posts/fe29e710.html"/>
    <id>https://xlxq.fun/posts/fe29e710.html</id>
    <published>2023-09-18T10:19:03.000Z</published>
    <updated>2023-09-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redis（Remote Dictionary Server），即远程字典服务 !<br>是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API；redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步</p><h1>NoSQL</h1><img src="/post-img/Pasted image 20230922151933.png" alt="图片损坏" style="zoom:100%;" /><h1>redis特征</h1><p>键值（ key-value）型,value支持多种不同数据结构，功能丰富<br>单线程，<strong>每个命令具备原子性</strong>，在网络请求处理方面可以实现多线程<br>低延迟，速度快（<strong>基于内存</strong>、IO多路复用、良好的编码）<br>支持数据持久化<br>支持主从集群、分片集群<br>支持多语言客户端</p><h1>redis通用命令</h1><h2 id="help【command】">help【command】</h2><p>查看一个命令的具体用法</p><h2 id="KEYS-pattern">KEYS pattern</h2><p>查看符合模板的所有key<br>其中模板指的是redis自身的一些定义，相当于模糊匹配<br><img src="/post-img/Pasted image 20230922160409.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="DEL">DEL</h2><p>删除一个指定的key</p><h2 id="EXISTS">EXISTS</h2><p>判断key是否存在</p><h2 id="EXPIRE">EXPIRE</h2><p>给一个key设置有效期，有效期到期时该key会被自动删除</p><h2 id="TTL">TTL</h2><p>查看一个key的剩余有效期</p><h1>key的层级格式</h1><p>Redis没有类似MySQL中的Table的概念，s使用key的分层级形式来区分不同类型的key<br><img src="/post-img/Pasted image 20230922160953.png" alt="图片损坏" style="zoom:100%;" /></p><h1>redis的数据结构</h1><p>redis是键值对型数据库，其键一般是字符串，而值的类型多种多样，以下是一些常见的值的类型的介绍</p><h2 id="string">string</h2><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。<br>其value是字符串，不过根据字符串的格式不同，又可以分为3类:<br>string:普通字符串<br>int:整数类型，可以做自增、自减操作<br>float:浮点类型，可以做自增、自减操作<br>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.<br><img src="/post-img/Pasted image 20230922160736.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="hash">hash</h2><img src="/post-img/Pasted image 20230922161203.png" alt="图片损坏" style="zoom:100%;" /><img src="/post-img/Pasted image 20230922161224.png" alt="图片损坏" style="zoom:100%;" /><h2 id="list">list</h2><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。<br>既可以支持正向检索和也可以支持反向检索。<br>特征也与LinkedList类似：<br>有序；元素可以重复；插入和删除快；查询速度一般<br><img src="/post-img/Pasted image 20230922161424.png" alt="图片损坏" style="zoom:100%;" /><br>可以用list来模拟栈，队列，阻塞队列等数据结构<br>入口和出口在同一边----&gt;栈<br>入口和出口在不同边----&gt;队列<br>入口和出口在不同边，出队时采用BLPOP或BRPOP----&gt;阻塞队列</p><h2 id="set">set</h2><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。<br>因为也是一个hash表，因此具备与HashSet类似的特征：<br>无序；元素不可重复；查找快；支持交集、并集、差集等功能<br><img src="/post-img/Pasted image 20230922161828.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="sortedset">sortedset</h2><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。<br>SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个<br>跳表（SkipList）加 hash表。<br>SortedSet具备下列特性:<br>可排序；元素不重复；查询速度快<br>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。<br><img src="/post-img/Pasted image 20230922164154.png" alt="图片损坏" style="zoom:100%;" /></p><h1>redis的java客户端</h1><p>jedis：以Redis命令作为方法名称。学习成本低,简单实用。但是Jedis实例是线程不安全的,多线程环境卞需要基于连接池来使用<br>lettuce：是基于Netty实现的,支持同步、异步和响应式编程方式，并且是线程家全的。支持Redis的哨兵模式、集群模式和管道模式。</p><h2 id="jedis快速入门">jedis快速入门</h2><p>官网：[<a href="https://github.com/redis/jedis">https://github.com/redis/jedis</a>]<br>1.引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">grouprd</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">grouprd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.建立连接<br><img src="/post-img/Pasted image 20230922164616.png" alt="图片损坏" style="zoom:100%;" /><br>3.测试string<br><img src="/post-img/Pasted image 20230922164635.png" alt="图片损坏" style="zoom:100%;" /><br>4.释放资源<br><img src="/post-img/Pasted image 20230922164647.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="jedis连接池">jedis连接池</h2><p>jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗<br>因此使用jedis连接池代替jedis的直连方式<br><img src="/post-img/Pasted image 20230922164951.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="SpringDataRedis">SpringDataRedis</h2><p>springdata是spring中数据操作的模块，包含对各种数据的集成，其中对redis的集成模块就是SpringDataRedis，官网:[https:/lsprina.io/proiects/spring-data-redis]<br>它提供了如下功能和便利：<br>1.提供了对不同Redis客户端的整合（Lettuce和Jedis）<br>2.提供了RedisTemplate统一API来操作Redis<br>3.支持Redis的发布订阅模型<br>4.支持Redis哨兵和Redis集群<br>5.支持基于Lettuce的响应式编程<br>6.支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化<br>7.支持基于Redis的JDKCollection实现</p><h3 id="快速入门">快速入门</h3><p>1.引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Redis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupid</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--连接池依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupid</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupid</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">redis:</span></span><br><span class="line"><span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">password:</span> <span class="number">123321</span></span><br><span class="line"><span class="attr">lettuce:</span></span><br><span class="line"><span class="attr">pool:</span></span><br><span class="line"><span class="attr">max-active:</span> <span class="number">8</span><span class="comment">#最大连接</span></span><br><span class="line"><span class="attr">max-idle:</span> <span class="number">8</span><span class="comment">#晟大空闲连接</span></span><br><span class="line"><span class="attr">min-idle:</span> <span class="number">0</span><span class="comment">#最小空闲连接</span></span><br><span class="line"><span class="attr">max-wait:</span> <span class="number">100</span> <span class="comment">#连接等待时间</span></span><br></pre></td></tr></table></figure><p>3.注入RedisTemplate</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate</span><br></pre></td></tr></table></figure><p>4.编写测试<br><img src="/post-img/Pasted image 20230922165941.png" alt="图片损坏" style="zoom:100%;" /><br>如果要操作其它数据类型，可以参照下表以及redis中各数据类型的命令（jedis中的方法名与命令名相同），用下表的对应类调用对应方法<br><img src="/post-img/Pasted image 20230922165439.png" alt="图片损坏" style="zoom:100%;" /></p><h3 id="序列化方式">序列化方式</h3><p>RedisTemplate可以接受任意Object作为值写入redis，但是写入前会把Object序列化为字节形式，默认是采用JDK序列化，这样做使得值的可读性差，并且内存占用较大，为了解决这个问题，有两种方式<br><strong>自定义RedisTemplate的序列化方式</strong><br><img src="/post-img/Pasted image 20230922170235.png" alt="图片损坏" style="zoom:100%;" /></p><p>以上是采用jackson序列化的示例，注意需要引入jackson依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>尽管它能改善可读性差的问题，但是为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。<br><strong>使用Spring提供的一个StringRedisTemplate类</strong><br>为了节省内存空间，我们并不会使用JSON序列化器来处理value，而是统一使用String序列化器，它要求只能存储String类型的key和value。当需要存储Java对象时，我们需要<strong>手动完成</strong>对象的序列化和反序列化。<br>StringRedisTemplate的key和value的序列化方式默认就是String方式。省去了我们自定义RedisTemplate的过程<br><img src="/post-img/Pasted image 20230922170840.png" alt="图片损坏" style="zoom:100%;" /><br><img src="/post-img/Pasted image 20230922171119.png" alt="图片损坏" style="zoom:100%;" /></p><h1>事务和乐观锁</h1><h2 id="事务">事务</h2><p>1.原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的操作要么都做，要么都不做。<br>2.一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。<br>3.隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。<br>4.持久性（durability）。持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。<br>在Redis事务没有隔离级别的概念！<br>在Redis单条命令是保证原子性的，但是事务不保证原子性！</p><h2 id="乐观锁">乐观锁</h2><p>1.当程序中可能出现并发的情况时，就需要保证在并发情况下数据的准确性，以此确保当前用户和其他用户一起操作时，所得到的结果和他单独操作时的结果是一样的。<br>2.没有做好并发控制，就可能导致脏读、幻读和不可重复读等问题。<br>在Redis是可以实现乐观锁的！</p><h2 id="事务的实现">事务的实现</h2><p>一、Redis如何实现事务？<br>1.正常执行事务<br><img src="/post-img/Pasted image 20230930154014.png" alt="图片损坏" style="zoom:100%;" /><br>2.放弃事务<br><img src="/post-img/Pasted image 20230930154026.png" alt="图片损坏" style="zoom:100%;" /><br>3.编译时异常，代码有问题，或者命令有问题，所有的命令都不会被执行<br><img src="/post-img/Pasted image 20230930154041.png" alt="图片损坏" style="zoom:100%;" /><br>4.运行时异常，除了语法错误不会被执行且抛出异常后，其他的正确命令可以正常执行<br><img src="/post-img/Pasted image 20230930154059.png" alt="图片损坏" style="zoom:100%;" /><br>5.总结：由以上可以得出结论，Redis是支持单条命令事务的，但是事务并不能保证原子性！</p><h2 id="乐观锁的实现">乐观锁的实现</h2><p>1.watch（监视）<br><img src="/post-img/Pasted image 20230930154234.png" alt="图片损坏" style="zoom:100%;" /><br>2.多线程测试watch<br><img src="/post-img/Pasted image 20230930154302.png" alt="图片损坏" style="zoom:100%;" /><br><img src="/post-img/Pasted image 20230930154313.png" alt="图片损坏" style="zoom:100%;" /><br>3.总结：乐观锁和悲观锁的区别：<br>悲观锁： 什么时候都会出问题，所以一直监视着，没有执行当前步骤完成前，不让任何线程执行，十分浪费性能！一般不使用！<br>乐观锁： 只有更新数据的时候去判断一下，在此期间是否有人修改过被监视的这个数据，没有的话正常执行事务，反之执行失败！</p><h1>持久化</h1><p>Redis 是<strong>内存数据库</strong>，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 Redis 提供了<strong>持久化功能</strong> !</p><h2 id="RDB（Redis-DataBase）">RDB（Redis DataBase）</h2><p>RDB持久化是Redis的一种快照持久化方式，它可以将内存中的数据周期性地保存到磁盘上的一个二进制文件中。这个文件包含了某个时间点上的所有数据，以及服务器的状态信息。RDB持久化的主要特点和步骤如下：</p><ol><li><strong>快照生成</strong>：Redis会定期生成一个快照文件，保存当前数据和服务器状态。你可以通过配置Redis的<code>save</code>指令来指定生成快照的条件，比如多少秒内至少有多少个写操作。</li><li><strong>生成快照文件</strong>：生成快照文件时，Redis会 fork 一个子进程来执行实际的快照生成操作，而父进程则继续响应客户端请求。这样可以确保持久化操作不会阻塞Redis的正常服务。</li><li><strong>保存到磁盘</strong>：生成的快照文件会被保存到磁盘上的一个文件中。</li><li><strong>加载快照</strong>：当Redis服务器启动时，它会检查是否存在RDB快照文件，如果存在，就会加载该文件并将数据还原到内存中。</li></ol><p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。<br>这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。我们默认的就是RDB，一般情况下不需要修改这个配置！在生产环境我们会将这个文件进行备份！</p><h3 id="快照生成机制（生成dump-rdb文件）">快照生成机制（生成dump.rdb文件）</h3><p>1.在redis的配置文件中修改对应区域可以指定快照生成的条件，满足条件生成快照<br><img src="/post-img/Pasted image 20230930155617.png" alt="图片损坏" style="zoom:100%;" /><br><img src="/post-img/Pasted image 20230930155652.png" alt="图片损坏" style="zoom:100%;" /><br>2.执行flushall命令，也会触发rdb规则<br>3.退出Redis，也会触发rdb规则<br>4.手动执行save命令生成快照文件</p><h3 id="恢复快照文件">恢复快照文件</h3><p>一般redis每次重启时会自动加载快照文件，实现持久化<br>1、只需将备份的rdb文件放在我们的redis启动目录即可，Redis启动的时候会自动检查dump.rdb文件并恢复其中的数据！<br>2、查找文件位置的命令：</p><h3 id="优缺点">优缺点</h3><p>优点：<br>1、适合大规模的数据恢复！<br>2、对数据的完整性要求不高！<br>3、性能高：生成快照时使用了子进程，不会影响正常的读写操作<br>4、生成的快照文件紧凑，适用于备份和恢复<br>缺点：<br>1、需要一定的时间间隔进程操作！如果redis意外宕机了，这个最后一次修改数据就没有的了！<br>2、fork进程的时候，会占用一定的内容空间！<br>3、不适用于实时数据备份：生成快照的频率较低，不适用于要求实时数据备份的场景。</p><h2 id="AOF（Append-Only-File）">AOF（Append Only File）</h2><p>Redis默认使用的是RDB模式，所以需要手动开启AOF模式，在配置文件中将下图中的no改为yes<br><img src="/post-img/Pasted image 20230930160809.png" alt="图片损坏" style="zoom:100%;" /><br>开启AOF模式后，redis会自动保存从这次启动redis服务器以来操作的命令，并记录到appendonly.aof文件中，从Redis 2.0版本开始，AOF持久化就已经是默认启用的持久化方式。</p><h3 id="appendonly-aof错误修复">appendonly.aof错误修复</h3><p>由于appendonly.aof文件是可读写的，因此有可能产生错误或遭到破坏，可以通过以下方法修复</p><ol><li><strong>备份原始AOF文件</strong>：首先，确保在尝试恢复之前备份原始的<code>appendonly.aof</code>文件。这可以帮助你在恢复过程中避免进一步的数据损坏。</li><li><strong>检查文件完整性</strong>：使用文本编辑器打开<code>appendonly.aof</code>文件，并检查文件是否完整和有效。有时，AOF文件可能会因某种原因损坏，导致无法正常解析其中的命令。如果文件完全无法打开或损坏严重，可能需要查看备份或考虑其他数据恢复方式。</li><li><strong>手动编辑文件</strong>：如果文件中只有一小部分数据受损，可以尝试手动编辑文件，修复损坏的部分。这可能需要一些Redis命令和AOF文件格式的了解。务必小心操作，以免进一步破坏文件。</li><li><strong>使用Redis-check-aof工具</strong>：Redis提供了一个名为<code>redis-check-aof</code>的工具，可以用于检查AOF文件的有效性并尝试修复其中的问题。可以通过以下命令来使用它：<code>redis-check-aof --fix &lt;AOF文件路径&gt;</code><br>该命令将尝试修复AOF文件中的问题，并在修复完成后生成一个修复后的文件（通常带有<code>.fixed</code>扩展名）。可以将修复后的文件重命名为<code>appendonly.aof</code>并替换原始文件。<br>注意虽然错误的内容少了，但是正确的也有一定的丢失！所以这个修复无法做到百分百修复！</li><li><strong>重新加载AOF文件</strong>：如果成功修复了AOF文件或者恢复了损坏的部分，可以重新启动Redis服务器以加载AOF文件中的命令并还原数据。</li></ol><h3 id="设置appendonly-aof文件大小">设置appendonly.aof文件大小</h3><p>aof默认的就是文件的无限追加，文件会越来越大！在配置文件中可以设置文件的大小！<br><img src="/post-img/Pasted image 20230930161737.png" alt="图片损坏" style="zoom:100%;" /></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>-aof-rewrite-percentage <span class="number">100</span> #写入百分比 </span><br><span class="line"><span class="keyword">auto</span>-aof-rewrite-min-size <span class="number">64</span>mb #写入的文件最大值是多少，一般在实际工作中我们会将其设置为<span class="number">5</span>gb左右！</span><br></pre></td></tr></table></figure><h3 id="优缺点-2">优缺点</h3><p>优点：</p><ol><li><strong>可读性和透明性</strong>：AOF文件是一个可读性的文本文件，它记录了每个写操作的命令。这使得AOF文件易于查看和理解，有助于调试和分析。</li><li><strong>实时备份</strong>：AOF模式以追加的方式记录每个写操作，这意味着数据变化会立即被记录到AOF文件中。这使得AOF模式适用于实时数据备份需求。每一次修改都同步，文件的完整性会更加好</li><li><strong>可靠性</strong>：AOF文件采用了追加写入方式，相对于RDB持久化，更不容易损坏。即使在写入过程中发生意外宕机，已经写入的数据不会丢失。每秒同步一次，最多会丢失一秒的数据</li><li><strong>重写机制</strong>：Redis提供了AOF文件的重写机制，允许定期对AOF文件进行重新压缩和优化。这可以控制AOF文件的大小，避免无限增长。</li><li><strong>数据恢复</strong>：AOF文件记录了写操作的历史，因此可以用于恢复数据。在Redis服务器启动时，AOF文件中的命令将会重新执行，还原数据。<br>缺点：</li><li><strong>文件大小</strong>：AOF文件通常会随着时间的推移逐渐增大，特别是在高写入负载下。较大的AOF文件可能占用大量磁盘空间，因此需要定期进行AOF文件的重写和优化。</li><li><strong>写入性能</strong>：相对于RDB持久化，AOF持久化在高写入负载下可能会稍微降低性能，因为每个写操作都要追加到AOF文件中。</li><li><strong>文件恢复时间</strong>：如果AOF文件过大，Redis服务器在启动时加载AOF文件的时间可能会较长，因为需要重新执行大量写操作。</li><li><strong>数据丢失风险</strong>：虽然AOF文件相对可靠，但在某些极端情况下，可能会出现数据丢失。例如，如果AOF文件在写入期间发生了损坏，那么写入的数据可能会丢失。</li></ol><h2 id="两种方式对比和总结">两种方式对比和总结</h2><p>1、RDB 持久化方式能够在指定的时间间隔内对数据进行快照存储<br>2、AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。<br>3、只做缓存，如果只希望数据在服务器运行的时候存在，也可以不使用任何持久化<br>4、同时开启两种持久化方式时，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。<br>RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，但建议不要只使用AOF，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。<br>5.一般情况下无脑两种一起用，此外<br><strong>使用AOF持久化的情况</strong>：</p><ol><li><strong>实时备份需求</strong>：如果你需要实时备份数据以确保数据不会丢失，AOF持久化是更好的选择。AOF以追加方式记录每个写操作，确保数据变更会立即记录到AOF文件中。</li><li><strong>可读性和调试需求</strong>：AOF文件是可读性的文本文件，易于查看和理解其中的命令。这对于调试和分析非常有用。</li><li><strong>数据恢复要求</strong>：AOF文件记录了写操作的历史，因此可以用于数据恢复。在Redis服务器启动时，AOF文件中的命令将会重新执行，还原数据。</li><li><strong>数据一致性要求高</strong>：AOF模式相对可靠，即使在写入过程中发生宕机，已经写入的数据不会丢失，因此适用于要求数据一致性高的场景。<br><strong>使用RDB持久化的情况</strong>：</li><li><strong>周期性备份需求</strong>：如果你只需要定期备份数据，而不需要实时备份，RDB持久化是一种有效的选择。RDB生成全量快照，适用于周期性的备份操作。</li><li><strong>磁盘空间有限</strong>：RDB文件通常比较小，适用于磁盘空间有限的情况。如果你的磁盘空间有限，可以考虑使用RDB持久化。</li><li><strong>启动速度要求</strong>：在Redis服务器启动时，加载RDB文件比加载大型AOF文件更快。如果需要快速启动，可以选择RDB持久化。</li><li><strong>性能优化</strong>：在某些高性能场景下，RDB持久化可能会比AOF持久化更适合，因为RDB生成快照的性能开销较小。</li></ol><h2 id="性能建议">性能建议</h2><p>1.因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留 save 900 1 这条规则。<br>2.如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率<br>AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。<br>3.如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。</p><h1>发布订阅</h1><p>Redis发布订阅（pub/sub）是一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接受消息。<br><img src="/post-img/Pasted image 20230930174823.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="实现">实现</h2><p>订阅端<br><img src="/post-img/Pasted image 20230930174926.png" alt="图片损坏" style="zoom:100%;" /><br>发送端<br><img src="/post-img/Pasted image 20230930174936.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="常用命令">常用命令</h2><p><strong>发布消息到指定频道</strong>：<br><strong>PUBLISH</strong>：将消息发布到指定的频道。<br><code>PUBLISH channel message</code><br>- <code>channel</code>：指定要发布消息的频道名称。<br>- <code>message</code>：要发布的消息内容。<br><strong>订阅频道</strong>：</p><ol><li><strong>SUBSCRIBE</strong>：订阅一个或多个频道。<br><code>SUBSCRIBE channel [channel ...]</code><ul><li><code>channel</code>：一个或多个频道名称，可以同时订阅多个频道。</li></ul></li><li><strong>PSUBSCRIBE</strong>：通过正则表达式订阅匹配的频道。<br><code>PSUBSCRIBE pattern [pattern ...]</code><ul><li><code>pattern</code>：一个或多个正则表达式，用于匹配多个频道名称。<br><strong>取消订阅频道</strong>：</li></ul></li><li><strong>UNSUBSCRIBE</strong>：取消订阅一个或多个频道。<br><code>UNSUBSCRIBE [channel [channel ...&quot; alt=&quot;图片损坏&quot; style=&quot;zoom:100%;&quot; /&gt;</code><ul><li><code>channel</code>：要取消订阅的频道名称，如果未提供任何频道名称，则取消所有频道的订阅。</li></ul></li><li><strong>PUNSUBSCRIBE</strong>：通过正则表达式取消订阅匹配的频道。<br><code>PUNSUBSCRIBE [pattern [pattern ...&quot; alt=&quot;图片损坏&quot; style=&quot;zoom:100%;&quot; /&gt;</code><ul><li><code>pattern</code>：要取消订阅的正则表达式，如果未提供任何正则表达式，则取消所有匹配的频道的订阅。<br><strong>查看订阅频道</strong>：</li></ul></li><li><strong>SUBSCRIBE</strong> 和 <strong>PSUBSCRIBE</strong> 命令会返回关于订阅状态的信息。你可以使用以下命令来查看当前订阅的频道和模式：<ul><li><code>PUBSUB CHANNELS</code>：列出当前活动的频道。</li><li><code>PUBSUB NUMSUB channel [channel ...]</code>：获取指定频道的订阅者数量。</li><li><code>PUBSUB NUMPAT</code>：获取匹配的模式数量。</li></ul></li></ol><h1>主从复制</h1><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)；数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave 以读为主。<br>主要作用：<br>1.数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。<br>2.故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。<br>3.负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。<br>4.高可用（集群）基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</p><h2 id="环境配置（单机集群）">环境配置（单机集群）</h2><p>1.基本查看命令info replication<br><img src="/post-img/Pasted image 20230930175500.png" alt="图片损坏" style="zoom:100%;" /><br>2.例开启三台服务<br><img src="/post-img/Pasted image 20230930175635.png" alt="图片损坏" style="zoom:100%;" /><br>3.全部启动并查看<br><img src="/post-img/Pasted image 20230930175658.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="单机测试（一主二从）">单机测试（一主二从）</h2><p>1.任命一台服务器为主节点，其它服务器为从节点slaveof  IP port<br><img src="/post-img/Pasted image 20230930175810.png" alt="图片损坏" style="zoom:100%;" /><br>2.从主节点处查看信息info replication<br><img src="/post-img/Pasted image 20230930175847.png" alt="图片损坏" style="zoom:100%;" /><br>3.以上的配置是一次性的，如果断电、宕机等，就要重新任命<br>可以通过修改配置文件来实现永久配置<br><img src="/post-img/Pasted image 20230930180117.png" alt="图片损坏" style="zoom:100%;" /><br>4.测试读写操作<br>主机写，从机可读<br>主机死，从机可读<br>主机复活，从机自动寻找主机（配置文件配置时）<br>从机死，不可重连（命令配置时）<br>从机只能读，不能写</p><h2 id="原理">原理</h2><p>Slave 启动成功连接到 master 后会发送一个sync同步命令<br>Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。</p><p>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。<br>增量复制： Master 继续将新的所有收集到的修改命令依次传给slave，完成同步但是只要是重新连接master，一次完全同步（全量复制）将被自动执行！ 我们的数据一定可以在从机中看到</p><h2 id="从机的从机">从机的从机</h2><p>层层链路<br><img src="/post-img/Pasted image 20230930180522.png" alt="图片损坏" style="zoom:100%;" /><br>从机可以有自己的从机（主从机的概念是相对的）</p><h2 id="主机转移（谋朝篡位）">主机转移（谋朝篡位）</h2><p>使用<code>SLAVEOF no one</code>让自己变成主机！其他的节点就可以手动连接到最新的这个主节点（手动）<br>如果主机复活，重新成为从机</p><h2 id="小结">小结</h2><p>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的（宕机），原因如下：<br>1、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；<br>2、从容量上，单个Redis服务器内存容量有限，就算一Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该20G。<br>主从复制，读写分离！ 80% 的情况下都是在进行读操作！减缓服务器的压力！架构中经常使用！ 一主二从！<br>只要在公司中，主从复制就是必须要使用的，因为在真实的项目中不可能单机使用Redis！</p><h1>哨兵模式</h1><p>是对主从复制的补充<br>主机断开后，我们得手动设置另一个从机变成主机！这是不智能的！在实际工作中，我们都是用哨兵模式来自动切换主机。Redis从2.8开始正式提供了Sentinel（哨兵） 架构，后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。<br>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的 <strong>进程</strong> ，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</p><h2 id="配置哨兵">配置哨兵</h2><p>1.添加哨兵配置文件sentinel.conf<br>内容如下：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sentinel monitor 被监控的名称 host port 1 （代表自动投票选举大哥！）</span></span><br><span class="line">sentinel<span class="built_in"> monitor </span>myredis 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure><p>2.启动哨兵</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel sentinel配置文件路径   <span class="meta">#和启动Redis一致</span></span><br></pre></td></tr></table></figure><p>3.准备测试环境（一主二从三台服务器）<br>4.测试主机宕机后自动选取大哥，如果主机此时回来了，只能归并到新的主机下，当做从机，这就是哨兵模式的规则！等待哨兵的默认配置时间时是30 秒！</p><h2 id="优缺点-3">优缺点</h2><p>优点<br>1.哨兵集群基于主从复制模式 ，所有的主从配置优点，它全有<br>2.主从可以切换，故障可以转移 ，系统的 可用性 就会更好<br>3.哨兵模式就是主从模式的升级，手动到自动，更加健壮<br>缺点<br>1.Redis 不好在线扩容 的，集群容量一旦到达上限，在线扩容就十分麻烦！<br>2.实现哨兵模式的配置其实是很 麻烦 的，里面有很多选择！<br>注意<br>以上所有的配置因为条件所限都是基于单机集群的前提下！正式集群下的多哨兵模式如下图：<br><img src="/post-img/Pasted image 20230930181510.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="哨兵的配置文件解析">哨兵的配置文件解析</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"># Example sentinel.conf </span><br><span class="line"></span><br><span class="line"># 哨兵sentinel实例运行的端口 默认<span class="number">26379</span> </span><br><span class="line">port <span class="number">26379</span> </span><br><span class="line"></span><br><span class="line"># 哨兵sentinel的工作目录 </span><br><span class="line">dir /tmp </span><br><span class="line"></span><br><span class="line"># 哨兵sentinel监控的redis主节点的 ip port </span><br><span class="line"># master-name 可以自己命名的主节点名字 只能由字母A-z、数字<span class="number">0</span><span class="number">-9</span> 、这三个字符<span class="string">&quot;.-_&quot;</span>组成。 </span><br><span class="line"># quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了 </span><br><span class="line"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt; sentinel monitor mymaster <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span> <span class="number">2</span> </span><br><span class="line"></span><br><span class="line"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供 密码</span><br><span class="line"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码 </span><br><span class="line"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt; </span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret<span class="number">-0123</span>passw0rd </span><br><span class="line"></span><br><span class="line"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认<span class="number">30</span>秒 </span><br><span class="line"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt; </span><br><span class="line">sentinel down-after-milliseconds mymaster <span class="number">30000</span> </span><br><span class="line"></span><br><span class="line"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步</span><br><span class="line">#这个数字越小，完成failover所需的时间就越长，</span><br><span class="line"># 但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。 </span><br><span class="line">#可以通过将这个值设为 <span class="number">1</span> 来保证每次只有一个slave 处于不能处理命令请求的状态。 </span><br><span class="line"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt; </span><br><span class="line">sentinel parallel-syncs mymaster <span class="number">1</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面： </span><br><span class="line">#<span class="number">1.</span> 同一个sentinel对同一个master两次failover之间的间隔时间。 </span><br><span class="line">#<span class="number">2.</span> 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那 里同步数据时。 </span><br><span class="line">#<span class="number">3.</span>当想要取消一个正在进行的failover所需要的时间。 </span><br><span class="line">#<span class="number">4.</span>当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时， slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了 </span><br><span class="line"># 默认三分钟 # sentinel failover-timeout &lt;master-name&gt; </span><br><span class="line">sentinel failover-timeout mymaster <span class="number">180000</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># SCRIPTS EXECUTION #配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知 相关人员。 </span><br><span class="line">#对于脚本的运行结果有以下规则： </span><br><span class="line">#若脚本执行后返回<span class="number">1</span>，那么该脚本稍后将会被再次执行，重复次数目前默认为<span class="number">10</span> #若脚本执行后返回<span class="number">2</span>，或者比<span class="number">2</span>更高的一个返回值，脚本将不会重复执行。 </span><br><span class="line">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为<span class="number">1</span>时的行为相同。 </span><br><span class="line">#一个脚本的最大执行时间为<span class="number">60</span>s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。 </span><br><span class="line">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等）， 将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信 息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配 置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无 法正常启动成功。 </span><br><span class="line">#通知脚本 </span><br><span class="line"># shell编程 </span><br><span class="line"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt; </span><br><span class="line">sentinel notification-script mymaster /var/redis/notify.sh </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 客户端重新配置主节点参数脚本 </span><br><span class="line"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已 经发生改变的信息。 </span><br><span class="line"># 以下参数将会在调用脚本时传给脚本: </span><br><span class="line"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;<span class="keyword">from</span>-ip&gt; &lt;<span class="keyword">from</span>-port&gt; &lt;to-ip&gt; &lt;to-port&gt; </span><br><span class="line"># 目前&lt;state&gt;总是“failover”, </span><br><span class="line"># &lt;role&gt;是“leader”或者“observer”中的一个。 </span><br><span class="line"># 参数 <span class="keyword">from</span>-ip, <span class="keyword">from</span>-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通 信的</span><br><span class="line"># 这个脚本应该是通用的，能被多次调用，不是针对性的。 </span><br><span class="line"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt; </span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh </span><br><span class="line"># 一般都是由运维来配置！</span><br></pre></td></tr></table></figure><h1>缓存穿透</h1><p>用户需要查询一个数据，但是redis中没有（比如说mysql中id=-1的数），直接去请求MySQL，当很多用户同时请求并且都没有命中！于是都去请求了持久层的数据库，那么这样会给持久层数据库带来非常大的压力。一般出现这样的情况都不是正常用户，基本上都是恶意用户！<br><strong>缓存穿透前提是：Redis和MySQL中都没有，然后不停的直接请求MySQL。</strong></p><h2 id="解决方案">解决方案</h2><h3 id="布隆过滤器">布隆过滤器</h3><img src="/post-img/Pasted image 20230930181912.png" alt="图片损坏" style="zoom:100%;" />布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则  丢弃，从而避免了对底层存储系统的查询压力；<h3 id="缓冲空对象">缓冲空对象</h3><img src="/post-img/Pasted image 20230930181949.png" alt="图片损坏" style="zoom:100%;" />当存储层查不到，即使是空值，我们也将其存储起来并且在Redis中设置一个过期时间，之后再访问这个数据将会从Redis中访问，保护了持久层的数据库！但是如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多  的空值的键；  即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。<h1>缓存击穿</h1><p>是指一个非常热点的key，在不停的扛着大并发，当这个key失效时，一瞬间大量的请求冲到持久层的数据库中，就像在一堵墙上某个点凿开了一个洞！</p><h2 id="解决方案-2">解决方案</h2><p>1.设置热点key永不过期<br>从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。这样做其实并不合理<br>2.加互斥锁<br>在查询持久层数据库时，保证了只有一个线程能够进行持久层数据查询，其他的线程让它睡眠几百毫秒，等待第一个线程查询完会回写到Redis缓存当中，剩下的线程可以正常查询Redis缓存，就不存在大量请求去冲击持久层数据库了！<br><img src="/post-img/Pasted image 20230930182240.png" alt="图片损坏" style="zoom:100%;" /></p><h1>缓存雪崩</h1><p>在某一个时间段，缓存的key大量集中同时过期了，所有的请求全部冲到持久层数据库上，导致持久层数据库挂掉！<br>范例：双十一零点抢购，这波商品比较集中的放在缓存，设置了失效时间为1个小时，那么到了零点，这批缓存全部失效了，而大量的请求过来时，全部冲过了缓存，冲到了持久层数据库！</p><h2 id="解决方案-3">解决方案</h2><h3 id="Redis高可用">Redis高可用</h3><p>搭建Redis集群，既然redis有可能挂掉，那么多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。（异地多活！）</p><h3 id="限流降级">限流降级</h3><p>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p><h3 id="数据预热">数据预热</h3><p>数据加热的含义就是在正式部署之前，先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀 。</p>]]></content>
    
    
    <summary type="html">redis</summary>
    
    
    
    <category term="redis" scheme="https://xlxq.fun/categories/redis/"/>
    
    
    <category term="redis" scheme="https://xlxq.fun/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="https://xlxq.fun/posts/151f44ae.html"/>
    <id>https://xlxq.fun/posts/151f44ae.html</id>
    <published>2023-09-15T12:18:02.000Z</published>
    <updated>2023-09-15T12:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1>什么是线程安全</h1><p>线程安全（Thread Safety）是指在多线程环境下，一个程序或者代码段能够在<strong>并发</strong>执行的情况下正确地执行，不会产生意外的结果。确保线程安全是多线程编程中一个非常重要的概念，因为在多线程环境下，多个线程可能同时访问和修改共享的数据，如果不进行适当的同步和保护，可能导致数据不一致、不确定的行为或者程序崩溃。</p><h2 id="线程安全的关键点">线程安全的关键点</h2><ol><li><strong>原子性（Atomicity）：</strong> 原子操作是指一个操作是不可中断的，要么全部执行成功，要么全部不执行，不会出现部分执行的情况。在多线程环境下，确保某个操作是原子的可以避免竞态条件（Race Condition）。</li><li><strong>可见性（Visibility）：</strong> 当一个线程对共享变量进行了修改，其他线程应该能够立即看到这个修改。Java中使用<code>volatile</code>关键字可以保证变量的可见性。</li><li><strong>有序性（Ordering）：</strong> 确保指令执行的顺序按照程序的顺序来执行。在Java中，通过synchronized关键字、Lock接口等机制可以保证代码块的有序性。</li><li><strong>不变性（Immutability）：</strong> 使用不可变对象或者通过其他手段确保对象在多线程环境中不能被修改，从而避免竞态条件。</li></ol><h2 id="实现线程安全">实现线程安全</h2><ol><li><strong>加锁机制：</strong> 使用<code>synchronized</code>关键字或者<code>ReentrantLock</code>等锁机制来确保在同一时刻只有一个线程能够访问共享资源，从而避免竞态条件。</li><li><strong>原子类：</strong> Java提供了一些原子类（如<code>AtomicInteger</code>、<code>AtomicLong</code>等），这些类的操作是原子的，不需要额外的同步。</li><li><strong>线程局部变量（Thread-Local Variables）：</strong> 使用<code>ThreadLocal</code>可以为每个线程提供独立的变量副本，避免了共享变量的修改冲突。</li><li><strong>不可变对象：</strong> 创建不可变对象，确保对象一旦被创建就不能被修改，从而避免多线程环境中的数据竞争。</li><li><strong>使用并发集合：</strong> Java提供了一些并发集合类（如<code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>等），它们内部实现了线程安全机制，可以在多线程环境下安全地使用。</li></ol><h1>ThreadLocal</h1><ol><li><code>ThreadLocal</code> 是 Java 中的一个特殊类，用于在多线程环境中保持<strong>变量的线程本地副本</strong>。它并不直接保证线程安全，而是通过为每个线程提供独立的变量副本来避免线程间的竞争和共享。</li><li><code>ThreadLocal</code> 使用一个特殊的数据结构来维护每个线程的变量副本，这样每个线程都可以独立地修改自己的副本而不会影响其他线程的副本。这种方式在一些场景下非常有用，比如在线程池中处理任务时，每个任务都可以独立地访问和修改自己的数据，而不用担心线程安全问题。</li><li>使用<code>ThreadLocal</code>有两个作用：<ul><li>线程内资源全局共享</li><li>线程间资源互相隔离</li></ul></li></ol><h3 id="用法示例">用法示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">常用方法：get(),set(object),remove()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 在主线程设置 ThreadLocal 变量</span></span><br><span class="line">        threadLocal.set(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动两个新线程，它们会访问各自独立的 ThreadLocal 变量副本</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">100</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 1: &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 2: &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在主线程获取 ThreadLocal 变量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Main Thread: &quot;</span> + threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">Thread <span class="number">1</span>: <span class="number">100</span></span><br><span class="line">Thread <span class="number">2</span>: <span class="literal">null</span></span><br><span class="line">Main Thread: <span class="number">42</span></span><br></pre></td></tr></table></figure><h2 id="原理">原理</h2><p>一个ThreadLocal内部维护了一个ThreadLocalMap，类似于HashMap，当在某个线程中调用其set方法时，会将该线程id作为键，传入参数作为值存入其中；<br>因为map的键必须唯一，所以每个线程只有一个存储的空间，如果需要存储多个变量，可以采用如下办法：</p><ol><li>创建一个包含多个变量的类，然后将这个类的实例存储在一个ThreadLocal中</li><li>使用多个ThreadLocal，每个ThreadLocal保存不同的值</li></ol><h2 id="使用ThreadLocal注意事项">使用ThreadLocal注意事项</h2><p>使用<code>ThreadLocal</code>时，需要注意一些问题以确保正确的使用和避免潜在的错误。下面是一些建议和注意事项：</p><ol><li><strong>ThreadLocal的生命周期：</strong> <strong>ThreadLocal存储的数据与线程的生命周期相关联</strong>。如果线程池中的线程被重用，可能会导致上一次的<code>ThreadLocal</code>数据残留。确保<strong>在线程池中使用</strong><code>ThreadLocal</code>时，在任务执行结束后及时清理相关的<code>ThreadLocal</code>数据。</li><li><strong>手动清理ThreadLocal：</strong> 在使用完<code>ThreadLocal</code>后，尽量手动调用<code>remove</code>方法清理<code>ThreadLocal</code>中的数据。可以使用<code>try-finally</code>块确保在任何情况下都能正确清理。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;  使用ThreadLocal &#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;   threadLocalVariable.remove(); &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>避免内存泄漏：</strong> 由于<code>ThreadLocal</code>的生命周期与线程相绑定，如果在应用中存在很多线程，并且频繁使用<code>ThreadLocal</code>，可能导致内存泄漏。确保使用完<code>ThreadLocal</code>后及时清理，以免过多的<code>ThreadLocal</code>实例占用内存。</li><li><strong>适当使用初始化值：</strong> 可以通过<code>ThreadLocal</code>的<code>withInitial</code>方法在获取线程本地变量时设置默认值。这有助于避免在未设置值时返回<code>null</code>等不可预测的情况。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocalVariable = </span><br><span class="line">ThreadLocal.withInitial(() -&gt; <span class="string">&quot;Default&quot;</span>);</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>不要滥用ThreadLocal：</strong> <code>ThreadLocal</code>是一种方便的工具，但滥用可能导致代码不易理解，尤其是在大规模的并发环境中。在适当的情况下使用，不要过度依赖它。</li><li><strong>清理资源：</strong> 如果<code>ThreadLocal</code>中存储的是一些需要手动释放的资源，确保在不再需要这些资源时进行释放，以防资源泄漏。</li><li><strong>考虑使用InheritableThreadLocal：</strong> 如果线程池中的任务可能会创建子任务，并且需要共享父任务的<code>ThreadLocal</code>数据，可以考虑使用<code>InheritableThreadLocal</code>。它会使子线程继承父线程的<code>ThreadLocal</code>值。</li></ol><h2 id="阿里开源TTL">阿里开源TTL</h2><ol><li>TTL（Transmittable Thread-Local）是阿里巴巴开源的一个Java工具库，用于解决跨线程传递<code>ThreadLocal</code>值的问题。在Java多线程编程中，<code>ThreadLocal</code>通常用于保存线程私有的变量，但当线程池或异步任务池中的线程复用时，<code>ThreadLocal</code>的值无法自动传递，可能导致问题。</li><li>TTL提供了一种解决方案，通过TTL可以在父线程中设置<code>ThreadLocal</code>的值，然后在子线程中获取到这个值。这样，即使线程被线程池复用，<code>ThreadLocal</code>的值也能够正确地传递。</li><li>以下是TTL的一些特点和使用方法：<ul><li><strong>支持父子线程传递：</strong> TTL通过修改<code>ThreadLocal</code>的底层实现，支持在父线程中设置<code>ThreadLocal</code>的值，然后在子线程中获取到这个值。</li><li><strong>透明：</strong> 使用TTL时，对原有的<code>ThreadLocal</code>代码基本没有入侵，通过TTL提供的API可以在需要的地方进行修饰。</li><li><strong>无内存泄漏风险：</strong> TTL会在子线程中自动清理不再需要的<code>ThreadLocal</code>值，避免了传统<code>ThreadLocal</code>可能存在的内存泄漏问题。</li><li><strong>与线程池集成：</strong> TTL对一些常见的线程池（如ThreadPoolExecutor）进行了集成，可以方便地与线程池搭配使用。</li><li><strong>兼容性：</strong> TTL兼容Java原生的<code>ThreadLocal</code> API，使用起来相对简便。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">java基础知识</summary>
    
    
    
    <category term="java" scheme="https://xlxq.fun/categories/java/"/>
    
    
    <category term="java" scheme="https://xlxq.fun/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>多线程</title>
    <link href="https://xlxq.fun/posts/5729df21.html"/>
    <id>https://xlxq.fun/posts/5729df21.html</id>
    <published>2023-09-15T12:18:02.000Z</published>
    <updated>2023-09-15T12:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1>线程</h1><p>线程是操作系统中能够进行运算调度的最小单位。它被包含在进程中，是进程中的实际运作单位<br>进程是程序的基本执行实体<br>多线程可以让程序同时做多件事情，其本质是提高效率<br>应用场景：想要让多个事情同时运行时（宏观上），可以采用多线程</p><h1>并发和并行</h1><p>并发：在同一时刻，有多个指令在单个CPU上交替执行<br>并行：在同一时刻，有多个指令在多个CPU上同时执行</p><h1>多线程的实现方式</h1><h2 id="继承Thread类的方式进行实现">继承Thread类的方式进行实现</h2><p>1.自己定义一个类继承Thread<br>2.重写run方法（线程要执行的任务）<br>3.创建子类对象，并启动线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><h2 id="实现Runnable接口的方式进行实现">实现Runnable接口的方式进行实现</h2><p>1.自己定义一个类实现Runable接口<br>2.重写run方法<br>3.创建子类对象<br>4.创建一个Thread类的对象，并启动线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类中的代码</span></span><br><span class="line"><span class="comment">//创建NyRun的对象</span></span><br><span class="line"><span class="comment">//表示多线程要执行的任务</span></span><br><span class="line"><span class="type">MyRun</span> <span class="variable">mr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRun</span>();</span><br><span class="line"><span class="comment">//创建线程对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr);</span><br><span class="line"><span class="comment">//开启线程</span></span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><p>注意：此时定义的类并不继承自Thread类，因此不能直接使用Thread中的方法如setName，此时可以在run方法中用Thread.currentThread()来获取当前线程的对象，从而使用Thread中的方法</p><h2 id="利用Callable接口和Future接口方式实现">利用Callable接口和Future接口方式实现</h2><p><strong>特点:可以获取到多线程运行的结果</strong><br>1.创建一个类MyCallable实现Callable接口<br>2.重写call(是有返回值的。表示多线程运行的结果)<br>3.创建MyCallable的对象（表示多线程要执行的任务）<br>4.创建FutureTask的对象(作用:管理多线程运行的结果)<br>5.创建Thread类的对象，并启动(表示线程)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Nycallable的对象（表示多线程要执行的任务)</span></span><br><span class="line"><span class="type">MyCallable</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line"><span class="comment">//创建FutureTask的对象(作用管理多线程运行的结果)</span></span><br><span class="line">FutureTask&lt;Integer&gt; ft= <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(mc);</span><br><span class="line"><span class="comment">//创建线程的对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t1.start();</span><br><span class="line"><span class="comment">//获取多线程运行的结果</span></span><br><span class="line">Integer result= ft.get();</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure><h2 id="多线程三种实现方式对比">多线程三种实现方式对比</h2><img src="/post-img/Pasted image 20230718122056.png" alt="图片损坏" style="zoom:100%;" /><h1>多线程中的常见成员方法</h1><img src="/post-img/Pasted image 20230718122159.png" alt="图片损坏" style="zoom:100%;" /><p><strong>1.getName（）</strong><br>如果没有给线程设置名字，线程有默认的名字，<br>格式为：Thread-X（X是从零开始的序号）<br><strong>2.setName（String name）</strong><br>如果要给线程设置名字，可以用setName方法，也可以用构造方法。<br>但是使用构造方法时要注意，子类继承父类时，不会继承构造方法，<br>因此要重写构造方法，并且在方法体中使用super调用父类构造方法<br><strong>3.currentThread（）</strong><br>当JVM虚拟机启动之后，会自动的启动多条线程<br>其中有一条线程就叫main线程，它的作用是调用main方法，并执行里面的代码<br>在以前我们写的所有的代码，其实都是运行在main线程当中<br><strong>4.sleep（long time）</strong><br>哪条线程执行到这个方法，那么哪条线程就在这里停留对应的时间<br>方法的参数:就表示睡眠的时间,单位毫秒<br>当时间到了之后,线程会自动的醒来，继续执行下面的其他代码<br><strong>5.setPriority（int newPriority）和getPriority（）</strong><br>最小是1，最大是10，默认为5<br>优先级越高，抢到CPU的概率越高，但不是一定<br><strong>6.setDaemon（boolean on）</strong><br>当其他的非守护线程执行完毕以后，守护线程会陆续结束（即使没有执行完毕），但不是立即结束，可能有较短的时间在继续执行<br><strong>7.yield（）</strong><br>静态方法，用类名调用，相对于单一进程，一般在run（）中使用<br>某线程执行完一轮后，将CPU执行权交出，所有线程重新抢夺，该线程有可能再次得到CPU执行权，该方法可以尽可能使进程间均匀执行<br><strong>8.join（）</strong><br>相对于进程之间，由某个进程调用，可以使该进程插入到当前线程之前<br>（如在main线程中调用，则先执行该线程，结束后执行main线程中的其他代码）</p><h1>线程的生命周期</h1><img src="/post-img/Pasted image 20230718124141.png" alt="图片损坏" style="zoom:100%;" /><h1>线程的安全问题</h1><h2 id="同步代码块">同步代码块</h2><p>把操作共享数据的代码锁起来<br>特点：锁默认打开，有一个线程进去了，锁自动关闭，里面的代码全部执行完毕，锁自动打开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步代码块</span></span><br><span class="line"><span class="comment">//obj是锁对象，可以是任意的对象，但一定要是唯一的，一般可以用该类的字节码文件(.class)</span></span><br><span class="line"><span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line"><span class="comment">//被锁起来的代码</span></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同步方法">同步方法</h2><p>修饰符 sunchronized 返回值类型 方法名（方法参数）{…}<br>特点：同步方法是锁住方法里面所有的代码，并且锁对象不能自己指定<br>如果是非静态方法，为this，静态方法是当前类的字节码文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//1.循环</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="comment">//2.同步代码块(同步方法)</span></span><br><span class="line"><span class="keyword">if</span> (method()) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//3.判断共享数据是否到了末尾,如果到了末尾,跳出循环</span></span><br><span class="line"><span class="keyword">if</span> (ticket == <span class="number">100</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//4.判断共享数据是否到了末尾,如果没有到末尾,执行代码逻辑</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace(）;</span><br><span class="line">&#125;</span><br><span class="line">ticket++;</span><br><span class="line">System.out.println(Thread.currentThread().getName() +<span class="string">&quot;在卖第” + ticket +&quot;</span>张票!!!<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">    return false;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Lock锁">Lock锁</h2><p>虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock<br>Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作<br>Lock中提供了获得锁和释放锁的方法，可以手动上锁、手动释放锁<br>void lock():获得锁<br>void unlock():释放锁<br>Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化ReentrantLock的构造方法<br>ReentrantLock():创建一个ReentrantLock的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="comment">//synchronized(MYThread.class)&#123;//同步代码块表述</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ticket == <span class="number">100</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//4.判断共享数据是否到了末尾,如果没有到末尾,执行核心逻辑</span></span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line">ticket++;</span><br><span class="line">System.out.println(Thread.currentThread().getName() +<span class="string">&quot;在卖第” + ticket +&quot;</span>张票!!!<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;catch(InterruptedException e)&#123;</span></span><br><span class="line"><span class="string">e.printStackTrace();</span></span><br><span class="line"><span class="string">&#125;finally&#123;</span></span><br><span class="line"><span class="string">//释放锁一定要运行，放在finally中</span></span><br><span class="line"><span class="string">lock.unlock();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="死锁">死锁</h2><p>在程序中出现了锁的嵌套时，会出现死锁，导致线程都进入循环等待的状态</p><h2 id="等待唤醒机制">等待唤醒机制</h2><h3 id="生产者、消费者问题">生产者、消费者问题</h3><p>常见方法：<br><img src="/post-img/Pasted image 20230718140001.png" alt="图片损坏" style="zoom:100%;" /><br>这几个方法都是通过锁对象调用（锁在资源类中创建，资源类用来控制生产者和消费者的执行）</p><h3 id="阻塞队列">阻塞队列</h3><p>放数据时，放不进去，会等着，即阻塞<br>取数据时，取不到，会等着，也会阻塞<br>阻塞队列实现的四个接口：Iterable、Collection、Quene、BlockingQuene<br>创建阻塞队列的实现类对象：ArrayBlockingQuene、LinkedBlockingQuene<br>其中前者的底层时数组，有界；后者的底层是链表，无界，但是最大为int的最大值<br>生产者和消费者必须使用同一个阻塞队列，所以阻塞队列对象应该在测试类中创建，但是生产者和消费者的类中应该给出阻塞队列的定义（但不赋值）<br>注意take方法的底层也是有锁的，因此不能再自己加锁，否则可能死锁</p><h1>线程的状态</h1><img src="/post-img/Pasted image 20230718141327.png" alt="图片损坏" style="zoom:100%;" />线程共有七种状态，但java中只定义了除运行外的其他六种状态，这是因为运行时java将线程交给操作系统了，不再管理<h1>线程池</h1><h2 id="原理">原理</h2><p>1.创建一个池子，池子中是空的<br>2.提交任务时，池子会（自动）创建新的线程对象，任务执行完毕，线程归还给池子，下回再次提交任务时，不需要创建新的线程，直接复用已有的线程即可<br>3.如果提交任务时，池子中没有空闲线程，也无法创建新的线程，任务就会排队等待<br>创建线程池-&gt;提交任务-&gt;所有任务全部执行完毕，关闭线程池</p><h2 id="代码实现">代码实现</h2><img src="/post-img/Pasted image 20230718142302.png" alt="图片损坏" style="zoom:100%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取线程池对象</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool1</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">//2.提交任务</span></span><br><span class="line"><span class="comment">//在MyRunable类中的run方法写任务</span></span><br><span class="line">pool1.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line"><span class="comment">//3.销毁线程池</span></span><br><span class="line">pool1.shutdown();</span><br></pre></td></tr></table></figure><h3 id="自定义线程池">自定义线程池</h3><p>当一些任务想要被线程运行时，线程池的分配顺序如下：<br>核心线程开始运行，剩下的任务进入排队队列，若还有剩下的任务，则进入临时线程（最大线程数量减核心线程数量），若还有剩下的任务，则被拒绝<br>代码实现：<br>ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor<br>(核心线程数量,最大线程数量,空闲线程最大存活时间,任务队列,创建线程工厂,任务的拒绝策略);<br>参数一:核心线程数量     不能小于0<br>参数二:最大线程数        不能小于等于0.最大数量&gt;=核心线程数量<br>参数三:空闲线程最大存话时间    不能小于0<br>参数四:时间单位        用TimeUnit指定<br>参数五:任务队列        不能为null<br>参数六:创建线程工厂       不能为null<br>参数七:任务的拒绝策略       不能为null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line"> <span class="number">3</span>,     <span class="comment">//核心线程数量。不能小于0</span></span><br><span class="line"> <span class="number">6</span>，    <span class="comment">//最大线程数，不能小于0.最大数量&gt;=核心线程数量</span></span><br><span class="line"> <span class="number">60</span>,    <span class="comment">//空闲线程最大存活时间</span></span><br><span class="line">TimeUnit.SECONDS ,  <span class="comment">//时间单位</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>),  <span class="comment">//任务队列</span></span><br><span class="line">Executors.defaultThreadFactory(),<span class="comment">//创建线程工厂</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicyo(),<span class="comment">//任务的拒绝策略</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//任务的拒绝策略是ThreadPoolExecutor的静态内部类，这是因为拒绝策略为线程池服务，并且是一个独立的个体</span></span><br></pre></td></tr></table></figure><p>四种拒绝策略：<br><img src="/post-img/Pasted image 20230718143400.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="最大并行数">最大并行数</h2><p>四核八线程（超线程技术）的最大并行数就是8<br>Runtime.getRuntime.().availableProcessors()可以获取可用处理器数目即最大并行数<br>线程池的大小：<br>CPU密集型运算：最大并行数+1（+1即替补）<br>I/O密集型运算：最大并行数* 期望CPU利用率* （总时间即CPU计算时间+等待时间）/CPU计算时间（利用工具thread dump获取数据）</p>]]></content>
    
    
    <summary type="html">java基础知识</summary>
    
    
    
    <category term="java" scheme="https://xlxq.fun/categories/java/"/>
    
    
    <category term="java" scheme="https://xlxq.fun/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>异常</title>
    <link href="https://xlxq.fun/posts/23a3bd72.html"/>
    <id>https://xlxq.fun/posts/23a3bd72.html</id>
    <published>2023-09-13T11:18:02.000Z</published>
    <updated>2023-09-13T11:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1>异常的分类：</h1><img src="/post-img/Pasted image 20230713171105.png" alt="图片损坏" style="zoom:100%;" />编译时异常:除了RuntimeExcpetion和他的子类，其他都是编译时异常。编译阶段需要进行处理，作用在于提醒程序员。运行时异常:RuntimeException本身和所有子类，都是运行时异常。<h1>异常的作用：</h1><p>作用一:异常是用来查询bug的关键参考信息<br>作用二∶异常可以作为方法内部的一种特殊返回值，以便通知调用者底层的执行情况</p><h1>异常的处理方式</h1><h2 id="JVM默认处理异常的方式">JVM默认处理异常的方式</h2><p>1．把异常的名称,异常原因及异常出现的位置等信息输出在控制台<br>2．程序停止执行,异常下面的代码不会再执行了</p><h2 id="try-catch处理异常">try-catch处理异常</h2><p>try-catch：提前预判程序中哪个地方可能会出现某种错误，出现后执行catch中的代码，并且程序可以继续运行<br>如果try中没有遇到问题，会将try中的所有代码全部执行完毕，并且跳过catch中代码<br>如果try中可能遇到多个问题，可以写多个catch与之对应，并且父类异常应该写在下面<br>如果try中遇到的问题没有被捕获，相当于try-catch白写了，异常交给虚拟机处理<br>如果try中遇到了问题，try下面其他的代码不会继续执行，直接跳转到对应的catch，此时try中后面的代码不会运行，但try-catch后面的其它代码会继续运行；<br>如果没有对应的catch，则交给虚拟机处理，此时后面的其它代码也不会运行<br><img src="/post-img/Pasted image 20230713171318.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="throws和throw">throws和throw</h2><p>throws：写在方法定义处，表示声明一个异常，告诉调用者，使用本方法可能会有哪些异常，其中编译时异常必须要写，运行时异常可以不写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 方法() <span class="keyword">throws</span> 异常类名<span class="number">1</span>，异常类名<span class="number">2.</span>..&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>throw：写在方法内，结束方法，手动抛出异常对象，交给调用者，并且方法中下面的代码不再运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 方法()&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三种异常处理方式的对比">三种异常处理方式的对比</h2><p>1．虚拟机默认处理异常的方式<br>把异常信息以红色字体打印在控制台，并结束程序<br>2．捕获:try…catch<br>一般用在调用处，能让代码继续往下运行。<br>3．抛出: throw throws<br>在方法中，出现异常了。<br>方法就没有继续运行下去的意义了，采取抛出处理。<br>让该方法结束运行并告诉调用者出现了问题。</p><h1>自定义异常</h1><p>定义异常类，名字格式：当前异常的名字+Exception<br>写继承关系，由于参数错误导致的问题继承RuntimeException，提醒程序员检查本地信息继承Exception<br>空参构造，ctrl+alt+insert<br>带参构造，ctrl+alt+insert<br>让控制台的报错信息更加见名知意，自定义异常类就是为了这个名字</p><h1>异常的常见方法：</h1><p>public string getMessage()   返回此throwable 的详细消息字符串<br>public String toString()   返回此可抛出的简短描述<br>这两个方法要用变量存储返回值后再打印在控制台<br>public void printstackTrace()  把异常的错误信息输出在控制台<br>只是打印消息，不会终止程序运行<br><a href="//System.err.println">//System.err.println</a>(“something”)<br>以红色字体将消息打印在控制台</p>]]></content>
    
    
    <summary type="html">java基础知识</summary>
    
    
    
    <category term="java" scheme="https://xlxq.fun/categories/java/"/>
    
    
    <category term="java" scheme="https://xlxq.fun/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>文件</title>
    <link href="https://xlxq.fun/posts/d4cf1cb8.html"/>
    <id>https://xlxq.fun/posts/d4cf1cb8.html</id>
    <published>2023-09-13T11:18:02.000Z</published>
    <updated>2023-09-13T11:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1>File文件对象</h1><p>表示路径，可以是文件或文件夹，可以是存在的，也可以是不存在的<br>绝对路径是带盘符的，相对路径是不带盘符的，默认到当前项目下去找</p><h1>File的三种构造方法</h1><p>public File(String pathname)：把字符串表示的路径变成File对象<br>public File(String parent,string child)：把父级路径和子级路径进行拼接<br>public File(File parent，String child)：把父级路径和子级路径进行拼接</p><h1>File成员方法</h1><img src="/post-img/Pasted image 20230715164122.png" alt="图片损坏" style="zoom:100%;" /><img src="/post-img/Pasted image 20230715164135.png" alt="图片损坏" style="zoom:100%;" /><img src="/post-img/Pasted image 20230715164202.png" alt="图片损坏" style="zoom:100%;" /><h2 id="部分方法的细节">部分方法的细节</h2><p><strong>length（）：</strong><br>返回值是long，单位是字节，如果想要改变单位，/1024<br>无法获取文件夹的大小，如果要获取文件夹的大小，累加文件夹中所有文件<br><strong>createNewFile（）：</strong><br>当前文件夹不存在，创建成功，返回true；存在，创建失败，返回false；<br>如果父级路径不存在，方法会有异常IOException；<br>创建的一定是文件，如果路径中不包含后缀名，创建一个没有后缀的文件<br><strong>mkdir（）：</strong><br>windows中路径是唯一的，如果当前路径已经存在，创建失败，返回false；<br>此方法只能创建单级文件，无法创建多级文件夹；而mkdirs（）方法既可创建单级的，又可以创建多级的文件夹；<br><strong>delete（）：</strong><br>如果删除的是文件，直接删除，不走回收站；<br>如果删除的是空文件夹，直接删除，不走回收站；<br>如果删除的是有内容的文件夹，则删除失败；<br><strong>listFiles（）：</strong><br>当调用者File表示的路径不存在时，返回null；<br>当调用者File表示的路径是文件时，返回null；<br>当调用者File表示的路径是一个空文件夹时，返回一个长度为0的数组；<br>当调用者File表示的路径是一个有内容的文件夹时，将里面所有文件和文件夹的路径放在File数组中返回；<br>当调用者File表示的路径是一个有隐藏文件的文件夹时，将里面所有文件和文件夹的路径放在File数组中返回，包含隐藏文件；<br>当调用者File表示的路径是需要权限才能访问的文件夹时，返回null；</p><h1>遍历文件夹</h1><p>要遍历某个盘符或某个文件夹中的所有文件，通常需要使用递归：<br>1.进入想要遍历的文件夹，利用listFiles（）方法获取file数组<br>2.遍历数组，依次得到每一个文件夹或文件<br>3.判断如果是文件执行业务逻辑<br>4.判断如果是文件夹，递归，此时参数是文件夹的次一级路径<br>5.注意是否可能存在空指针异常（一般是由于存在无访问权限的文件，此时listFile（）返回的是Null）</p>]]></content>
    
    
    <summary type="html">java基础知识</summary>
    
    
    
    <category term="java" scheme="https://xlxq.fun/categories/java/"/>
    
    
    <category term="java" scheme="https://xlxq.fun/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Stream流和方法引用</title>
    <link href="https://xlxq.fun/posts/6ae8bba9.html"/>
    <id>https://xlxq.fun/posts/6ae8bba9.html</id>
    <published>2023-09-11T11:18:02.000Z</published>
    <updated>2023-09-11T11:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Stream流</h1><p>作用：结合lambda表达式，简化集合和数组的操作<br>可以理解为是一种流水线作业，将集合或数组中的元素放到流水线（stream流）上，进行响应的处理后（使用链式编程可以更方便的处理），进行输出或其他操作<br>使用步骤：获取Stream流对象，使用中间方法处理数据，使用终结方法处理数据<br>获取Stream流对象的方法：<br>单列集合：collection中的默认方法stream<br>双列集合：不能直接获取（可以转化为单列集合后获取）<br>数组：Arrays工具类中的静态方法stream<br>零散数据（相同数据类型）：Stream接口中的静态方法of<br>常见的方法：<br>中间方法：filter，limit，skip，distinct，concat，map<br>终结方法：forEach，count，collect，toArray</p><h2 id="获取Stream流对象：">获取Stream流对象：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单列集合</span></span><br><span class="line">ArrayList&lt;String&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">Collections.addAll(list,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>);  </span><br><span class="line"><span class="comment">//创建流水线对象，后续可以进行其他操作</span></span><br><span class="line">Stream&lt;String&gt; stream1 = list.stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//双列集合</span></span><br><span class="line">HashMap&lt;String,Integer&gt; hashMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">hashMap.put(<span class="string">&quot;aaa&quot;</span>,<span class="number">111</span>);  </span><br><span class="line">hashMap.put(<span class="string">&quot;bbb&quot;</span>,<span class="number">222</span>);  </span><br><span class="line">hashMap.put(<span class="string">&quot;ccc&quot;</span>,<span class="number">333</span>);  </span><br><span class="line">hashMap.put(<span class="string">&quot;ddd&quot;</span>,<span class="number">444</span>);  </span><br><span class="line">hashMap.put(<span class="string">&quot;eee&quot;</span>,<span class="number">555</span>);</span><br><span class="line"><span class="comment">//1.通过获取键构造单列集合</span></span><br><span class="line">Stream&lt;String&gt; stream2 = hashMap.keySet().stream();</span><br><span class="line"><span class="comment">//2.通过获取键值对构造单列集合</span></span><br><span class="line">Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; stream = hashMap.entrySet().stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基本数据类型</span></span><br><span class="line"><span class="type">int</span>[] arr1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="comment">//引用数据类型</span></span><br><span class="line">String[] arr2=&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;  </span><br><span class="line"><span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> Arrays.stream(arr1);  </span><br><span class="line">Stream&lt;String&gt; stream1 = Arrays.stream(arr2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//零散数据</span></span><br><span class="line">Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">Stream.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Stream接口中静态方法of的细节</span></span><br><span class="line"><span class="comment">//方法的形参是一个可变参数，可以传递一堆零散的数据。也可以传递数组</span></span><br><span class="line"><span class="comment">//但是数组必须是引用数据类型的，如果传递基本数据类型，是会把整个数组当做一个元素，放到Stream当中。</span></span><br></pre></td></tr></table></figure><h2 id="中间方法">中间方法</h2><img src="/post-img/Pasted image 20230713163230.png" alt="图片损坏" style="zoom:100%;" />1.中间方法返回的是新的stream流，原来的stream流只能使用一次，因此建议使用链式编程2.修改stream流中的数据，不会影响原来集合或数组中的数据<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//filter过滤函数</span></span><br><span class="line">list.stream().filter(s-&gt;过滤条件(满足条件留下));</span><br><span class="line"></span><br><span class="line"><span class="comment">//limit截取前几个元素，可以配合filter或skip使用，在某条件下再截取前几个元素</span></span><br><span class="line">list.stream().limit(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//skip跳过前几个元素，可以配合filter或skip使用，在某条件下再跳过前几个元素</span></span><br><span class="line">list.stream().skip(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//distinct去重(依赖hashcode和equals方法，若传递自定义数据类型，需重写这两个方法)</span></span><br><span class="line">list.stream().distinct();</span><br><span class="line"></span><br><span class="line"><span class="comment">//concat合并两个流(尽可能使两个流的数据类型保持一致)</span></span><br><span class="line">Stream.concat(list1.stream(),list2.stream);</span><br><span class="line"></span><br><span class="line"><span class="comment">//map改变数据类型（但更像是提供一个对流中数据进行操作的平台）</span></span><br><span class="line">list.stream().map(s-&gt; Integer.parseInt(s.split( regex: <span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="终结方法">终结方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//forEach遍历</span></span><br><span class="line">list.stream().forEach(s-&gt;操作)；</span><br><span class="line"></span><br><span class="line"><span class="comment">//count记录集合元素个数</span></span><br><span class="line">list.stream().count();</span><br><span class="line"></span><br><span class="line"><span class="comment">//toArray将流中的数据收集起来存到一个数组中</span></span><br><span class="line"><span class="comment">//参数的作用：创建一个指定类型的数组</span></span><br><span class="line"><span class="comment">//返回值：装着流中所有数据的数组</span></span><br><span class="line">list.stream().toArray(value(元素个数)-&gt;<span class="keyword">new</span> <span class="title class_">String</span>[value]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//collect收集流中的数据，放到集合中（List Set Map）</span></span><br><span class="line">List&lt;String&gt; newList = list.stream( )</span><br><span class="line">.filter(s -&gt;“男”<span class="string">&quot;.equals(s.split( regex:&quot;</span>-<span class="string">&quot;&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">.collect(collectors.toList()/toSet());</span><br><span class="line">List&lt;String&gt; newList = list.stream( )</span><br><span class="line">.filter(s -&gt;“男”<span class="string">&quot;.equals(s.split( regex:&quot;</span>-<span class="string">&quot;&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">.collect(collectors.toMap(键的生成规则，值的生成规则));</span><br><span class="line">  </span><br><span class="line"><span class="comment">//    参数一:  </span></span><br><span class="line"><span class="comment">//    Function泛型一:表示流中每一个数据的类型  </span></span><br><span class="line"><span class="comment">//    泛型二:表示Nap集合中键的数据类型  </span></span><br><span class="line"><span class="comment">//    方法apply形参:依次表示流里面的每一个数据  </span></span><br><span class="line"><span class="comment">//    方法体:生成键的代码  </span></span><br><span class="line"><span class="comment">//    返回值:己经生成的键  </span></span><br><span class="line"><span class="comment">//    参数二:  </span></span><br><span class="line"><span class="comment">//    Function泛型一:表示流中每一个数据的类型  </span></span><br><span class="line"><span class="comment">//    泛型二:表示Hap集合中值的数据类型  </span></span><br><span class="line"><span class="comment">//    方法apply形参:依次表示流里面的每一个数据  </span></span><br><span class="line"><span class="comment">//    方法体:生成值的代码  </span></span><br><span class="line"><span class="comment">//    返回值:已经生成的值</span></span><br><span class="line">Map&lt;String,Integer&gt; map2 = list.stream()  </span><br><span class="line">        .filter(s -&gt;<span class="string">&quot;男&quot;</span>.equals(s.split( <span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))  </span><br><span class="line">        .collect(Collectors.toMap(  </span><br><span class="line">        s-&gt; s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>],  </span><br><span class="line">        s-&gt;Integer.parseInt(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">2</span>])));</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">java基础知识</summary>
    
    
    
    <category term="java" scheme="https://xlxq.fun/categories/java/"/>
    
    
    <category term="java" scheme="https://xlxq.fun/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收</title>
    <link href="https://xlxq.fun/posts/72f47432.html"/>
    <id>https://xlxq.fun/posts/72f47432.html</id>
    <published>2023-09-11T11:18:02.000Z</published>
    <updated>2023-09-11T11:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1>分类</h1><ol><li><strong>Minor GC（年轻代垃圾回收）:</strong><ul><li>针对年轻代（Young Generation）进行垃圾回收</li><li>当年轻代满时触发（通常由Eden区满、S0或S1区满触发）</li><li>垃圾对象相对较少，停顿时间较短。存活对象会被移到年老代。</li></ul></li><li><strong>Major GC（主要垃圾回收）:</strong><ul><li>Major GC 这个术语在Java中并不是一个官方的术语，有时也被用来指代Full GC。</li><li>有时人们使用 “Major GC” 来表示一次垃圾回收中涉及老年代的部分，即Full GC中清理老年代的过程。</li></ul></li><li><strong>Full GC（完全垃圾回收或老年代垃圾回收）:</strong><ul><li>针对整个堆（包括年轻代和老年代）进行垃圾回收。</li><li>当年轻代和老年代都满时触发，也可能由永久代（jdk7）满触发。</li><li>清理的范围更广，涉及整个堆。通常停顿时间相对较长。</li></ul></li></ol><h1>垃圾回收算法</h1><h2 id="标记-清除算法（Mark-and-Sweep）">标记-清除算法（Mark and Sweep）</h2><ul><li><strong>标记阶段：</strong> 从根节点开始，通过可达性分析标记所有能够被访问到的对象。</li><li><strong>清除阶段：</strong> 通过遍历整个堆，清除未被标记的对象，即垃圾对象。</li><li><strong>优点：</strong> 简单，容易实现。不需要移动对象。</li><li><strong>缺点：</strong> 产生内存碎片。 暂停时间较长。</li></ul><h2 id="复制算法（Copying）"><strong>复制算法（Copying）</strong></h2><ul><li>将堆分为两个区域，每次只使用其中一个。将存活的对象从一个区域复制到另一个区域。清理当前区域的所有对象。</li><li><strong>优点：</strong> 无内存碎片。适用于小对象，存活对象较少的场景（新生代）。</li><li><strong>缺点：</strong> 需要额外的空间。需要复制对象，移动开销较大。</li></ul><h2 id="标记-整理算法（Mark-and-Compact）"><strong>标记-整理算法（Mark and Compact）</strong></h2><ul><li>标记可达对象，将存活对象向一端移动，然后清理未标记的区域。</li><li><strong>优点：</strong> 无内存碎片。相较于复制算法，减少了对象复制的开销。</li><li><strong>缺点：</strong> 移动对象可能导致引用更新的复杂性。暂停时间相对较长。</li></ul><h2 id="分代回收算法（Generational）"><strong>分代回收算法（Generational）:</strong></h2><ul><li>将堆分为年轻代和老年代。大部分对象在年轻代被快速回收，少部分晋升到老年代。</li><li><strong>优点：</strong> 利用了对象的生命周期不同的特性，针对不同年代使用不同的垃圾回收策略。</li><li><strong>缺点：</strong> 需要额外的管理。不能解决所有的垃圾回收问题。</li></ul><h1>垃圾回收器</h1><ol><li><strong>Serial</strong> Garbage Collector:（串行垃圾回收器）<ul><li>单线程执行，适用于小型应用或测试环境。</li></ul></li><li><strong>Parallel</strong> Garbage Collector:<ul><li>多线程执行，充分利用多核处理器。</li><li>在新生代使用并行垃圾回收器，老年代使用串行垃圾回收器。</li></ul></li><li><strong>Concurrent Mark-Sweep (CMS)</strong> Garbage Collector:<ul><li>主要用于老年代的垃圾回收。</li><li>在标记和清理阶段允许与应用程序线程并发执行，目标是<strong>最小停顿时间</strong>。</li></ul></li><li><strong>Garbage First（G1）</strong> Garbage Collector:<ul><li>适用于大堆内存，具有低停顿时间的需求。</li><li>将堆划分为多个区域（region），通过并行和并发阶段实现垃圾回收。</li></ul></li></ol><h1>CMS</h1><p>四阶段：<strong>初始标记，并发标记，重新标记，并发清除</strong><br>其中第一、三阶段需要STW（stop the world，暂停用户线程）</p><ol><li>初始标记：标记所有直接被GCroot关联的对象，速度比较快</li><li>并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，耗时较长，但是是并发执行，不需要暂停用户线程</li><li>重新标记：修正并发标记期间,因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要STW，但时间不会太长</li><li>并发清除：清理删除掉标记阶段判定的已经死亡的对象,释放内存空间，不需要移动存活对象,可以与用户线程同时并发（产生内存碎片）<br>由于最耗费时间的并发标记与并发清除阶段都是不需要暂停用户线程的,所以整体的回收是低停顿的</li></ol><h1>G1</h1><p>回收步骤与CMS相似，<strong>初始标记，并发标记，最终标记，筛选回收</strong><br>重要概念和特点：</p><ol><li>区域（region）：把堆内存分割为很多不相关的区域(Region)(物理上不连续)，所有region均可以用来当作eden，survivor，old，humongous（存储大对象）（<strong>区域化内存布局</strong>）</li><li>Region之间是复制算法（从若干个rigion回收融合到一个region）,但整体上实际可看作是标记-整理算法</li><li>G1除了追求低停顿外,还能建立可预测的停顿时间模型,能让使用者明确指定在一个长度为M毫秒的时间片段内,消耗在垃圾收集上的时间不得超过N毫秒（<strong>可预测停顿时间</strong>），因为会优先回收价值高的region（<strong>垃圾优先</strong>）</li><li>可以只选取部分区域进行内存回收,这样缩小了范围,因此对于全局停顿情况的发生也能得到较好的控制，可以进行<strong>混合回收</strong>，同时处理新生代和老年代</li><li><strong>并行和并发</strong>执行垃圾回收操作，并行加快标记和复制的速度，并发减少垃圾回收对应用程序的停顿时间</li></ol><h1>补充</h1><h2 id="关于GC-root">关于GC root</h2><p>GCroot（垃圾收集根）是指一组对象，这些对象被认为是在垃圾收集时安全的，不会被垃圾收集器回收。垃圾收集根是整个对象图的起始点，垃圾收集器通过这些根对象能够追踪到其他对象的引用链，从而确定哪些对象是可达的，哪些是不可达的，进而进行垃圾回收。<br>以下是一些常见的 GCroot 类型：</p><ol><li><strong>栈中的局部变量和输入参数：</strong><ul><li>方法中的局部变量和输入参数，以及调用方法时传递的参数，都是GCroot。这是因为它们是程序执行的起点。</li></ul></li><li><strong>静态变量（类变量）：</strong><ul><li>存储在静态变量中的对象也是GCroot，因为它们随着类的加载而存在，不依赖于特定的实例。</li></ul></li><li>JNI 引用：<ul><li>通过 Java Native Interface (JNI) 创建的引用，允许 Java 代码访问和调用本地库的接口。JNI 引用也是 GCroot。</li></ul></li><li>活动的线程：<ul><li>正在运行的线程本身也是 GCroot，因为它们持有一些对象的引用，而这些引用不能被垃圾收集。</li></ul></li><li>Finalizer 引用：<ul><li>当一个对象的finalize()方法被调用时，这个对象是 GCroot，因为在finalize()方法中可能会重新建立对象的引用关系。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">JVM</summary>
    
    
    
    <category term="JVM" scheme="https://xlxq.fun/categories/JVM/"/>
    
    
    <category term="JVM，java" scheme="https://xlxq.fun/tags/JVM%EF%BC%8Cjava/"/>
    
  </entry>
  
  <entry>
    <title>mysql基础</title>
    <link href="https://xlxq.fun/posts/8e40d0ad.html"/>
    <id>https://xlxq.fun/posts/8e40d0ad.html</id>
    <published>2023-09-09T10:19:03.000Z</published>
    <updated>2023-09-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>单表设计</h1><h2 id="DDL">DDL</h2><p><strong>DDL英文全称是Data Definition Language，数据定义语言，用来定义数据库对象(数据库、表)。</strong></p><h3 id="数据类型">数据类型</h3><h4 id="数值类型">数值类型</h4><img src="/post-img/Pasted image 20230726153339.png" alt="图片损坏" style="zoom:100%;" /><h4 id="字符串类型">字符串类型</h4><img src="/post-img/Pasted image 20230726153459.png" alt="图片损坏" style="zoom:100%;" />char(10)：最多只能存10个字符，不足10个字符占用10个字符空间 性能高，浪费空间varchar(10)：最多只能存10个字符，不足10个字符，按照实际长度存储 性能低，节省空间确定字符串长度用varchar，不确定用char<h4 id="日期类型">日期类型</h4><img src="/post-img/Pasted image 20230726153803.png" alt="图片损坏" style="zoom:100%;" /><h4 id="根据页面原型-需求创建表">根据页面原型/需求创建表</h4><p>通过页面原型和需求获取原型字段（选择合适的类型和约束）<br>加上基础字段如id、create_time、update_time等<br>其中create_time记录当前这条数据插入的时间update_time记录当前这条数据最后更新的时间<br>最终获得合理的表结构</p><h3 id="数据库操作">数据库操作</h3><p>查询所有数据库: show databases;<br>查询当前数据库: select database();<br>使用数据库:use 数据库名;<br>创建数据库:create database [ if not exists ] 数据库名;<br>删除数据库:drop database [ if exists ] 数据库名;<br>注意：上述语法中的database，也可以替换成schema。如: create schema db01;</p><h3 id="表操作">表操作</h3><h4 id="创建">创建</h4><img src="/post-img/Pasted image 20230726152908.png" alt="图片损坏" style="zoom:100%;" />约束是作用于表中字段上的规则，用于限制存储在表中的数据，目的是保证数据库中数据的正确性、有效性和完整性，分为not null、unique、primary key（auto_increment自增）、default、foreign key<img src="/post-img/Pasted image 20230726153144.png" alt="图片损坏" style="zoom:100%;" /><h4 id="查询">查询</h4><p>查询当前数据库所有表: show tables;<br>查询表结构:desc表名;<br>查询建表语句: show create table表名;</p><h4 id="修改">修改</h4><p>添加字段: alter  table  表名  add  字段名类型(长度)  [comment注释]  [约束];<br>修改字段类型: alter  table  表名  modify  字段名  新数据类型(长度);<br>修改字段名和字段类型: alter  table  表名  change  旧字段名  新字段名  类型(长度)  [comment注释]  [约束];<br>删除字段: alter  table  表名  drop  column  字段名;<br>修改表名:rename  table  表名  to  新表名;<br><img src="/post-img/Pasted image 20230726154822.png" alt="图片损坏" style="zoom:100%;" /></p><h4 id="删除">删除</h4><p>删除表:drop table [ if exists ]表名;<br>删除表时，表中的全部数据也会被删除</p><h2 id="DML">DML</h2><p><strong>DML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进行增、删、改操作。</strong></p><h3 id="INSERT-增加">INSERT(增加)</h3><img src="/post-img/Pasted image 20230726155221.png" alt="图片损坏" style="zoom:100%;" /><img src="/post-img/Pasted image 20230726155347.png" alt="图片损坏" style="zoom:100%;" />调用now( )为create_time和update_time赋值注意：1.插入数据时，指定的字段顺序需要与值的顺序是一一对应的。2.字符串和日期型数据应该包含在引号中。3.插入的数据大小，应该在字段的规定范围内。<h3 id="UPDATE（修改）">UPDATE（修改）</h3><img src="/post-img/Pasted image 20230726155611.png" alt="图片损坏" style="zoom:100%;" /><img src="/post-img/Pasted image 20230726155637.png" alt="图片损坏" style="zoom:100%;" />修改表的条件可以有，也可以没有，没有条件会修改整张表的所有数据<h3 id="DELETE-删除">DELETE(删除)</h3><img src="/post-img/Pasted image 20230726155858.png" alt="图片损坏" style="zoom:100%;" /><img src="/post-img/Pasted image 20230726155944.png" alt="图片损坏" style="zoom:100%;" />1.DELETE语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。2.DELETE 语句不能删除某一个字段的值(如果要操作，可以使用UPDATE，将该字段的值置为NULL)。<h2 id="DQL">DQL</h2><p><strong>DQL英文全称是Data Query Language(数据查询语言)，用来查询数据库表中的记录。</strong><br><img src="/post-img/Pasted image 20230726160258.png" alt="图片损坏" style="zoom:100%;" /></p><h3 id="基本查询">基本查询</h3><img src="/post-img/Pasted image 20230726160313.png" alt="图片损坏" style="zoom:100%;" />其中查询所有字段使用通配符虽然比较简洁，但是性能比较低，不推荐，建议用将表中的所有字段列出的方式查询<h3 id="条件查询">条件查询</h3><img src="/post-img/Pasted image 20230726160601.png" alt="图片损坏" style="zoom:100%;" /><h3 id="聚合函数">聚合函数</h3><img src="/post-img/Pasted image 20230726160719.png" alt="图片损坏" style="zoom:100%;" /><img src="/post-img/Pasted image 20230726160726.png" alt="图片损坏" style="zoom:100%;" />count的三种使用方式：1.conut（字段）字段必须是非空的，因为聚合函数不对null值进行运算2.count（任意不为null的常量）3.count（\*）推荐使用，mysql底层有优化<h3 id="分组查询">分组查询</h3><img src="/post-img/Pasted image 20230726161051.png" alt="图片损坏" style="zoom:100%;" />where与having区别：1．执行时机不同: where是分组之前进行过滤，不满足where条件，不参与分组;而having是分组之后对结果进行过滤。2.判断条件不同:where不能对聚合函数进行判断，而having可以。注意：1.分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。2.执行顺序: where >聚合函数>having 。<h3 id="排序查询">排序查询</h3><img src="/post-img/Pasted image 20230726161302.png" alt="图片损坏" style="zoom:100%;" />排序方式：ASC升序（默认）、DESC降序如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序<h3 id="分页查询">分页查询</h3><img src="/post-img/Pasted image 20230726161439.png" alt="图片损坏" style="zoom:100%;" />注意：1.起始索引从0开始，起始索引=（查询页码–1）  * 每页显示记录数。2.分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。3.如果查询的是第一页数据，起始索引可以省略，直接简写为limit 10。<h3 id="DQL小结">DQL小结</h3><img src="/post-img/Pasted image 20230726161617.png" alt="图片损坏" style="zoom:100%;" /><h1>多表设计</h1><p>项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系</p><h2 id="一对多">一对多</h2><p>在数据库表中多的一方，添加字段，来关联一的一方的主键<br>为了避免数据的不完整、不一致问题，这个字段定义为多的一方的外键<br><img src="/post-img/Pasted image 20230726162008.png" alt="图片损坏" style="zoom:100%;" /><br><img src="/post-img/Pasted image 20230726162030.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="一对一">一对一</h2><p>关系:一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他字段放在另一张表中，以提升操作效率<br>实现:在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)</p><h2 id="多对多">多对多</h2><p>关系:一个学生可以选修多门课程，一门课程也可以供多个学生选择<br>实现:建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p><h1>多表查询</h1><p><strong>从多张表中查询数据</strong></p><h2 id="连接查询">连接查询</h2><h3 id="内连接">内连接</h3><img src="/post-img/Pasted image 20230726162420.png" alt="图片损坏" style="zoom:100%;" /><h3 id="外连接">外连接</h3><img src="/post-img/Pasted image 20230726162449.png" alt="图片损坏" style="zoom:100%;" />左外连接:查询左表所有数据(包括两张表交集部分数据)右外连接:查询右表所有数据(包括两张表交集部分数据)左外连接和右外连接可以互相转换，因此多用左外连接<img src="/post-img/Pasted image 20230726162608.png" alt="图片损坏" style="zoom:100%;" /><h2 id="子查询">子查询</h2><img src="/post-img/Pasted image 20230726162642.png" alt="图片损坏" style="zoom:100%;" />分析时建议一步步查询，最后再将变量替换即可<h3 id="标量子查询">标量子查询</h3><img src="/post-img/Pasted image 20230726162907.png" alt="图片损坏" style="zoom:100%;" /><h3 id="列子查询">列子查询</h3><img src="/post-img/Pasted image 20230726162916.png" alt="图片损坏" style="zoom:100%;" /><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">select</span> id <span class="keyword">from</span> tb_dept <span class="keyword">where</span> name <span class="operator">=</span><span class="string">&#x27;教研部&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;咨询部&#x27;</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_emp <span class="keyword">where</span> dept_id <span class="keyword">in</span>(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_emp <span class="keyword">where</span> dept_id <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> tb_dept <span class="keyword">where</span> name <span class="operator">=</span><span class="string">&#x27;教研部&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;咨询部&#x27;</span>); </span><br></pre></td></tr></table></figure><h3 id="行子查询">行子查询</h3><img src="/post-img/Pasted image 20230726163250.png" alt="图片损坏" style="zoom:100%;" /><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">select</span> entrydate,job <span class="keyword">from</span> tb_emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;韦一笑&#x27;</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_emp <span class="keyword">where</span> entrydate <span class="operator">=</span> &quot;2007-01-01&#x27; and job=2;</span><br><span class="line">//select * from tb_emp where (entrydate,job) = (&quot;<span class="number">2007</span><span class="number">-01</span><span class="number">-01</span><span class="string">&#x27;,2);</span></span><br><span class="line"><span class="string">select * from tb_emp where (entrydate,job) = (select entrydate,job from tb_emp where name = &#x27;</span>韦一笑<span class="string">&#x27;);</span></span><br></pre></td></tr></table></figure><h3 id="表子查询">表子查询</h3><img src="/post-img/Pasted image 20230726163732.png" alt="图片损坏" style="zoom:100%;" /><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span>,d.name <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_emp <span class="keyword">where</span> entrydate <span class="operator">&gt;</span><span class="string">&#x27;2006-01-01&#x27;</span>) e,tb_dept d <span class="keyword">where</span> e.dept_id <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure><h1>事务和索引</h1><h2 id="事务">事务</h2><p>一组操作的集合，这组操作要么全部成功，要么全部失败<br><img src="/post-img/Pasted image 20230726163756.png" alt="图片损坏" style="zoom:100%;" /><br><img src="/post-img/Pasted image 20230726163819.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="索引">索引</h2><p>索引时帮助数据库高效获取数据的数据结构，在mysql中，默认使用的是B+树（多路平衡搜索树）<br>没有索引，查询数据需要进行全表扫描，在数据量大时效率极低；通过索引，可以大幅缩短查询所需的时间</p><h3 id="优点">优点</h3><p>提高数据查询的效率，降低数据库的lO成本。<br>通过索引列对数据进行排序,降低数据排序的成本，降低CPU消耗。</p><h3 id="缺点">缺点</h3><p>索引会占用存储空间。<br>索引大大提高了查询效率，同时却也降低了insert、update、delete的效率。</p><h3 id="语法">语法</h3><img src="/post-img/Pasted image 20230726164532.png" alt="图片损坏" style="zoom:100%;" />主键字段，在建表时，会自动创建主键索引。添加唯一约束时，数据库实际上会添加唯一索引。<h3 id="B-树的特点">B+树的特点</h3><p>1.每一个节点，可以存储多个key(有n个key，就有n个指针)。<br>2.所有的数据都存储在叶子节点,非叶子节点仅用于索引数据。<br>3.叶子节点形成了一颗双向链表,便于数据的排序及区间范围查询。</p>]]></content>
    
    
    <summary type="html">java基础知识</summary>
    
    
    
    <category term="mysql" scheme="https://xlxq.fun/categories/mysql/"/>
    
    
    <category term="mysql" scheme="https://xlxq.fun/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>redis数据结构</title>
    <link href="https://xlxq.fun/posts/abcb1f8f.html"/>
    <id>https://xlxq.fun/posts/abcb1f8f.html</id>
    <published>2023-08-18T10:19:03.000Z</published>
    <updated>2023-08-20T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>通常所说的redis常用数据类型string，hash，set，list，sortedSet等<br>其底层都是精心优化过的数据结构，这也是redis拥有高性能的重要原因之一<br>概括的说，redis的底层有六种数据结构，分别是<strong>SDS（简单动态字符串），hashtable（哈希表），skiplist（跳表），ziplist（压缩列表），intset（整数集合），linkedlist（双向链表）</strong><br>本文从常用的五种数据类型入手，依次说明其底层数据结构</p><h1>字典（dict）</h1><p>字典是redis用来存储所有数据（K-V类型）的一种统一结构体，其定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">dictType *type;</span><br><span class="line"><span class="type">void</span> *privdata;</span><br><span class="line">dictht ht[<span class="number">2</span>];</span><br><span class="line"><span class="type">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125;dict;</span><br></pre></td></tr></table></figure><ol><li><code>dictType *type;</code>  这是一个指向 <code>dictType</code> 结构体的指针，用于表示字典的类型。<code>dictType</code> 中包含了一系列函数指针，定义了字典的操作方法，例如哈希函数、键比较函数和值释放函数等。通过这个指针，字典可以支持不同类型的键值对。</li><li><code>void *privdata;</code>  这是一个指向私有数据的指针，允许用户为字典提供额外上下文信息。</li><li><code>dictht ht[2];</code>  这是一个<strong>包含两个元素的数组，每个元素都是 <code>dictht</code> 结构体的实例</strong>。<code>dictht</code> 是 Redis 字典的哈希表表示，而数组的两个元素则<strong>用于实现哈希表的 rehash 操作</strong>。在 rehash 过程中，字典会使用两个哈希表，逐步将数据从旧表迁移到新表。</li><li><code>long rehashidx;</code>  这是一个长整型变量，<strong>表示当前 rehash 操作的索引</strong>。如果 <code>rehashidx</code> 的值为 -1，表示没有进行 rehash 操作。否则，它表示正在进行 rehash 操作，指示当前正在迁移旧表的索引位置。</li><li><code>unsigned long iterators;</code>  这是一个无符号长整型变量，表示当前正在运行的迭代器的数量。字典的修改操作可能会受到迭代器的影响，因此需要追踪迭代器的数量，以确保安全的遍历字典。</li></ol><h1>dictht（hashtable）</h1><p>dictht是redis中用来存储实际数据的结构体，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">dictEntry **table;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> sizemask ;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure><ol><li><code>dictEntry **table;</code>  这是一个<strong>指向指针数组的指针</strong>，用于表示哈希表的槽位。每个槽位可以包含一个指向 <code>dictEntry</code> 结构体的指针，或者为 <code>NULL</code>，表示该槽位为空。<code>dictEntry</code> 结构体表示哈希表中的一个键值对。<strong>类比hashMap中的数组+链表</strong></li><li><code>unsigned long size;</code>  这是一个无符号长整型变量，表示哈希表的大小，即槽位的数量。它表示哈希表中<strong>可以存储的最大键值对数目</strong></li><li><code>unsigned long sizemask;</code>  这是一个无符号长整型变量，用于快速计算索引位置的掩码。在哈希表的大小为 2 的幂时，通过 <code>sizemask</code> 可以替代取模运算，提高效率。</li><li><code>unsigned long used;</code>  这是一个无符号长整型变量，表示哈希表中当前已经使用的槽位数量，即<strong>已经存储的键值对数目</strong></li></ol><h1>redisObject</h1><p>上面说到redis用dict来存储所有的K-V数据类型，这就像是java中的Map，键固定为String类型，但值可有五种数据类型啊，C语言中又没有类似Object这样的类，于是有了redisObject，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//对象最后一次被访问的时间</span></span><br><span class="line">    <span class="type">unsigned</span> lru:REDIS_LRU_BITS</span><br><span class="line">    <span class="comment">//引用计数</span></span><br><span class="line">    <span class="type">int</span> refcount</span><br><span class="line">    <span class="comment">//指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    ...</span><br><span class="line">&#125; redisObject;</span><br></pre></td></tr></table></figure><ol><li><code>unsigned type:4;</code>  这是一个 4 位的无符号整数，<strong>表示对象的类型</strong>。</li><li><code>unsigned encoding:4;</code>  这是一个 4 位的无符号整数，表示对象的编码方式。Redis 对于不同类型的对象可以使用不同的编码方式，以优化存储和处理性能。以下是一些编码常量：<img src="/post-img/Pasted image 20240216141600.png" alt="图片损坏" style="zoom:100%;" /></li><li><code>unsigned lru:REDIS_LRU_BITS;</code>  这是一个用于 LRU（Least Recently Used）算法的字段，用于记录对象最后一次被访问的时间。</li><li><code>int refcount;</code>  这是一个整数，表示对象的引用计数。引用计数用于追踪对象被引用的次数，确保在没有引用时可以安全地释放对象的内存。</li><li><code>void *ptr;</code>  这是一个指向底层实现数据结构的指针。根据对象的类型和编码方式，<code>ptr</code> 指向实际存储数据的具体结构。例如，对于字符串对象，<code>ptr</code> 可能指向一个包含字符串数据的结构。</li></ol><p><strong>综上我们知道，redis用dict所指向的hashtable结合redisObject已经可以表示五种数据类型，但其实并不是五种数据类型都是通过dict实现的，redis还维护了其它数据结构来优化性能</strong></p><h1>string</h1><h2 id="SDS">SDS</h2><p>string类型的底层是通过SDS实现的，C语言中的字符串是不可变的，使用起来不方便<br>SDS应运而生，它有三个参数：</p><ol><li>len ：保存的字符串长度。获取字符串的长度就是O(1)</li><li>free：剩余可用存储字符串的长度</li><li>buf： 字符串数组，保存字符串<br>通过上述参数，SDS可以实现动态更改字符串的长度，具体实现如下：</li><li><strong>预分配空间：</strong><ul><li>SDS 在分配空间时，会预先分配一定的额外空间，避免每次追加操作都触发内存重新分配。 这个额外空间的大小由 SDS 结构中的free属性表示。</li><li>SDS 的空间分配策略采用了多种方式，根据当前字符串长度和预分配策略动态调整。当字符串长度小于 1MB 时，每次追加操作会分配两倍于所需空间的额外空间。当字符串长度大于等于 1MB 时，每次追加操作只会额外分配1MB的空间。</li></ul></li><li><strong>惰性空间释放：</strong><ul><li>SDS 采用惰性空间释放的策略，即在删除字符串内容时，并不立即释放相应的内存。保留已分配的内存（增大free的值），以备将来再次追加字符串时直接使用，避免频繁的内存分配和释放。</li></ul></li><li><strong>其它特点</strong>：<ul><li>len参数的存在使得获取字符串的长度是O(1)时间复杂度</li><li>上述两种空间分配策略使得SDS能很好的杜绝缓冲区移除和内存泄漏</li><li>SDS可以包含任何数据，最大可存512M，这也是为什么redis的key不能超过512M</li></ul></li></ol><h2 id="int">int</h2><p>对于简单数字或数字字符串，redis会采用int编码，严格意义上并不算是一种数据结构，也就是上述编码变量中的REDIS_ENCODING_INT</p><h1>list</h1><p>list的底层采用的是压缩列表和双向链表</p><h2 id="压缩列表（ziplist）">压缩列表（ziplist）</h2><p>数据量较少时采用<br>具体当list对象同时满足以下两个条件时，使用ziplist<br> 1. list对象保存的所有字符串元素长度都小于64字节<br> 2. list对象保存的元素数量小于512个<br>结构(从前到后依次是)：<br><strong>zlbytes</strong>： 4byte，记录整个压缩列表占用的内存字节数,在对压缩列表内存重分配或计算zlend位置时使用<br><strong>zltail</strong>：4byte，记录最后一个节点离列表起始地址有多少个字节通过这个偏移量，就可以不用遍历整个列表就知道尾节点的位置了<br><strong>zllen</strong>：2byte，记录列表中的节点数,值小于unit16_max(65535)时是准确值，大于时需要遍历<br><strong>entry1…entryN</strong>：列表节点，不定长<br><strong>zlend</strong>：特殊值，标记列表末端<br>在压缩列表中，元素按顺序存储，但不保留插入的顺序信息。每个元素的长度可以是不定长的，这使得压缩列表可以更灵活地存储不同长度的元素。<br>压缩列表也支持快速的头部和尾部插入和删除操作，在某些操作上可能比双向链表更紧凑，特别是在元素较小的情况下。但一般情况下，ziplist的增删改查需要遍历，为O(N)时间复杂度</p><h2 id="双向链表（linkedlist）">双向链表（linkedlist）</h2><p>使用redis的list数据结构时，存储数据较大时，list对象已经不满足上面描述的ziplist条件，则会使用linkedlist，修改效率高，但占用更多内存（存放指针）</p><h2 id="快速列表（quickList）">快速列表（quickList）</h2><p>Quicklist 是对双向链表的进一步优化，将长列表分成多个节点，每个节点都是一个压缩列表。这样，Quicklist 结合了双向链表和压缩列表的优势，提高了对长列表的操作效率。<br>每个 Quicklist 节点都包含压缩列表指针若干和当前节点中元素（所有指针指向的压缩列表中元素总和）的数量</p><h1>hash</h1><p>hash的底层采用的是ziplist 或hashtable，其中ziplist同上，每个列表节点都变为hash类型</p><h2 id="hashtable（dict字典）">hashtable（dict字典）</h2><p><strong>哈希表是字典的一种实现方式，而字典是键值对存储的通用概念</strong><br>字典是哈希类型的一种底层数据结构，它使用哈希表（数组）来存储键值对。哈希表通过哈希函数计算键的索引，将键值对存储在相应的槽（bucket）中。字典的主要特点包括：</p><ul><li><strong>O(1) 时间复杂度的查找、插入和删除操作</strong>：由于哈希表的设计，它提供了快速的键值对查找、插入和删除操作。</li><li><strong>动态扩展和收缩</strong>：字典会根据实际元素数量动态调整哈希表的大小，以平衡内存占用和性能。</li></ul><h3 id="详细说明">详细说明</h3><ol><li><strong>结构（hash表）:</strong><ul><li>Redis 字典的底层数据结构是哈希表，它是一个数组，每个数组元素称为<strong>桶</strong>（bucket）。这个数组的大小是可动态调整的，根据实际存储的键值对数量动态分配。每个桶中又可以存储一个或多个键值对。哈希表使用哈希函数将键映射到数组的特定位置，即桶的索引。</li></ul></li><li><strong>链地址法解决冲突:</strong><ul><li>在哈希表中，可能会出现多个键经过哈希函数后映射到同一个桶的情况，这被称为哈希冲突。Redis 使用链地址法（Separate Chaining）来解决冲突，即在每个桶中维护一个链表，将映射到同一个桶的键值对串在链表上。</li></ul></li><li><strong>O(1) 操作:</strong><ul><li>查找操作：通过哈希函数计算键的哈希值，定位到对应的桶，然后在链表中查找对应的键值对。由于链表长度相对较短，查找时间是常数级别的，即 O(1)。</li><li>插入操作：同样通过哈希函数计算哈希值，定位到对应的桶，然后在链表中插入新的键值对。由于链表操作是常数时间，插入操作也是 O(1)。</li><li>删除操作：通过哈希函数计算哈希值，定位到对应的桶，然后在链表中删除对应的键值对。链表删除操作也是常数时间，所以删除操作是 O(1)。<br>由于哈希表的设计，使得<strong>查找、插入和删除等操作具有常数级别的时间复杂度</strong>，即 O(1)。然而，需要注意的是，在极端情况下，如果哈希冲突过于频繁，导致链表变得很长，性能可能会下降，但平均情况下哈希表提供了高效的字典操作。</li></ul></li></ol><h3 id="hash表的扩展和收缩">hash表的扩展和收缩</h3><ol><li>当哈希表中元素数量达到一定阈值，为了避免哈希冲突过于频繁，Redis 会触发哈希表的<strong>扩展操作</strong>：新建一个更大的哈希表（通常是当前大小的两倍），然后将旧哈希表中的元素重新分布到新哈希表中。由于哈希表扩展是一个耗时的操作，为了不阻塞其他操作，Redis 使用了<strong>渐进式扩展</strong>的策略。这意味着 rehash 操作不会一次性完成，而是分多次逐步完成。在每个事件循环中，只处理一小部分键值对的 rehash 操作。这样可以分摊 rehash对 CPU 和内存的影响，使得系统在扩展时仍能保持响应。</li><li>当哈希表中的元素数量下降到一定程度，为了节省内存，Redis 可以触发哈希表的<strong>收缩操作</strong>：新建一个更小的哈希表，将旧哈希表中的元素重新分布到新哈希表中。与扩展类似，收缩操作也是一个耗时的操作，为了不阻塞其他操作，可以采用<strong>渐进式收缩</strong>的策略。Redis 使用两个哈希表，旧哈希表和新哈希表。在rehash过程中，会逐步将旧哈希表的元素迁移到新哈希表，同时保持两个表中的元素共存。在每个事件循环中，只迁移一小部分元素，减少对系统性能的影响。</li><li>扩展和收缩用到了dict中定义的两个变量ht[2]和rehashidx，ht[2]保存了两个hashtable，通常情况下，只会用到其中一个，当需要扩容时，另一个hashtable会申请一个较大的空间，每次CRUD操作中，rehashidx都会自增，将指向的元素迁移（如果一直没有指向元素，自增10次就会停止），这就是<strong>渐进式哈希</strong>。</li></ol><h1>set</h1><p>set底层使用的是intset 或hashtable</p><h2 id="intset">intset</h2><ol><li>结构：length（元素数量）记录了 intset中元素的数量。contents（元素数组）实际存储整数，元素按照从小到大的顺序存储。</li><li>特点：<ul><li>intset设计紧凑，对于小型整数集合可以减小内存开销。</li><li>元素按照从小到大的顺序存储，这使得在整数集合上执行范围查询等操作更加高效。</li><li>通过二分查找，<code>intset</code> 可以在 O(log N) 的时间内完成查找操作。插入操作也可以在 O(N) 的时间内完成，因为可能需要进行数组的移动和扩容。</li><li>适用于小型整数集合，当整数集合较大时，intset的性能可能不如其他数据结构</li></ul></li><li>补充：<ul><li>节约内存，但由于是连续空间，修改效率不高</li><li>集合中的数都是整数时，且数据量不超过512个时，使用intset，set默认使用hashtable</li></ul></li></ol><h1>sortedSet</h1><p>底层是由ziplist 或 skiplist 实现的<br>有序集合是有序的集合数据结构，每个元素都与一个分数（score）相关联，通过分数进行排序。有序集合中的元素也可以是各种类型，不仅限于整数。分数可以是整数或浮点数。</p><h2 id="skiplist">skiplist</h2><h3 id="结构">结构</h3><ol><li>节点结构：<br>每个节点包含了两个主要部分以及指针：<ul><li>成员（Member）：存储有序集合中的元素（例如字符串）。</li><li>分值（Score）：与成员相关联的分值，用于排序。分值可以是整数或浮点数。</li><li>指针：用于在不同层级上进行快速查找。</li></ul></li><li>多层级结构：<ul><li>skiplist由很多层结构组成，每一层都是一个有序的链表，默认是升序，也可以根据创建映射时所提供的Comparator进行排序，具体取决于使用的构造方法</li><li>最底层(Level 1)的链表包含所有元素，如果一个元素出现在Level i 的链表中，则它在Level i 之下的链表也都会出现。例如，出现在level 3中，则会出现在level 2和level 1中。后续插入新的节点时，会<strong>随机选取插入的层级</strong>，这也影响到该层级之下的所有层级中是否需要插入该节点</li><li>每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素</li></ul></li><li>多级索引：<ul><li>为了提高查找效率，Skiplist包含了多级索引，每一级索引都是元素的子集。这些索引允许在不必遍历所有节点的情况下，通过跳过一些节点来快速找到目标节点。查询时，如果在当前层级找到了大于等于目标元素的位置，就可以下降到下一层级，继续查找，可以在 O(log N) 的时间内完成查询操作</li></ul></li><li>虚拟头节点：<ul><li>Skiplist中通常包含一个虚拟头节点，它不存储实际数据，但有助于简化代码逻辑，使得实现更加简洁。</li></ul></li></ol><h3 id="特点">特点</h3><ul><li>层次结构：skiplis 使用多层级的链表，每一层都是元素的子集。这种层次结构使得在有序集合中进行范围查询更加高效。</li><li>快速查询：skiplist具有 O(log N) 时间复杂度的查询操作，这使得查找某个成员或某个分值范围的成员非常高效。</li><li>元素存储：每个节点包含了一个成员和分值，同时具有多个指针，用于在不同层级上进行快速查找。</li><li>适用范围：适用于较大有序集合，对于元素数量较多或者需要频繁进行范围查询的情况。</li></ul><h1>总结</h1><p>string底层的数据结构：SDS，int<br>list底层的数据结构：ziplist、linkedlist、quicklist<br>hash底层的数据结构：ziplist、hashtable（dict）<br>set底层的数据结构：intset、hashtable（dict）<br>sortedSet底层的数据结构：ziplist、skiplist</p>]]></content>
    
    
    <summary type="html">redis</summary>
    
    
    
    <category term="redis" scheme="https://xlxq.fun/categories/redis/"/>
    
    
    <category term="redis" scheme="https://xlxq.fun/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis为什么高性能</title>
    <link href="https://xlxq.fun/posts/561bfca6.html"/>
    <id>https://xlxq.fun/posts/561bfca6.html</id>
    <published>2023-08-18T10:19:03.000Z</published>
    <updated>2023-08-20T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>原因总结</h1><p>redis作为数据库能拥有如此高的性能具有多方面的原因，本文来探讨其中重要的一部分</p><ol><li><strong>网络I/O：</strong><ul><li><strong>非阻塞I/O模型：</strong> Redis使用非阻塞I/O模型，采用事件驱动的方式进行网络通信。这意味着在一个线程内，可以同时处理多个客户端请求而无需为每个连接创建一个新线程。这提高了并发处理能力。</li><li><strong>高效的协议：</strong> Redis使用轻量级的文本协议，如RESP（REdis Serialization Protocol），它简单而高效，减少了网络传输的开销。</li></ul></li><li><strong>磁盘I/O：</strong><ul><li><strong>内存数据库：</strong> Redis主要将数据存储在内存中，减少了对磁盘的频繁读写操作。这使得对数据的访问速度非常快，适用于高速读写的场景。</li><li><strong>持久化机制：</strong> 尽管主要是内存数据库，但Redis提供了多种持久化机制，如RDB快照和AOF日志文件。这些机制可以根据需求进行配置，以实现数据持久化，同时尽量减小对性能的影响。</li></ul></li><li><strong>计算速度：</strong><ul><li><strong>单线程模型：</strong> Redis采用单线程模型，通过使用高效的数据结构和算法，提高了在单个线程上的计算速度。这对于简单的操作和高并发场景是非常有效的。</li></ul></li><li><strong>数据结构：</strong><ul><li><strong>优化的数据结构：</strong> Redis提供了丰富的数据结构，如字符串、哈希表、有序集合等。这些数据结构在实现上经过了优化，使得它们在各自的应用场景下能够高效地执行相关操作。</li><li><strong>内部编码：</strong> Redis对不同类型的值采用了不同的内部编码方式，例如压缩列表、哈希表、跳跃表等，以提高存储效率。</li></ul></li><li><strong>多路复用：</strong><ul><li><strong>事件驱动和多路复用：</strong> Redis使用事件驱动的模型，通过多路复用技术（如<code>epoll</code>、<code>kqueue</code>等）来处理多个客户端连接。这允许Redis在单个线程上同时监听多个套接字，提高了并发连接的处理能力。</li></ul></li><li><strong>Pipeline 操作：</strong><ul><li><strong>批量操作：</strong> Redis支持Pipeline操作，可以将多个命令打包一次性发送到服务器执行，减少了往返时间。这对于需要执行大量命令的场景，如批量读取或写入，能够显著提高性能。</li></ul></li><li><strong>分布式架构：</strong><ul><li><strong>分布式部署：</strong> Redis支持分布式部署，可以通过分片或集群的方式水平扩展。这意味着可以在多个节点上分布负载，提高整体性能。</li></ul></li><li><strong>内存管理和优化：</strong><ul><li><strong>内存碎片整理：</strong> Redis通过使用内存池和优秀的内存管理算法，减少了内存碎片的产生，提高了内存利用率。</li></ul></li></ol><h1>补充</h1><h2 id="关于多路复用">关于多路复用</h2><p>io多路复用是五种io模型（阻塞IO、非阻塞IO、IO多路复用、信号驱动IO、异步IO）之一</p><h3 id="I-O模型">I/O模型</h3><ol><li>阻塞 I/O 模型（Blocking I/O）:<ul><li>当一个应用程序发起 I/O 操作时，它会被阻塞，直到操作完成。在此期间，应用程序无法执行其他任务。</li><li>适用于简单的同步操作，对于每个操作都等待其完成。</li></ul></li><li>非阻塞 I/O 模型（Non-blocking I/O）:<ul><li>应用程序发起 I/O 操作后，可以继续执行其他任务而不被阻塞。需要通过轮询或者回调等方式来检查操作是否完成。</li><li>适用于需要同时处理多个任务的场景，可以通过轮询或事件通知来实现。</li></ul></li><li>多路复用 I/O 模型（Multiplexing I/O）:<ul><li>通过一种机制（如<code>select</code>、<code>poll</code>、<code>epoll</code>、<code>kqueue</code>等）同时监听多个 I/O 通道，当任意通道就绪时进行处理。</li><li>适用于需要同时处理多个连接的场景，提高了系统的并发性。</li></ul></li><li>信号驱动 I/O 模型（Signal-driven I/O）:<ul><li>应用程序发起 I/O 操作后，通过信号通知操作的完成。应用程序可以继续执行其他任务。</li><li>适用于需要异步通知的场景，但相对较少使用。</li></ul></li><li>异步 I/O 模型（Asynchronous I/O）:<ul><li>应用程序发起 I/O 操作后，可以继续执行其他任务。当操作完成时，应用程序通过回调或其他方式得到通知。</li><li>适用于需要异步处理的场景，能够提高并发和系统的响应性。</li></ul></li></ol><p>下面重点阐述I/O多路复用模型：<br>非阻塞IO解决了一部分问题，即应用程序发起 I/O 操作后，可以继续执行其他任务而不被阻塞，但是，仍需要进行轮询或者回调等方式来检查操作是否完成。那么有没有可能，当操作完成时再通知应用程序来避免“无用功”呢？</p><ol><li><strong>文件描述符</strong>，简称FD，是一个从0 开始的无符号整数，用来关联Linux中的一个文件。在Linux中，一切皆文件，例如常规文件、视频、硬件设备等，当然也包括网络套接字（Socket）。</li><li>当用户去读取数据的时候，<strong>不再去直接调用recvfrom</strong>（在网络编程中用于接收数据的系统调用）了，<strong>而是调用select函数</strong>，select函数会将需要监听的数据交给内核，由内核去检查这些数据是否就绪了，如果说这个数据就绪了，就会通知应用程序数据就绪，然后来读取数据，再从内核中把数据拷贝给用户态，完成数据处理，如果N多个FD一个都没处理完，此时就进行等待。</li><li>监听FD的方式、通知的方式又有多种实现，常见的有：select、poll、epoll</li></ol><ul><li>select和pool相当于是当被监听的数据准备好之后，会把监听的FD整个数据都发送给调用者，需要通过遍历的方式到整个FD中去找哪些是处理好了的文件，所以性能也并不是那么好</li><li>epoll则相当于内核准备好了之后，会把准备好的数据，直接发给调用者</li></ul><h2 id="关于事件驱动">关于事件驱动</h2><p>Redis采用单线程的事件驱动模型，而多路复用则是这种模型的一部分，它的核心是通过监听多个套接字（sockets）上的事件，从而在单个线程内同时处理多个客户端的请求。</p><h3 id="主要组成部分">主要组成部分</h3><ol><li><strong>事件处理器（Event Loop）:</strong><ul><li>Redis的事件处理器负责监听和分发事件。它通过调用操作系统提供的多路复用函数（如<code>select</code>、<code>poll</code>、<code>epoll</code>、<code>kqueue</code>等）来检测套接字上的事件。</li></ul></li><li><strong>文件事件（File Events）:</strong><ul><li>文件事件用于处理套接字上的各种事件，例如可读事件、可写事件、连接事件等。在 Redis 中，<strong>客户端的命令请求和服务器的响应都是通过文件事件来传递的</strong>。</li></ul></li></ol><h3 id="工作流程（事件循环）">工作流程（事件循环）</h3><ol><li><strong>监听事件：</strong><ul><li>事件处理器监听套接字上的事件，包括连接事件、读事件、写事件等。</li></ul></li><li><strong>等待事件：</strong><ul><li>事件处理器等待发生事件的通知。这可以通过阻塞调用多路复用函数，或者使用非阻塞I/O模型中的回调函数来实现。</li></ul></li><li><strong>事件分发：</strong><ul><li>当套接字上发生事件时，事件处理器将事件分发给相应的事件处理函数。例如，可读事件将触发处理命令请求的函数，可写事件将触发发送响应的函数。</li></ul></li><li><strong>执行事件处理函数：</strong><ul><li>事件处理函数执行相应的逻辑，例如处理命令请求、发送响应等。由于采用了非阻塞I/O，一个事件处理函数在执行时不会阻塞其他事件的处理。</li></ul></li><li><strong>重复：</strong><ul><li>事件处理器不断重复上述过程，监听、等待、分发、执行，以处理多个套接字上的事件。</li></ul></li></ol><h3 id="优点">优点</h3><ul><li><strong>高并发：</strong> 多路复用使得 Redis 能够在单线程内同时处理大量的客户端连接，提高了并发处理能力。</li><li><strong>低延迟：</strong> 通过非阻塞I/O和事件驱动模型，Redis可以实现低延迟的请求处理。</li><li><strong>资源效率：</strong> 单线程的事件处理模型减少了线程切换的开销，提高了资源利用率。</li></ul><h2 id="pipeline（Redis管道）">pipeline（Redis管道）</h2><p>Redis的管道（Pipeline）机制是一种优化技术，用于在客户端与服务器之间批量执行多个命令。通过管道机制，可以减少往返时间，提高性能，尤其是在需要执行大量命令时。<br>基本原理如下：</p><ol><li><strong>批量发送命令：</strong> 客户端可以将多个命令一次性发送给服务器，而不是分开发送。</li><li><strong>一次性获取回复：</strong> 服务器接收到命令后，不会立即执行，而是将命令缓存起来。然后一次性执行所有命令，并将结果按照命令发送的顺序一次性返回给客户端。<br>使用管道机制的好处有：</li></ol><ul><li><strong>减少网络往返时间：</strong> 因为所有命令都在一次通信中完成，而不是多次单独通信。</li><li><strong>提高吞吐量：</strong> 在需要执行大量命令时，通过批量操作可以显著提高性能。<br>创建管道—&gt;向管道中添加命令—&gt;执行命令并获取结果executePipelined</li></ul><h1>总结</h1><p>redis高性能的原因：</p><ol><li>基于内存，计算速度快，减少了对磁盘的频繁读写操作，高速读写</li><li>C语言编写，优化的数据结构</li><li>非阻塞IO模型（多路复用），高效简单的协议</li><li>支持分布式架构扩展，搭建高可用集群</li></ol>]]></content>
    
    
    <summary type="html">redis</summary>
    
    
    
    <category term="redis" scheme="https://xlxq.fun/categories/redis/"/>
    
    
    <category term="redis" scheme="https://xlxq.fun/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>mysql中的锁</title>
    <link href="https://xlxq.fun/posts/ef86472b.html"/>
    <id>https://xlxq.fun/posts/ef86472b.html</id>
    <published>2023-08-14T10:19:03.000Z</published>
    <updated>2023-08-20T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>数据库锁是用于管理并发访问数据库的机制，其主要作用是控制多个事务对共享资源（如数据表、数据行）的访问，以确保数据的一致性和完整性。锁可以防止多个事务同时对同一资源进行不同的操作，从而避免并发问题。</p><h1>从锁的粒度划分</h1><ol><li><strong>行级锁（Row-level Lock）：</strong> 行级锁是一种细粒度的锁，允许事务锁定表中的某一行或某几行，而不是整个表。这种锁的作用是减小锁的粒度，允许并发性更高，减少锁冲突。</li><li><strong>表级锁（Table-level Lock）：</strong> 表级锁是锁定整个表的锁，它的粒度比行级锁更粗，通常会阻塞其他事务的操作，因此在高并发情况下可能导致性能问题。表级锁的使用应该尽量避免，除非确实需要锁定整个表。</li><li><strong>页级锁</strong>：是粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折中的页级，一次锁定相邻的一组记录。</li></ol><h1>从使用性质划分</h1><p>InnoDB 实现了标准的行级锁，包括两种：<strong>共享锁（简称 s 锁）、排它锁（简称 x 锁）。</strong></p><ol><li><strong>共享锁（Shared Lock）：</strong> 也称为读锁。多个事务可以同时持有共享锁，并且不会阻塞其他事务的共享锁。共享锁用于读取操作，允许多个事务同时读取相同的资源，但阻止其他事务持有排他锁。</li><li><strong>排他锁（Exclusive Lock）：</strong> 也称为写锁。只有一个事务可以持有排他锁，其他事务无法同时持有共享锁或排他锁。排他锁用于写入操作，确保只有一个事务可以修改资源，防止其他事务读取或写入相同的资源。</li><li><strong>意向锁（Intention Lock）：</strong> 意向锁是用来表示事务打算对资源进行哪种类型的锁定（共享锁或排他锁）。意向锁不会阻止其他事务获取共享或排他锁，但它们提供了一种机制，让事务了解其他事务的锁定意图，以便更好地管理锁。</li></ol><h1>从主观上划分</h1><ol><li><strong>乐观锁</strong>（Optimistic Lock）：顾名思义，从主观上认定资源是不会被修改的，所以不加锁读取数据，仅当更新时用版本号机制等确认资源是否被修改。乐观锁适用于多读的应用类型，可以系统提高吞吐量。通常通过<strong>增加额外字段</strong>来实现，但仅仅体现一种思想，进行数据库操作时还是使用的mysql底层的锁（悲观锁）</li><li><strong>悲观锁</strong>（Pessimistic Lock）：正如其名，具有强烈的独占和排它特性，每次读取数据时都会认为会被其它事务修改，所以每次操作都需要加上锁。</li></ol><h1>InnoDB中的锁算法（加锁模式）</h1><ul><li>Record Lock：单个行记录上的锁。</li><li>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身</li><li>Next-Key Lock：Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身</li><li>它们都是行级锁的实现</li></ul><h2 id="记录锁（Record-Lock）">记录锁（Record Lock）</h2><p>对表中的记录加锁（锁住索引记录，而不是真正的数据记录）叫做记录锁，简称行锁（区别于行级锁）。例如下面的sql会在 id=1 的记录上加上记录锁，以阻止其他事务插入，更新，删除 id=1 这一行。注意：id 列必须为唯一索引列或主键列，同时查询语句必须为精准匹配（=），不能为 &gt;、&lt;、like 等，否则会退化成临键锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test` <span class="keyword">WHERE</span> `id`<span class="operator">=</span><span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><h2 id="间隙锁（Gap-Locks）">间隙锁（Gap Locks）</h2><p>间隙锁是一种特殊的锁，用于<strong>锁定范围内的间隙</strong>（两个值之间的空间），<strong>存在于非唯一索引中</strong>，以防止其他事务插入新行。这有助于<strong>避免幻读</strong>问题。当事务查询数据时，InnoDB可以自动获取间隙锁来保护查询范围。例如emp 表中只有 101 条记录，其 empid 的值分别是1, 2, …, 100, 101，下面的SQL不仅会对符合条件的 empid 值为 101 的记录加锁，也会对 empid 大于 101（这些记录并不存在）的 “间隙” 加锁。这时如果插入 empid 等于 102 的数据，如果那边事务还没有提交，就会处于等待状态，无法插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empid <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure><h2 id="临键锁（Next-Key-Locks）">临键锁（Next-Key Locks）</h2><p>Next-key 锁是记录锁和间隙锁的组合，它指的是加在<strong>某条记录以及这条记录前面间隙上</strong>的锁，<strong>存在于非唯一索引中</strong>。 InnoDB使用Next-Key Locks来处理范围查询和避免幻读。这种锁将行级锁与间隙锁结合起来，确保不会有新行插入到查询范围内。可以理解为一种特殊的间隙锁。通过临建锁可以解决幻读的问题。每个数据行上的<strong>非唯一索引</strong>列（该索引里面的值允许重复）上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段 <strong>左开右闭</strong> 区间的数据。例如，假设有如下表，其中id 是主键，age是普通索引。<img src="/post-img/Pasted image 20240215222036.png" alt="图片损坏" style="zoom:100%;" />该表中 age 列潜在的临键锁有：(-∞, 10]，(10, 24]，(24, 32]，(32, 45]，(45, +∞]。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在事务 A 中执行如下命令之一：</span><br><span class="line"><span class="comment">-- 根据非唯一索引列 UPDATE 某条记录 </span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span> <span class="keyword">SET</span> name <span class="operator">=</span> Vladimir <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">24</span>; </span><br><span class="line"><span class="comment">-- 或根据非唯一索引列 锁住某条记录 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">24</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line">会导致以下命令被阻塞：</span><br><span class="line">（事务A在对age为<span class="number">24</span>的列进行<span class="keyword">UPDATE</span>操作的同时也获取了(<span class="number">10</span>, <span class="number">32</span>]这个区间内的临键锁）</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">table</span> <span class="keyword">VALUES</span>(<span class="number">100</span>, <span class="number">26</span>, <span class="string">&#x27;tianqi&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这里对 记录锁、间隙锁、临键锁 做一个总结：<br>InnoDB 中的行锁的实现依赖于索引，一旦某个加锁操作没有使用到索引，那么该锁就会退化为表锁。<br>记录锁 存在于包括 主键索引 在内的唯一索引中，锁定 单条索引 记录。<br>间隙锁 存在于 非唯一索引 中，锁定开区间范围内的一段间隔，它是基于 临键锁 实现的。<br>临键锁 存在于 非唯一索引 中，该类型的每条记录的索引上都存在这种锁，它是 一种特殊的间隙锁，锁定一段 左开右闭 的索引区间。</p><h1>拓展</h1><h2 id="意向锁">意向锁</h2><p>意向锁分为 <strong>意向共享锁（IS）</strong> 和 <strong>意向排他锁（IX）</strong>，是表锁的实现，存在的目的是为了让 InnoDB 中的<strong>行锁和表锁更高效的共存</strong>。</p><ul><li>意向共享锁（IS）和 意向排他锁（IX）都是 <strong>表锁</strong>。</li><li>意向锁是一种 <strong>不与行级锁冲突的表级锁</strong>，这一点非常重要。</li><li>意向锁是 InnoDB 自动加的， 不需用户干预。</li><li>意向锁是在 InnoDB 下存在的内部锁，对于MyISAM 而言没有意向锁之说。</li></ul><ol><li>当某个事务user表中的某行上了排他锁时（例如记录、间隙、临键等），另一个事务此时需要获取表锁，因为共享锁与排他锁互斥，所以事务B对user表加共享锁的时候，必须保证：当前没有其他事务持有 users 表的排他锁，当前没有其他事务持有 users 表中任意一行的排他锁 。后者必<strong>须通过遍历</strong>表中的每一行才能知道，这是一种低效的做法。</li><li>有了意向锁之后，事务 B 只要看表上有没有意向排他锁（某行上了排他锁时会自动为表获取），有则说明表中有些行被行锁锁住了，因此，事务 B 申请表的写锁会被阻塞。</li><li>意向锁与意向锁之间永远是兼容的，因为不论加行级的 X 锁或 S 锁，都会自动获取表级的 IX 锁或者 IS 锁。也就是有 10 个事务，对不同的 10 行加了行级 X 锁，那么这个时候就存在 10 个 IX 锁。这 10 个 IX 存在的作用就是假如这个时候有个事务，想对整个表加排它 X 锁,那它不需要遍历每一行是否存在 S 或 X 锁，而是看有没有存在意向锁，只要存在一个意向锁，那这个事务就加不了表级排它(X)锁，要等上面 10 个 IX 全部释放才行。</li></ol><h2 id="插入意向锁">插入意向锁</h2><ul><li>插入意向锁是在<strong>插入</strong>一条记录行前，由 INSERT 操作产生的一种间隙锁。</li><li>虽然插入意向锁中含有意向锁三个字，但是它并不属于意向锁而属于<strong>间隙锁</strong>，因为意向锁是表锁，而插入意向锁是行锁。</li><li>假设存在两条值分别为 4 和 7 的记录，两个不同的事务分别试图插入值为 5 和 6 的两条记录，每个事务在获取插入行上独占的（排他）锁前，都会获取（4，7]之间的间隙锁，但是因为数据行之间并不冲突，所以两个事务之间并不会产生冲突（阻塞等待）。</li><li>插入意向锁是<strong>一种特殊的间隙锁</strong> ，两个插入意向锁之间互不排斥，所以即使多个事务在同一区间插入多条记录，只要记录本身（<strong>主键、唯一索引</strong>）不冲突，那么事务之间就不会出现冲突等待。也就是说插入意向锁在<strong>锁定区间相同但记录行本身不冲突</strong>的情况下互不排斥。</li><li>具体的说，当多个事务并发地进行插入操作时，如果它们的插入数据范围没有重叠，就可以避免插入意向锁的竞争，提高并发性能。但如果它们的插入数据范围有重叠，可能需要等待其他事务释放锁，以协调插入操作。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务1</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (id, name) <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="string">&#x27;John&#x27;</span>) LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务2</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (id, name) <span class="keyword">VALUES</span> (<span class="number">7</span>, <span class="string">&#x27;Jane&#x27;</span>) LOCK <span class="keyword">IN</span> SHARE MODE; <span class="comment">-- 不会被阻塞，因为是不同的索引区间</span></span><br></pre></td></tr></table></figure><h1>总结</h1><p>mysql锁分类：<br>按粒度：行级锁、表级锁、页级锁<br>按使用性质：共享锁、排他锁、意向锁<br>按主观：悲观锁、乐观锁<br>按加锁模式：记录锁、间隙锁、临键锁、意向锁、插入意向锁<br><strong>其中粒度，使用性质，主观都是逻辑上的分类</strong><br>行级锁有行锁（记录锁），间隙锁，临键锁<br>表级锁有表锁，意向锁，元数据锁（防止数据定义语句DDL数据操作语句DML起冲突）</p>]]></content>
    
    
    <summary type="html">mysql</summary>
    
    
    
    <category term="mysql" scheme="https://xlxq.fun/categories/mysql/"/>
    
    
    <category term="mysql" scheme="https://xlxq.fun/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>mysql原理</title>
    <link href="https://xlxq.fun/posts/6b129314.html"/>
    <id>https://xlxq.fun/posts/6b129314.html</id>
    <published>2023-08-13T10:19:03.000Z</published>
    <updated>2023-08-20T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>mysql重要组件</h1><ol><li><strong>MySQL Server（MySQL 服务器）：</strong><ul><li>MySQL Server 是 MySQL 数据库管理系统的核心组件，负责处理客户端的请求、执行 SQL 语句、管理数据库和表结构等核心功能。</li><li>MySQL Server 提供了多种存储引擎，如InnoDB、MyISAM等，用于实现不同的数据存储和管理方式。</li></ul></li><li><strong>Storage Engines（存储引擎）：</strong><ul><li>存储引擎是 MySQL 中负责数据存储和检索的模块。不同的存储引擎具有不同的特性，适用于不同的应用场景。</li><li>常见的存储引擎包括 InnoDB（支持事务、行级锁、外键等特性）、MyISAM（适用于读多写少的场景）、MEMORY（将表数据存储在内存中）、等等。</li></ul></li><li><strong>MySQL Clients（MySQL 客户端）：</strong><ul><li>MySQL 客户端是与 MySQL Server 进行通信的用户接口。它可以是命令行工具（如 mysql 命令行客户端）、图形用户界面工具（如 MySQL Workbench）或应用程序中的数据库连接库。</li><li>客户端通过 MySQL 协议与服务器通信，向服务器发送 SQL 语句并接收执行结果。</li></ul></li><li><strong>SQL Interface（SQL 接口）：</strong><ul><li>SQL 接口是连接 MySQL 客户端和服务器之间的桥梁。它定义了客户端如何与服务器进行通信，以及如何发送 SQL 语句和接收执行结果。</li><li>MySQL 使用标准的 SQL 语言作为与用户交互的接口，用户通过 SQL 语句进行数据库操作。</li></ul></li><li><strong>MySQL Connectors（MySQL 连接器）：</strong><ul><li>MySQL 连接器是用于不同编程语言的 API，允许应用程序与 MySQL 数据库进行连接和通信。常见的连接器包括 JDBC（Java 数据库连接）、ODBC（开放数据库连接）、PHP MySQLi（PHP 连接器）等。</li></ul></li></ol><p><strong>在mysql的各组件中，我们最关注的应该是服务器（也就是通常说的server层）以及存储引擎</strong></p><h2 id="mysql服务器">mysql服务器</h2><p>server层的重要组成部分如下：</p><ol><li><strong>解析器（Parser）：</strong><ul><li>解析器负责对 SQL 语句进行语法分析，将 SQL 语句解析为内部的数据结构，如解析树。这是 SQL 执行的第一步。</li></ul></li><li><strong>优化器（Optimizer）：</strong><ul><li>优化器负责选择最佳的执行计划，即确定如何执行查询以获得最佳性能。它考虑了索引的使用、连接顺序、Join 类型、过滤条件等因素。</li></ul></li><li><strong>执行计划生成器（Execution Plan Generator）：</strong><ul><li>执行计划生成器使用优化器的结果，生成一个具体的执行计划，包括执行每个步骤的顺序。生成的执行计划被存储在缓存中，以便在将来的执行中重用。</li></ul></li><li><strong>存储引擎接口（Storage Engine Interface）：</strong><ul><li>MySQL 支持多种存储引擎，如 InnoDB、MyISAM 等。存储引擎接口提供了与存储引擎进行交互的接口，包括读取、写入、锁定等操作。</li></ul></li><li><strong>缓存和缓存管理器（Cache and Cache Manager）：</strong><ul><li>MySQL 使用缓存来提高查询性能。缓存管理器负责管理查询结果的缓存，以及其他缓存，如索引缓存、表缓存等。</li></ul></li></ol><h2 id="存储引擎">存储引擎</h2><p>mysql的存储引擎有许多实现，最为常见的是innoDB和MyISAM</p><h3 id="MylSAM和-InnoDB的区别">MylSAM和 InnoDB的区别</h3><ol><li><strong>事务支持：</strong><ul><li><strong>MyISAM：</strong> MyISAM不支持事务。这意味着它不适用于需要事务支持的应用，如银行应用或在线购物网站。</li><li><strong>InnoDB：</strong> InnoDB支持事务。它提供了ACID（原子性、一致性、隔离性和持久性）属性，可以确保数据的完整性和一致性。</li></ul></li><li><strong>锁定级别：</strong><ul><li><strong>MyISAM：</strong> MyISAM使用表级锁定（Table-level Locking），这意味着在执行写操作时，整个表将被锁定，阻塞其他写操作。</li><li><strong>InnoDB：</strong> InnoDB使用行级锁定（Row-level Locking），这使得多个事务可以同时操作同一表的不同行，提高了并发性能。</li></ul></li><li><strong>外键支持：</strong><ul><li><strong>MyISAM：</strong> MyISAM不支持外键约束。它不会强制执行引用完整性，因此需要应用程序自行管理外键关系。</li><li><strong>InnoDB：</strong> InnoDB支持外键约束。它可以在数据库层面强制执行引用完整性，确保数据的一致性。</li></ul></li></ol><h3 id="InnoDB的四大特性（了解）">InnoDB的四大特性（了解）</h3><ol><li><strong>插入缓冲（Insert Buffer）：</strong><ul><li>插入缓冲是 InnoDB 存储引擎的一个特性，用于优化插入操作的性能。</li><li>当执行插入操作时，数据首先被写入到插入缓冲中，然后根据适当的时机（通常是在后台任务执行时）将数据合并到主要数据页中。</li><li>这减少了插入操作引起的磁盘 I/O 操作，提高了插入性能。</li></ul></li><li><strong>二次写（Double Write）：</strong><ul><li>二次写是一项用于提高数据完整性的安全措施。</li><li>当数据写入磁盘时，InnoDB 将数据首先写入到一个称为 doublewrite buffer 的地方，然后再写入到实际的数据文件。</li><li>如果在写入过程中发生崩溃，InnoDB 可以从 doublewrite buffer 中恢复数据，以避免数据损坏或丢失。</li></ul></li><li><strong>自适应哈希索引（Adaptive Hash Index，AHI）：</strong><ul><li>自适应哈希索引是 InnoDB 存储引擎中的一种优化技术，用于加速哈希索引的访问。</li><li>在某些情况下，InnoDB 使用哈希索引来提高查询性能。AHI 动态地调整哈希索引的大小和位置，以适应查询模式和工作负载的变化。</li><li>AHI 的目标是确保在高负载环境下，哈希索引仍然可以有效提高查询性能。</li></ul></li><li><strong>预读（Read Ahead）：</strong><ul><li>预读是 InnoDB 存储引擎的一项优化技术，用于减少磁盘 I/O 操作的开销。</li><li>当执行查询时，InnoDB 可以预读邻近的数据页，因为查询通常不仅仅涉及单个数据页。这样，在查询需要这些数据页时，它们已经在内存中，减少了磁盘访问的需求，提高了查询性能。</li></ul></li></ol><h1>InnoDB</h1><h2 id="逻辑存储结构">逻辑存储结构</h2><ol><li><strong>表空间（Tablespace）：</strong><ul><li>表空间是 InnoDB 存储引擎的最顶层结构，用于存储记录，索引等数据。每个数据库表都存储在一个或多个表空间中。</li></ul></li><li><strong>段（Segment）：</strong><ul><li>表空间内的逻辑存储结构被划分为段。每个段包含一个或多个区。InnoDB 使用段来<strong>组织数据</strong>。分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment） , InnoDB是索引组织表，数据段就是B+树的叶子节点，索引段即为B+树的非叶子节点。</li></ul></li><li><strong>区（Extent）：</strong><ul><li>区是 InnoDB 存储引擎中的一个单位，相当于若干个连续的页。每个区的大小默认为 1MB，因此一个区中有64个连续的页。区是<strong>分配和管理存储空间的基本单位</strong>。为了保证页的连续性，InnoDB每次从磁盘中申请4-5个区。</li></ul></li><li><strong>页（Page）：</strong><ul><li>页是 InnoDB 存储引擎的<strong>最小存储单位</strong>，通常为 16KB。所有的数据都存储在页中，包括表数据、索引、回滚段等。页是物理存储的基本单位，也是缓冲池中数据的基本单元。</li></ul></li><li><strong>行（Row）：</strong><ul><li>行是表中的最小数据单元，包含表中的一条记录。InnoDB 存储引擎支持行级别的锁和多版本并发控制（MVCC），使得多个事务可以同时对同一表进行读写操作而不会互相干扰。</li><li>每行还包含两个隐藏字段<strong>Trx_id（事务id）和Rol pointer（隐藏指针）</strong></li><li>Trx_id:每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。</li><li>Rol pointer: 每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul></li></ol><h2 id="内存架构">内存架构</h2><h3 id="缓冲池（Buffer-Pool）：">缓冲池（Buffer Pool）：</h3><ol><li>把磁盘读到的页放到一块内存区域里面,下一次读取相同的页,先判断是不是在这个内存区域里面,如果是,就直接读取,然后操作,不用再次从磁盘中加载。这体现了<strong>局部性原理</strong>和<strong>预加载机制</strong>。</li><li>当磁盘的一块数据被读取的时候,很有可能它附近的位置也会马上被读取到,这就是<strong>局部性原理</strong>。</li><li>每次读取的时候可以多读取一些数据,而不是用多少读多少，这就是<strong>预读取</strong>,体现为以页为最小单位加载数据。</li><li>缓冲池以页（同逻辑结构中的页）为单位，底层采用链表数据结构管理。 根据状态，将Page分为三种类型： <strong>free page</strong>:未被使用，<strong>clean page</strong>:被使用过但数据没有被修改过，<strong>dirty page</strong>:脏页，被使用过且数据被修改过，其数据与磁盘的数据产生了不一致。</li></ol><h3 id="更改缓冲区（Change-Buffer）">更改缓冲区（Change Buffer）</h3><ol><li><strong>针对于非唯一二级索引页</strong></li><li>在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区Change Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中</li><li>目的：与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了ChangeBuffer之后，我们可以在缓冲池中进行合并处理，<strong>减少磁盘IO</strong>。</li></ol><h3 id="自适应哈希（AHI）">自适应哈希（AHI）</h3><ol><li>用于优化对Buffer Pool数据的查询。InnoDB存储引擎会监控对表上各索引页的查询，如果观察到hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。</li><li>无需人工干预，是系统根据情况自动完成。开关参数（默认开）: adaptive_hash_index</li></ol><h3 id="日志缓冲区（Log-Buffer）">日志缓冲区（Log Buffer）</h3><ol><li>用来保存要写入到磁盘中的log日志数据（redolog、undolog），默认大小为16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以减少磁盘l/O。设置缓冲区大小：innodb_log_buffer_size</li><li>日志刷新到磁盘时机参数：innodb_flush_log_at_trx_commit<ul><li>0：每秒将日志写入并刷新到磁盘一次</li><li>1：日志在每次事务提交时写入并刷新到磁盘（保证数据能写到日志）</li><li>2：日志在每次事务提交后写入,并每秒刷新到磁盘一次</li></ul></li></ol><h2 id="磁盘结构">磁盘结构</h2><h3 id="表空间（Tablespace）">表空间（Tablespace）</h3><ol><li><strong>系统表空间（System Tablespace）</strong>：是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等) 参数:innodb_data_file_path</li><li><strong>用户表空间（File-Per-Table Tablespaces）</strong>：每个表的文件表空间，包含单个InnoDB表的数据和索引，并存储在文件系统上的单个数据文件中 参数:innodb_file_per_table</li><li><strong>通用表空间（General Tablespaces）</strong>：需要通过CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。</li></ol><h3 id="双写缓冲区（Doublewrite-Buffer-Files）">双写缓冲区（Doublewrite Buffer Files）</h3><p>innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。（显示为dblwr文件）</p><h3 id="重做日志（Redo-Log）">重做日志（Redo Log）</h3><ol><li>用来<strong>实现事务的持久性</strong></li><li>该日志文件由两部分组成:<ul><li>重做日志缓冲（redo log buffer），在内存中（前面提到的Log Buffer）</li><li>重做日志文件（redo log），在磁盘中。</li><li>当<strong>事务提交之后</strong>会把所有修改信息都会存到该日志中,用于在刷新脏页到磁盘时,发生错误时,进行数据恢复使用。</li></ul></li></ol><h3 id="回滚日志（Undo-Log）">回滚日志（Undo Log）</h3><ol><li>记录了事务发生之前的数据状态(不包括select).如果修改数据时出现异常,可以使用undo log来实现回滚操作(<strong>保持原子性</strong>)</li><li>在执行undo的时候,仅仅是将数据从逻辑上恢复至事务之前的状态,而不是从物理页面上操作实现的,属于逻辑格式的日志</li><li>undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment 回滚段中，内部包含1024个undo log segment</li><li>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除；而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</li></ol><h2 id="MVCC">MVCC</h2><p>全称Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本<br>使得读写操作没有冲突，快照读是MySQL实现MVCC的一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p><h3 id="快照读和当前读">快照读和当前读</h3><ol><li><strong>当前读</strong>：<ul><li>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。以下是一些当前读操作，如:</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ...lock <span class="keyword">in</span> share mode(共享锁)</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span>、<span class="keyword">update</span>、<span class="keyword">insert</span>、<span class="keyword">delete</span>(排他锁)</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>快照读</strong>：<ul><li>简单的select (不加锁)就是快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</li><li>Read Committed:每次select，都生成一个快照读。</li><li>Repeatable Read:开启事务后第一个select语句才是快照读的地方。</li><li>Serializable:快照读会退化为当前读。</li></ul></li></ol><h3 id="实现原理">实现原理</h3><h4 id="隐藏字段">隐藏字段</h4><p>每条记录（行）中有三个隐藏字段：</p><ul><li>DB_TRX_ID：最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。</li><li>DB_ROLL_PTR：回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本。</li><li>DB_ROw_ID：隐藏主键,如果表结构没有指定主键，将会生成该隐藏字段。</li></ul><h4 id="undolog版本链">undolog版本链</h4><ol><li>不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</li><li>每个链表的节点都是一条行记录的一个版本，只是隐藏字段不同</li></ol><h4 id="readview读视图">readview读视图</h4><ol><li>是<strong>快照读</strong>SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的） id。不同的隔离级别，生成ReadView的时机不同:<ul><li>READ COMMITTED∶在事务中每一次执行快照读时生成ReadView</li><li>REPEATABLE READ:仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView</li></ul></li><li>ReadView中包含了四个核心字段:<ul><li>m_ids：当前活跃的事务ID集合（当前还未提交的事务ID集合）</li><li>min_trx_id：最小活跃事务ID（最小还未提交事务id）</li><li>max_trx_id：预分配事务ID,当前最大事务ID+1（因为事务ID是自增的）</li><li>creator_trx_id：ReadView创建者的事务ID</li></ul></li><li>版本链访问规则（trx_id是当前事务ID）：<ul><li>trx_id == creator_trx_id ?可以访问该版本（说明数据是当前这个事务更改的）</li><li>trx_id &lt; min_trx_id ?可以访问该版本（说明数据已经提交了）</li><li>trx_id &gt; max_trx_id ?不可以访问该版本（说明该事务是在readview生成后才开启）</li><li>min_trx_id &lt;= trx_id &lt;= max_trx_id ?如果trx_id不在m_ids中是可以访问该版本的（说明数据已经提交）</li></ul></li></ol><h1>SQL执行流程</h1><h2 id="server中">server中</h2><p>查询缓存-&gt;解析-&gt;预处理-&gt;优化器-&gt;执行器-&gt;执行引擎<br><img src="/post-img/Pasted image 20240216204730.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="执行引擎（InnoDB）">执行引擎（InnoDB）</h2><ol><li>写undo log，存储回滚指针和事务ID</li><li>若当前操作记录在内存中，找到数据并更新，否则先从磁盘数据页中加载数据</li><li>写redo log，WAL（write-ahead log），将刷盘从随机读写变为顺序读写，提高性能</li><li>写bin log，备份/主从同步</li><li>事务提交<br><img src="/post-img/Pasted image 20240216205106.png" alt="图片损坏" style="zoom:100%;" /></li></ol>]]></content>
    
    
    <summary type="html">mysql</summary>
    
    
    
    <category term="mysql" scheme="https://xlxq.fun/categories/mysql/"/>
    
    
    <category term="mysql" scheme="https://xlxq.fun/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>synchronized详解</title>
    <link href="https://xlxq.fun/posts/f0baa025.html"/>
    <id>https://xlxq.fun/posts/f0baa025.html</id>
    <published>2023-08-12T12:18:02.000Z</published>
    <updated>2023-08-12T12:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1>并发编程中的三大问题</h1><ol><li><strong>原子性问题（Atomicity）：</strong><ul><li><strong>定义：</strong> 保证一个操作是不可中断的，要么全部执行成功，要么全部不执行。</li><li><strong>问题：</strong> 当多个线程同时执行一组操作时，可能出现一部分操作已经执行而另一部分没有执行的情况，导致数据不一致性。</li></ul></li><li><strong>可见性问题（Visibility）：</strong><ul><li><strong>定义：</strong> 一个线程对共享变量的修改能够及时被其他线程看到。</li><li><strong>问题：</strong> 当一个线程修改了共享变量的值，其他线程可能无法立即感知到这个变化，从而导致数据的不一致性。</li></ul></li><li><strong>有序性问题（Ordering）：</strong><ul><li><strong>定义：</strong> 确保程序执行的顺序与代码的书写顺序一致。</li><li><strong>问题：</strong> 由于编译器的优化或硬件的乱序执行，代码的执行顺序可能与预期不一致，导致意外的结果。</li></ul></li></ol><h1>JMM（Java Memory Modle）</h1><p>Java内存模型，是Java虚拟机规范中所定义的一种内存模型，Java内存模型是标准化的，屏蔽掉了底层不同计算机的区别。它是一套规范，描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节。Java内存模型是一套在多线程读写共享数据时，对共享数据的可见性、有序性、和原子性的规则和保障。</p><ol><li>主内存：是所有线程都共享的，都能访问的。所有的共享变量都存储于主内存。</li><li>工作内存：每一个线程有自己的工作内存，工作内存只存储该线程对共享变量的<strong>副本</strong>。线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接访问对方工作内存中的变量。</li><li>JMM是一种抽象的逻辑概念，Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉</li></ol><h2 id="JMM中主内存与工作内存之间的数据交互过程">JMM中主内存与工作内存之间的数据交互过程</h2><p>Java内存模型中定义了以下8种操作来完成，主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的。<br>分别是lock、read、load、use、assign、store、write、unlock<br>1.如果对一个变量执行lock操作，将会清空工作内存中此变量的值<br>2.对一个变量执行unlock操作之前，必须先把此变量同步到主内存中</p><h1>synchronized与三大特性</h1><p>synchronized可以保证原子性、有序性、可见性，其中有序性和可见性是通过JMM规范的八个命令中的lock和unlock命令保证的</p><ol><li><strong>原子性（Atomicity）：</strong><ul><li><code>synchronized</code> 保证了代码块或方法中的所有操作要么全部执行成功，要么全部失败，不会被其他线程中断。当一个线程获得锁时，它将独占锁，其他线程必须等待释放锁后才能继续执行。</li></ul></li><li><strong>可见性（Visibility）：</strong><ul><li>当一个线程获得锁进入 <code>synchronized</code> 代码块时，它会清空工作内存中的共享变量副本，强制从主内存中重新读取共享变量的值。同样，线程在释放锁的时候会将修改后的值刷新回主内存，这样其他线程能够感知到这些变化。这确保了对共享变量的修改对其他线程可见。</li></ul></li><li><strong>有序性（Ordering）：</strong><ul><li>as-if-serial：不管编译器和CPU如何重排序，必须保证在单线程情况下程序的结果是正确的。也就是逻辑上有先后关系的代码不会被重排序，例如a=1,b=2,c=a+b可能被重排序为b=2,a=1,c=a+b，但不可能被重排序为a=1,c=a+b,b=2</li><li><code>synchronized</code> 保证了线程进入和退出临界区的有序性。即，一个线程在释放锁之前，必须把修改过的变量刷新到主内存，而获取锁的线程要求从主内存中读取变量的最新值。这就确保了线程之间的有序性，防止了乱序执行。</li></ul></li></ol><h1>特性</h1><h2 id="可重入锁">可重入锁</h2><p>一个线程在持有锁的情况下，可以再次获取相同的锁，而不会造成死锁。这是通过<strong>为每个锁关联一个持有者线程和一个计数器</strong>来实现的。当一个线程第一次获取锁时，计数器为1，每次递归获取锁，计数器递增。只有当计数器降为零时，锁才会被释放。这确保了线程可以多次进入同一个 <code>synchronized</code> 代码块，而不会发生死锁。可重入锁是一种提高程序灵活性和避免死锁的设计。</p><h2 id="不可中断">不可中断</h2><p>不可中断：一个线程获得锁后，另一个线程想要获得锁，必须处于阻塞或等待状态，如果第一个线程不释放锁，第二个线程会一直阻塞或等待，不可被中断。</p><h1>原理</h1><h2 id="monitorenter">monitorenter</h2><ol><li>每一个对象都会和一个<strong>监视器</strong>monitor关联。监视器被占用时会被锁住，其他线程无法来获取该monitor。当JVM执行某个线程的某个方法内部的monitorenter时，它会尝试去获取当前对象对应的monitor的所有权。其过程如下︰</li><li>获取当前对象对应的monitor的所有权的过程：<ul><li>若monior的进入数为0，线程可以进入monitor，并将monitor的进入数置为1。当前线程成为monitor的owner (所有者）</li><li>若线程已拥有monitor的所有权，允许它重入monitor，则进入monitor的进入数加1</li><li>若其他线程已经占有monitor的所有权，那么当前尝试获取monitor的所有权的线程会被阻塞，直到monitor的进入数变为0，才能重新尝试获取monitor的所有权。</li></ul></li><li>synchronized的锁对象会关联一个monitor,这个monitor不是我们主动创建的,是JVM的线程执行到这个同步代码块,发现锁对象没有monitor就会创建monitor,monitor内部有两个重要的成员变量：<ul><li>owner:拥有这把锁的线程</li><li>recursions会记录线程拥有锁的次数,当一个线程拥有monitor后其他线程只能等待</li></ul></li></ol><h2 id="monitorexit">monitorexit</h2><ol><li>能执行monitorexit指令的线程一定是拥有当前对象的monitor的所有权（owner）的线程。</li><li>执行monitorexit时会将monitor的进入数减1。当monitor的进入数减为0时，当前线程退出monitor，不再拥有monitor的所有权，此时其他被这个monitor阻塞的线程可以尝试去获取这个monitor的所有权monitorexit释放锁。</li><li>monitorexit插入在方法结束处和异常处，JVM保证每个monitorenter必须有对应的monitorexit，因此<strong>synchornized出现异常时会释放锁</strong></li></ol><h2 id="对象头的结构">对象头的结构</h2><p>在 HotSpot JVM 中，对象头包括两部分信息，分别是 Mark Word 和 Klass Pointer</p><ol><li>Mark Word用于存储对象自身的运行时数据，如哈希码(HashCode ) 、GC分代年龄、锁状态标志线程持有的锁、偏向线程ID、偏向时间戳等等，占用内存大小与虚拟机位长一致。</li><li>Klass Pointer用于存储对象的类型指针，该指针指向它的类元数据，JVM通过这个指针确定对象是哪个类的实例。该指针的位长度为JVM的一个字大小，即32位的JVM为32位，64位的JVM为64位。</li></ol><h1>锁升级</h1><ol><li><strong>偏向锁（Biased Locking）：</strong><ul><li>初始时，一个对象的头部信息会包含偏向锁标记。当某个线程访问这个对象并获取锁时，会将该线程的ID记录在对象头中，并将偏向锁标记置为1。之后，如果同一个线程再次访问该对象，无需竞争，直接获取锁。这提高了同一线程多次获取锁的效率。</li></ul></li><li><strong>轻量级锁（Lightweight Locking）：</strong><ul><li>当有多个线程竞争同一把锁时，偏向锁就不再合适。此时，锁会升级为轻量级锁。在轻量级锁的情况下，当前获取到锁的线程将对象的Mark Word复制到栈帧中的Lock Recod中，Mark Word更新为指向Lock Record的指针。其他线程在尝试获取锁时会将对象头的 Mark Word 复制到线程的栈帧中，并进行自旋操作，而不是直接阻塞线程。如果自旋失败（10次以上仍未获取），锁升级为重量级锁。</li></ul></li><li><strong>重量级锁（Heavyweight Locking）：</strong><ul><li>当轻量级锁自旋失败，多个线程竞争同一把锁的时候，锁会升级为重量级锁。在这种情况下，JVM 使用操作系统提供的互斥量来实现锁。此时，如果一个线程获取了锁，其他线程必须阻塞等待。重量级锁是通过对象头关联的monitor（见补充）实现的。</li></ul></li></ol><h1>优化</h1><ol><li>锁消除：在synchronized修饰的代码中，如果不存在操作临界资源的情况，编译时JIT触发锁消除，相当于无锁</li><li>锁膨胀：如果在一个循环中，频繁的获取和释放做资源，这样带来的消耗很大，锁膨胀就是将锁的范围扩大，避免频繁的竞争和获取锁资源带来不必要的消耗</li><li>锁升级：synchronized在JDK1.6之前，获取不到锁，立即挂起当前线程，所synchronized性能比较差，之后做了锁升级的优化，即无锁—&gt;偏向锁—&gt;轻量级锁—&gt;重量级锁；有的观点认为锁只能升级，不能降级，也有说锁降级确实是会发生的，当 JVM 进入安全点（SafePoint）的时候，会检查是否有闲置的 Monitor，然后试图进行降级。</li></ol><h1>补充</h1><h2 id="java中对象的结构">java中对象的结构</h2><p>java对象由三部分组成：对象头，实例数据，对齐填充</p><ol><li>对象头：由 Mark Word 和 Klass Pointer组成</li><li>实例数据：就是类中定义的成员变量</li><li>对齐填充：并不是必然存在的，也没有什么特别的意义，他仅仅起着占位符的作用，由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头正好是8字节的倍数，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</li></ol><h2 id="monitor">monitor</h2><ol><li>每一个Java对象都<code>可以</code>与一个监视器monitor关联，我们可以把它理解成为一把锁，当一个线程想要执行一段被synchronized圈起来的同步方法或者代码块时，该线程得先获取到synchronized修饰的对象对应的monitor。</li><li>monitor并不是随着对象创建而创建的。我们是通过synchronized修饰符告诉VM需要为我们的某个对象创建关联的monitor对象。</li><li>monitor的重要成员变量<ul><li>_owner:初始时为NULL。当有线程占有该monitor时，owner标记为该线程的唯一标识。当线程释放monitor时，owner又恢复为NULL。owner是一个临界资源，JVM是通过CAS操作来保证其线程安全的。</li><li>_CXq∶竞争队列，所有请求锁的线程首先会被放在这个队列中（单向链接）。_cxq是一个临界资源，JVM通过CAS原子指令来修改_cxq队列。修改前_cxq的旧值填入了node的next字段，_cxq指向新值（新线程)。因此_cxq是一个后进先出的stack(栈)。</li><li>_EntryList : _cxq队列中有资格成为候选资源的线程会被移动到该队列中。</li><li>_WaitSet :因为调用wait方法而被阻塞的线程会被放在该队列中。</li></ul></li><li>monitor是重量级锁：<ul><li>ObjectMonitor（hotspot的monitor实现）的函数调用中会涉及到Atomic::cmpxchg_ptr，Atomic:.inc_ptr等内核函数，执行同步代码块，没有竞争到锁的对象会park()被挂起，竞争到锁的线程会unpark()唤醒。这个过程中存在操作系统用户态和内核态的转换，这种切换会消耗大量的系统资源。所以synchronized在Java语言中是一个重量级(Heavyweight)的操作。</li></ul></li></ol><h2 id="安全点（safe-point）">安全点（safe point）</h2><p>安全点是程序执行的一个状态，JVM 在这个状态下，能够确保所有线程都在安全位置，不会出现对对象引用的修改。在安全点上，JVM 可以停止所有线程，进行垃圾回收、线程栈的修改等操作，而不会导致数据不一致或错误的状态。在安全点上，线程不会在执行关键的、可能导致数据不一致的代码。<br>安全点通常发生在一些特定的位置，包括：</p><ol><li><strong>方法调用：</strong><ul><li>在方法调用的地方，JVM 可以方便地确保所有线程都在一个安全的状态。这可以是方法的入口或返回点。</li></ul></li><li><strong>循环跳跃：</strong><ul><li>在循环的迭代点，例如 for 循环的迭代点，也是安全点。这是因为在循环迭代点，线程通常都在相对较安全的位置。</li></ul></li><li><strong>异常抛出：</strong><ul><li>在抛出异常的地方，例如在 <code>throw</code> 语句附近，也是一个潜在的安全点。</li></ul></li><li><strong>代码生成器插入的安全点：</strong><ul><li>代码生成器在生成机器码时，会在适当的位置插入安全点，以确保在执行这些机器码时，所有线程都在一个安全的状态。。在某些情况下，为了减少安全点的频率，JVM 可能会选择较少的插入安全点，从而提高程序的运行效率。</li></ul></li></ol><h2 id="synchronized与Lock的区别">synchronized与Lock的区别</h2><ol><li>synchronized是关键字，而Lock是一个接口。</li><li>synchronized会自动释放锁，而Lock必须手动释放锁。</li><li>synchronized是不可中断的，Lock可以中断也可以不中断。</li><li>通过Lock可以知道线程有没有拿到锁，而synchronized不能。</li><li>synchronized能锁住方法和代码块，而Lock只能锁住代码块。</li><li>Lock可以使用读锁提高多线程读效率。</li><li>synchronized是非公平锁，ReentrantLock可以控制是否是公平锁。</li></ol><h1>总结</h1><ol><li>synchornized是可重入锁，不可中断锁</li><li>可以保证原子性，有序性和可见性（JMM中定义的8种原子操作）</li><li>原理是java对象头（偏向锁、轻量级锁）以及monitor（重量级锁）</li><li>jdk6后提供了锁优化：锁消除、锁膨胀、锁升级</li></ol>]]></content>
    
    
    <summary type="html">java基础知识</summary>
    
    
    
    <category term="java" scheme="https://xlxq.fun/categories/java/"/>
    
    
    <category term="java,锁" scheme="https://xlxq.fun/tags/java-%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>函数式接口与lambda表达式</title>
    <link href="https://xlxq.fun/posts/b427a511.html"/>
    <id>https://xlxq.fun/posts/b427a511.html</id>
    <published>2023-08-12T12:18:02.000Z</published>
    <updated>2023-08-12T12:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1>函数式接口</h1><ol><li>函数式接口是指只包含一个抽象方法的接口。Java中引入了函数式接口的概念，主要是为了支持Lambda表达式的使用。Lambda表达式是一种轻量级的匿名函数，可以直接传递给函数式接口的对象。函数式接口的定义要求使用<code>@FunctionalInterface</code>注解，该注解用于强制检查接口是否符合函数式接口的标准。</li><li>以下是函数式接口的特征：<ul><li>接口中只能有一个抽象方法（可以包含默认方法和静态方法）。</li><li><code>@FunctionalInterface</code> 注解用于标识该接口是函数式接口（可选）。</li></ul></li></ol><h1>函数式接口的实现方式</h1><ol><li><strong>使用匿名内部类：</strong> 使用匿名内部类是最传统的方式，它允许直接实现接口的抽象方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyFunctionalInterface</span> <span class="variable">myFunction</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyFunctionalInterface</span>() &#123;     </span><br><span class="line"><span class="meta">@Override</span>     </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> &#123;         </span><br><span class="line">System.out.println(<span class="string">&quot;Implementation using anonymous inner class&quot;</span>);     </span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>使用Lambda表达式：</strong> Lambda表达式是一种更简洁的方式，特别适用于函数式接口。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyFunctionalInterface</span> <span class="variable">myFunction</span> <span class="operator">=</span> </span><br><span class="line">() -&gt; System.out.println(<span class="string">&quot;Implementation using Lambda expression&quot;</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>使用方法引用：</strong> 如果接口的抽象方法与现有方法的签名兼容，可以使用方法引用。方法引用提供了一种更简洁的语法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在这里，`myObject::myMethod` 是对 `MyFunctionalInterface` 中的抽象方法的实现。</span></span><br><span class="line">  <span class="type">MyClass</span> <span class="variable">myObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>(); </span><br><span class="line">  <span class="type">MyFunctionalInterface</span> <span class="variable">myFunction</span> <span class="operator">=</span> myObject::myMethod;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>使用构造方法引用：</strong> 如果函数式接口代表的是一个构造函数，可以使用构造方法引用。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里假设 `MyClass` 是一个函数式接口 `MyFunctionalInterface` 的实现类。</span></span><br><span class="line"> <span class="type">MyFunctionalInterface</span> <span class="variable">myFunction</span> <span class="operator">=</span> MyClass::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure><h1>lambda表达式</h1><p>Lambda表达式是Java中引入的一种轻量级的函数式编程特性，它允许你将一个函数（或称为代码块）作为一个参数传递给方法，或者更简洁地实现函数式接口。</p><p>Lambda表达式的基本语法如下：</p><ul><li><code>(parameters) -&gt; expression</code></li><li><code>(parameters) -&gt; &#123; statements; &#125;</code><br>其中，<code>parameters</code> 是Lambda表达式的参数列表，<code>expression</code> 或 <code>&#123; statements; &#125;</code> 是Lambda表达式的主体。</li></ul><p>以下是一些示例，演示了Lambda表达式的不同用法：</p><ol><li><strong>不带参数的Lambda表达式：</strong><br><code>Runnable runnable = () -&gt; System.out.println(&quot;Hello, Lambda!&quot;);</code><br><code>new Thread(runnable).start();</code></li><li><strong>带参数的Lambda表达式：</strong><br><code>(x, y) -&gt; x + y</code><br>这表示一个接受两个参数 <code>x</code> 和 <code>y</code>，并返回它们的和。</li><li><strong>带主体的Lambda表达式：</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主体可以包含多条语句，并且可以有返回值。</span></span><br><span class="line">(x, y) -&gt; &#123;     </span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> x + y;     </span><br><span class="line">System.out.println(<span class="string">&quot;Sum: &quot;</span> + sum);     </span><br><span class="line"><span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>遍历集合的Lambda表达式：</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里使用了 `forEach` 方法和Lambda表达式，简化了集合的遍历操作。</span></span><br><span class="line">    List&lt;String&gt; languages = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>); </span><br><span class="line">    languages.forEach(language -&gt; System.out.println(language));`</span><br></pre></td></tr></table></figure><p>Lambda表达式的引入使得代码更加简洁、易读，并支持更函数式的编程风格。在使用Lambda表达式时，通常用于实现函数式接口（只有一个抽象方法的接口）的匿名实现。</p>]]></content>
    
    
    <summary type="html">java基础知识</summary>
    
    
    
    <category term="java" scheme="https://xlxq.fun/categories/java/"/>
    
    
    <category term="java" scheme="https://xlxq.fun/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>反射</title>
    <link href="https://xlxq.fun/posts/7af799fd.html"/>
    <id>https://xlxq.fun/posts/7af799fd.html</id>
    <published>2023-08-12T12:18:02.000Z</published>
    <updated>2023-08-12T12:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>反射允许对成员变量，成员方法和构造方法的信息进行编程访问<br>它从字节码文件中获取这些信息，因此使用反射必须先获取class对象<br><img src="/post-img/Pasted image 20230719121447.png" alt="图片损坏" style="zoom:100%;" /></p><h1>获取class对象的三种方式</h1><p>1.Class.forName（”全类名“）<br>使用于源代码阶段，全类名即包名+类名（选中类名右键copy）<br>2.类名.class<br>适用于加载阶段，一般用于当作参数传递<br>3.对象.getClass（）<br>适用于运行阶段，已经创建对象后<br>注意字节码文件是唯一的，因此上述三种方法获取的是同一个对象</p><h1>利用反射获取构造方法</h1><img src="/post-img/Pasted image 20230719122046.png" alt="图片损坏" style="zoom:100%;" />获取到构造方法后，可以通过方法获取构造方法的信息，如权限修饰符，参数类型等getModifiers（）获取权限修饰符，返回整数（2的次方数）表示修饰符类型getParameterCount（）获取参数数量getParameterTypes（）获取参数类型getParameter（）获取所有参数newInstance（）构造新的对象setAccessible（true）临时取消权限校验<h1>利用反射获取成员变量</h1><img src="/post-img/Pasted image 20230719122800.png" alt="图片损坏" style="zoom:100%;" />获取到成员变量后，可以通过方法获取成员变量的信息，如权限修饰符，名字等getModifiers（）获取权限修饰符，返回整数（2的次方数）表示修饰符类型getName（）获取名字getType（）获取数据类型get（对象）获取成员变量记录的值setAccessible（true）临时取消权限校验set（）修改对象里面记录的值<h1>利用反射获取成员方法</h1><img src="/post-img/Pasted image 20230719123234.png" alt="图片损坏" style="zoom:100%;" />获取到成员方法后，可以通过方法获取成员方法的信息，如权限修饰符，名字等getModiifiers（）获取权限修饰符，返回整数（2的次方数）表示修饰符类型getName（）获取名字getParameters（）获取形参getExceptionTypes（）获取方法的抛出异常//方法运行Method类中用于创建对象的方法Object invoke(Object obj, object. . . args):运行方法参数一:用obj对象调用该方法（方法的调用者对象）参数二:调用方法的传递的参数（如果没有就不写）返回值:方法的返回值（如果没有就不写）<h1>反射的作用</h1><p>1.获取一个类里面所有的信息，获取到了后执行其他业务逻辑<br>2.结合配置文件，动态创建对象并调用方法（只需要修改配置文件就可以不需要更改代码在别的类中实现相同的作用）</p><h1>总结</h1><img src="/post-img/Pasted image 20230719124007.png" alt="图片损坏" style="zoom:100%;" />]]></content>
    
    
    <summary type="html">java基础知识</summary>
    
    
    
    <category term="java" scheme="https://xlxq.fun/categories/java/"/>
    
    
    <category term="java" scheme="https://xlxq.fun/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>常用API</title>
    <link href="https://xlxq.fun/posts/e3dac448.html"/>
    <id>https://xlxq.fun/posts/e3dac448.html</id>
    <published>2023-08-12T12:18:02.000Z</published>
    <updated>2023-08-12T12:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1>MATH</h1><img src="/post-img/Pasted image 20230719171712.png" alt="图片损坏" style="zoom:100%;" /><h1>System</h1><img src="/post-img/Pasted image 20230719171743.png" alt="图片损坏" style="zoom:100%;" /><h1>Runtime</h1><img src="/post-img/Pasted image 20230719171840.png" alt="图片损坏" style="zoom:100%;" /><h1>Object和Objects</h1><h2 id="Object">Object</h2><p>1.Object是java中的顶级父类，所有的类都直接或间接的继承于Object类<br>2.Object类中的方法可以被所有子类访问<br>3.Objet类中没有成员变量，因此只有一个空参构造方法</p><h3 id="成员方法">成员方法</h3><img src="/post-img/Pasted image 20230719172210.png" alt="图片损坏" style="zoom:100%;" />**1.toString（）**当我们打印一个对象的时候。底层会调用对象的toString方法。把对象变成字符串。然后再打印在控制台上,打印完毕换行处理。默认情况下,因为Object类中的toString方法返回的是地址值，所以默认情况下打印一个对象打印的就是地址值，但是地址值对于我们是没什么意义的，如果要看到对象内部的属性值，应该重写Object类中的toString方法**2.equals（）**如果没有重写equals方法，那么默认使用Object中的方法进行比较，比较的是地址值是否相等。一般来讲地址值对于我们意义不大，所以我们会重写，重写之后比较的就是对象内部的属性值了。**3.clone（）**方法在底层会帮我们创建一个对象，并把原对象中的数据拷贝过去。书写细节:1.重写Object中的clone方法2.让javabean类实现Cloneable接口3.创建原对象并调用clone深克隆和浅克隆：浅克隆：不管对象内部的属性是基本数据类型还是引用数据类型，都完全拷贝过来（引用拷贝地址值），是Object中的默认方式深克隆：基本数据类型拷贝过来，字符串复用，引用数据类型重新创建新的空间拷贝数据后返回新地址值，需要重写clone方法<h1>BigInteger</h1><h2 id="构造方法">构造方法</h2><p>对象一旦被创建数据不能被修改<br><img src="/post-img/Pasted image 20230719173753.png" alt="图片损坏" style="zoom:100%;" /><br>1.获取指定的大整数细节:字符串中的数字必须是整数<br>2.获取指定进制的大整数细节:<br>字符串中的数字必须是整数；<br>字符串中的数字必须要跟进制吻合。<br>比如二进制中，那么只能写0和1，写其他的就报错。<br>3.public static BigInteger valueOf(1ong val)<br>静态方法获取BigInteger的对象，内部有优化<br>细节:<br>1.能表示范围比较小，只能在long的取值范围之内，如果超出long的范围就不行了<br>2.在内部对常用的数字:-16 ~ 16进行了优化。<br>提前把-16 ~ 16 先创建好BigInteger的对象，如果多次获取不会重新创建新的。<br><img src="/post-img/Pasted image 20230719174258.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="成员方法-2">成员方法</h2><img src="/post-img/Pasted image 20230719174324.png" alt="图片损坏" style="zoom:100%;" /><h2 id="底层存储方式">底层存储方式</h2><p>通过数组分段，分别表示符号，基数和次幂<br>最大可以是42亿的21亿次方</p><h1>BigDecimal</h1><h2 id="创建方法">创建方法</h2><p>表示较大的小数和解决小数运算精度失真的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过传递double类型的小数来创建对象，可能是不精确的，不建议使用</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecima</span>(<span class="number">0.01</span>);</span><br><span class="line"><span class="comment">//通过传递字符串表示的小数来创建对象</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecima</span>(<span class="string">&quot;0.01&quot;</span>);</span><br><span class="line"><span class="comment">//通过静态方法创建对象</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">bd</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//如果要表示的数字不大，没有超出double的取值范围，建议使用静态方法</span></span><br><span class="line"><span class="comment">//如果要表示的数字超出了double的取值范围，建议使用构造方法</span></span><br><span class="line"><span class="comment">//如果传递的是0~10之间的整数，包含0和10，方法会返回已经创建好的对象，不会重新创建；但是如果传递的是小数，则是直接创建新的对象</span></span><br></pre></td></tr></table></figure><h2 id="成员方法-3">成员方法</h2><img src="/post-img/Pasted image 20230720164842.png" alt="图片损坏" style="zoom:100%;" />## 底层存储方式遍历字符串，得到每一个数字和小数点代表的ASKII码，存入一个数组中# 正则表达式1.检验字符串是否满足规则2.在一段文本中查找满足要求的内容<img src="/post-img/Pasted image 20230720165324.png" alt="图片损坏" style="zoom:100%;" /><img src="/post-img/Pasted image 20230720165726.png" alt="图片损坏" style="zoom:100%;" />注意：1.如果要求两个范围的交集，要写”&&“，如果只写一个，表示的仅仅是”&“这个符号2."\\"是转义字符<img src="/post-img/Pasted image 20230720165836.png" alt="图片损坏" style="zoom:100%;" /><img src="/post-img/Pasted image 20230720165901.png" alt="图片损坏" style="zoom:100%;" /><h2 id="爬虫">爬虫</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span>获取正则表达式的对象</span><br><span class="line">Pattern p = Pattern.compile<span class="params">(&quot;Java\\d&#123;0,2&#125;)</span>;</span><br><span class="line"><span class="string">//</span>获取文本匹配器的对象</span><br><span class="line"><span class="string">//m</span>:文木匹配器的对象</span><br><span class="line"><span class="string">//str</span>:大串</span><br><span class="line"><span class="string">//p</span>:规则</span><br><span class="line"><span class="string">//m</span>要在str中找符合p规则的小串</span><br><span class="line">Matcher m = p.matcher<span class="params">(str)</span>;</span><br><span class="line"><span class="string">//</span>拿着文本匹配器从头开始读取，寻找是否有满足规则的子串</span><br><span class="line"><span class="string">//</span>如果没有，方法返回<span class="literal">false</span></span><br><span class="line"><span class="string">//</span>如果有，返回<span class="literal">true</span>。在底层记录子串的起始索引和结束索引+1</span><br><span class="line">boolean b = m.find<span class="params">()</span>;</span><br></pre></td></tr></table></figure><h2 id="正则表达式在字符串方法中的使用">正则表达式在字符串方法中的使用</h2><img src="/post-img/Pasted image 20230720170913.png" alt="图片损坏" style="zoom:100%;" />贪婪爬取和非贪婪爬取"ab+"和"ab+?"<h2 id="分组">分组</h2><p>可以复用前面已经有的正则表达式<br>1.每组是有组号的，也就是序号。从1开始，连续不间断。<br>2.以左括号为基准，最左边的是第一组，其次为第二组，以此类推。<br>3.\\组号： 表示把第x组的内容再用一次<br><img src="/post-img/Pasted image 20230720171347.png" alt="图片损坏" style="zoom:100%;" /></p><h1>时间</h1><h2 id="Date">Date</h2><p>Date类是一个JDK写好的Javabean类，用来描述时间，精确到毫秒。利用空参构造创建的对象，默认表示系统当前时间。<br>利用有参构造创建的对象，表示指定的时间。<br><img src="/post-img/Pasted image 20230720171641.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="SimpleDateFormat">SimpleDateFormat</h2><img src="/post-img/Pasted image 20230720171817.png" alt="图片损坏" style="zoom:100%;" /><h2 id="Calender">Calender</h2><img src="/post-img/Pasted image 20230720172005.png" alt="图片损坏" style="zoom:100%;" /><img src="/post-img/Pasted image 20230720172023.png" alt="图片损坏" style="zoom:100%;" /><h1>包装类</h1><p>为了将基本数据类型转化为对象，提出了包装类的概念，其本质是在堆内存中开辟了一块空间，用来存储基本数据类型的值，而把这块空间的地址值传递给包装类对象，这样做可以使所有的数据类型都可以视为对象，是object的子类，排除了代码的局限性，此外，集合的泛型中也需要传递包装类</p><h2 id="获取包装类对象的方法（以Integer为例）">获取包装类对象的方法（以Integer为例）</h2><img src="/post-img/Pasted image 20230720172756.png" alt="图片损坏" style="zoom:100%;" />细节：1.-128~127间的数据，用的比较多，因此java底层已经创建好了这些数据的对象，如果用到了会直接返回对象的地址值，因此在这个范围内获取两个值相同的数据时，实际上获取的是同一个对象，这样做的目的是不浪费太多内存2.JDK5后对包装类新增了自动装箱和自动拆箱的操作<h2 id="Integer成员方法">Integer成员方法</h2><img src="/post-img/Pasted image 20230720173222.png" alt="图片损坏" style="zoom:100%;" />]]></content>
    
    
    <summary type="html">java基础知识</summary>
    
    
    
    <category term="java" scheme="https://xlxq.fun/categories/java/"/>
    
    
    <category term="java" scheme="https://xlxq.fun/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>集合</title>
    <link href="https://xlxq.fun/posts/d366874c.html"/>
    <id>https://xlxq.fun/posts/d366874c.html</id>
    <published>2023-08-11T11:18:02.000Z</published>
    <updated>2023-08-11T11:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1>单列集合</h1><img src="/post-img/Pasted image 20230710135523.png" alt="图片损坏" style="zoom:100%;" /><h2 id="单列集合的特点">单列集合的特点</h2><p><strong>List集合系列元素：有序，可重复，有索引<br>Set集合系列元素：无序，不重复，无索引</strong></p><h2 id="集合和数组的对比">集合和数组的对比</h2><p>数组长度固定，既可以存基本数据类型，又可以存引用数据类型<br>集合长度可变，可以存引用数据类型，基本数据类型需要转为其包装类</p><h2 id="泛型">泛型</h2><h3 id="不指定泛型">不指定泛型</h3><p>如果在创建集合的时候不指定泛型，默认认为所有的数据都是object类型，这意味着可以往该集合中添加任意类型的数据，但是这使得在获取数据的时候，无法使用该数据类型的特有方法（多态的弊端）</p><h3 id="作用">作用</h3><p>1.统一数据类型<br>2.把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为在编译期间类型就能确定</p><h3 id="细节">细节</h3><p>1.泛型中不能写基本数据类型<br>2.指定泛型的基本类型后，传递数据时，可以传入该类类型或其子类类型<br>3.不写泛型，类型默认是Object</p><h3 id="使用位置">使用位置</h3><h4 id="泛型类">泛型类</h4><p>当一个类中，某个变量的数据类型不确定时，可以定义带有泛型的类,但在使用时，应该给泛型一个确定的数据类型</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ArrayList</span>&lt;<span class="symbol">E</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型方法">泛型方法</h4><p>方法中形参不确定时，可以使用类名后面定义的泛型，所有方法都能使用；<br>也可以在方法申明上定义自己的泛型，只有本方法可以使用</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyArrayList</span> &#123;</span><br><span class="line">publid &lt;E&gt; <span class="function"><span class="type">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">obj[size] = e;</span><br><span class="line">size++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型接口">泛型接口</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">List</span>&lt;<span class="symbol">E</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法：<br>1.实现类给出具体类型<br>2.实现类延续泛型，创建对象时再确定</p><h3 id="泛型通配符">泛型通配符</h3><p>在使用泛型时，虽然不确定类型，但是有时会希望只能传递某一个继承链中的数据类型，此时可以使用泛型通配符<br>? 表示不确定的类型<br>? extends E 表示可以传递E或E的所有子类类型<br>? super E 表示可以传递E或E的所有父类类型</p><h2 id="Collection的常见API">Collection的常见API</h2><p>Collection是一个接口，不能直接创建其对象<br><img src="/post-img/Pasted image 20230710140041.png" alt="图片损坏" style="zoom:100%;" /></p><h3 id="部分方法的细节">部分方法的细节</h3><p><strong>1.添加元素 add()</strong><br>如果我们要往List系列集合中添加数据，那么方法永远返回true，因为List系列的是允许元素重复的。<br>如果我们受往Set系列集合中添加数据，如果当前要添加元素不存在，方法返回true，表示添加成功。<br>如果当前要添加的元素已经存在。方法返回false。表示添加失败。因为Set系列的集合不允许重复。<br><strong>2…删除元素 remove()</strong><br>因为Collection里面定义的是共性的方法，所以此时不能通过索引进行剧除。只能通过元素的对象进行删除。<br>方法会有一个布尔类型的返回值。删除成功返回true，删除失败返回false；如果要剧除的元素不存在，剧除失败。<br><strong>3.判断集合是否包含 contains（）</strong><br>底层是依赖equals方法进行刘断是否存在的。所以，如果集合中存储的是自定义对象，也想通过contains方法来判断是否包含，那么在javabean类中，一定要重写equals方法。</p><h2 id="集合的遍历">集合的遍历</h2><h3 id="迭代器遍历">迭代器遍历</h3><h4 id="迭代器的三个方法">迭代器的三个方法</h4><p><strong>Iterator&lt; E &gt; iterator() :</strong> 获取一个迭代器对象<br><strong>boolean hasNext() :</strong> 判断当前指向的位置是否有元素<br><strong>E next() :</strong> 获取当前指向的元素并移动指针</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it <span class="operator">=</span> coll.iterator()<span class="comment">;</span></span><br><span class="line">while(it.hasNext())&#123;</span><br><span class="line">string str <span class="operator">=</span> it.next()<span class="comment">;</span></span><br><span class="line">System.out.println(str)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错NoSuchElementException指针已经指向集合最后没有元素的位置<br>迭代器遍历完毕，指针不会复位（要第二次遍历，只能获取新的迭代器对象）<br>循环中只能用一次next方法（元素数目为奇数时报错NoSuchElementException）<br>迭代器遍历时，不能用集合的方法进行增加或者删除（迭代器有remove方法删除指向的元素）</p><h3 id="增强for遍历">增强for遍历</h3><p>其本质是迭代器遍历，更便于书写,单列集合和数组才可以使用</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//idea中的快速生成方法，集合名字.for</span></span><br><span class="line"><span class="built_in">for</span>(string s: list) &#123;<span class="comment">//s是一个第三方变量，在循环的过程中依次表示集合中的每一个数据</span></span><br><span class="line">system<span class="selector-class">.out</span><span class="selector-class">.println</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在for中修改变量的值，修改的是第三方变量的值，不会影响原来的值</p><h3 id="lambda表达式">lambda表达式</h3><h4 id="匿名内部类方式：">匿名内部类方式：</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历集合依次得到每一个元素,把得到的每一个元素,传递给下面的accept方法</span></span><br><span class="line"><span class="comment">//s依次表示集合中的每一个数据</span></span><br><span class="line">coll.<span class="title function_">forEach</span>(<span class="keyword">new</span> consumer&lt;<span class="title class_">String</span>&gt;()&#123;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">accept</span>(<span class="params"><span class="built_in">String</span> s</span>) &#123;</span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lambda表达式方式：">lambda表达式方式：</h4><p>删除格式部分，加上箭头，数据类型省略，只有一个变量时小括号省略，方法体只有一行代码时大括号省略</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coll.<span class="keyword">forEach</span>(s -&gt;<span class="keyword">System</span>.<span class="keyword">out</span>.println(s));</span><br></pre></td></tr></table></figure><p>总结：在遍历过程中想要删除元素，用迭代器，仅仅想要遍历，用增强for或lambda表达式</p><h2 id="List">List</h2><h3 id="特有方法（索引相关）">特有方法（索引相关）</h3><img src="/post-img/Pasted image 20230710145358.png" alt="图片损坏" style="zoom:100%;" />1.添加元素 add（）在指定位置插入元素，原来位置上的元素后移2.删除元素 remove（）删除指定索引处的元素，返回被删除的元素重载方法remove（object o）；删除指定元素，返回是否删除成功3.修改元素 set（）修改指定索引处的元素，返回被修改的元素4.获取元素 get（）返回指定索引处的元素<h3 id="遍历方法">遍历方法</h3><p>1.迭代器遍历<br>2.增强for遍历<br>3.lambda表达式<br>4.普通for遍历<br>5.列表迭代器遍历<br>获取一个列表迭代器对象，里面的指针默认指向0<br>add，next，hasnext，remove<br>添加和修改时要用迭代器的方法</p><h4 id="五种遍历方式对比">五种遍历方式对比</h4><p>迭代器遍历         在遍历的过程中需要删除元素，请使用迭代器。<br>列表迭代器         在遍历的过程中需要添加元素，请使用列表迭代器。<br>增强for遍历、Lambda表达式       仅仅想遍历，那么使用增强for或Lambda表达式。<br>普通for          如果遍历的时候想操作索引，可以用普通for。</p><h3 id="ArrayList">ArrayList</h3><h4 id="创建">创建</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;?&gt; list = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;<span class="keyword">String</span>&gt;();</span><br></pre></td></tr></table></figure><p>打印ArrayList中的数据时，由于java底层对其进行了处理<br>打印出的不是地址值，而是集合中存储的数据，展示时会用[ ]把所有的数据进行包裹，并在数据间加上”，“</p><h4 id="常用方法">常用方法</h4><img src="/post-img/Pasted image 20230719141133.png" alt="图片损坏" style="zoom:100%;" /><h4 id="底层原理">底层原理</h4><p>1.利用空参创建的集合，在底层创建一个默认长度为0的数组<br>2.添加第一个元素时，底层会创建一个新的长度为10的数组<br>3.存满时，会扩容1.5倍<br>4.如果一次添加多个元素，1.5倍还放不下，则新创建数组的长度以实际为准<br><a href="https://www.bilibili.com/video/BV17F411T7Ao?p=190&amp;vd_source=ed6c39835b03d1fda588ce43bc8a16e6">集合进阶-06-ArrayList源码分析_哔哩哔哩_bilibili</a></p><h3 id="LinkedList">LinkedList</h3><h4 id="常用方法-2">常用方法</h4><img src="/post-img/Pasted image 20230719143752.png" alt="图片损坏" style="zoom:100%;" /><h4 id="底层原理-2">底层原理</h4><p>底层是双链表，查询慢，增删快，如果操作的是首尾元素，速度也是极快的<br><a href="https://www.bilibili.com/video/BV17F411T7Ao?p=191&amp;vd_source=ed6c39835b03d1fda588ce43bc8a16e6">集合进阶07-LinkedList和迭代器的源码分析_哔哩哔哩_bilibili</a></p><h2 id="数据结构：树">数据结构：树</h2><h3 id="二叉树">二叉树</h3><p>度:每一个节点的子节点数量<br>树高:树的总层数<br>根节点:最顶层的节点<br>左子节点:左下方的节点<br>右子节点:右下方的节点<br>根节点的左子树:蓝色虚线<br>根节点的右子树:绿色虚线</p><h4 id="二叉查找树">二叉查找树</h4><p>每一个节点上最多有两个子节点<br>任意节点左子树上的值都小于当前节点<br>任意节点右子树上的值都大于当前节点</p><h4 id="二叉树的遍历">二叉树的遍历</h4><p>前序遍历：当前-&gt;左-&gt;右<br>中序遍历：左-&gt;当前-&gt;右<br>后序遍历：左-&gt;右-&gt;当前<br>层序遍历：从根节点开始一层一层遍历</p><h4 id="平衡二叉树">平衡二叉树</h4><p>任意节点的左右子树高度差不超过1</p><h5 id="左旋和右旋">左旋和右旋</h5><p>触发时机，当添加一个节点后，该树不再是一棵平衡二叉树<br>左旋：<br>1.从添加的节点开始，不断的往父节点找不平衡的节点，以不平衡的点作为支点<br>2.把支点左旋降级，变成左子节点<br>3.原先的右子节点变成新的父节点，并把多余的左子节点出让，给已经降级的根节点当右子节点<br>右旋：<br>1.从添加的节点开始，不断的往父节点找不平衡的节点，以不平衡的点作为支点<br>2.把支点右旋降级，变成右子节点<br>3.原先的左子节点变成新的父节点，并把多余的右子节点出让，给已经降级的根节点当左子节点</p><h3 id="红黑树">红黑树</h3><p>1.红黑树是一种自平衡的二叉查找树，是计算机科学中用到的一种数据结构<br>2.它是一种特殊的二叉查找树，红黑树的每一个节点上都有存储位表示节点的颜色<br>3.每一个节点可以是红或者黑;红黑树不是高度平衡的，它的平衡是通过&quot;红黑规则&quot;进行实现的</p><h4 id="红黑规则">红黑规则</h4><p>1.每一个节点或是红色的，或者是黑色的<br>2.根节点必须是黑色<br>3.如果一个节点没有子节点或者父节点，则该节点相应的指针属性值为Nil，这些Nil视为叶节点，每个叶节点(Nil)是黑色的<br>4.如果某一个节点是红色，那么它的子节点必须是黑色(不能出现两个红色节点相连的情况)<br>5.对每一个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点;</p><h4 id="添加节点的规则">添加节点的规则</h4><img src="/post-img/Pasted image 20230719163729.png" alt="图片损坏" style="zoom:100%;" /><h2 id="Set">Set</h2><p>特点：<br>1.无序：存取顺序不一致<br>2.不重复：可以去除重复<br>3.无索引：没有带索引的方法，所以不能使用普通for循环遍历，也不能通过索引获取元素<br>Set接口中的方法基本与collection中的API一致（没有自己的方法）</p><h3 id="HashSet">HashSet</h3><p>无序、不重复、无索引</p><h4 id="底层原理-3">底层原理</h4><p>1.HashSet集合底层采取哈希表存储数据<br>2.哈希表是一种对于增删改查数据性能都较好的结构<br>在JDK8之前，采用数组+链表<br>从JDK8开始，采用数组+链表+红黑树</p><h4 id="创建过程">创建过程</h4><p>1.创建一个默认长度16，默认加载因子为0.75的数组，数组名table<br>2.根据元素的哈希值跟数组的长度计算出应存入的位置<br>3.判断当前位置是否为null，如果是null直接存入<br>如果位置不为null，表示有元素，则调用equals方法比较属性值<br>一样:不存；不一样:存入数组，形成链表<br>JDK8以前:新元素存入数组，老元素挂在新元素下面<br>JDK8以后:新元素直接挂在老元素下面</p><h5 id="哈希值">哈希值</h5><p>1.根据hashcode方法算出来的int类型的整数<br>2.该方法定义在Object类中，所有对象都可以调用，默认使用地址值进行计算<br>3.一般情况下，会重写hashCode方法，利用对象内部的属性值计算哈希值<br>如果没有重写hashCode方法，不同对象计算出的哈希值是不同的<br>如果已经重写hashcode方法，不同的对象只要属性值相同，计算出的哈希值就是一样的<br>在小部分情况下，不同的属性值或者不同的地址值计算出来的哈希值也有可能一样。(哈希碰撞)</p><h4 id="一些问题">一些问题</h4><p>1.HashSet集合的底层数据结构是什么样的?<br>数组+链表（+红黑树）<br>2.HashSet添加元素的过程?<br>数组-&gt;链表-&gt;红黑树<br>3.HashSet为什么存和取的顺序不一样?<br>哈希值计算出来的数组序号不是按顺序排列的<br>4.HashSet为什么没有索引?<br>数组每个索引下都有链表，链表中每个数据在数组中的索引是相同的<br>5.HashSet是利用什么机制保证去重的?<br>利用hashcode和equals方法<br>因此如果向HashSet中存储自定义对象时，必须要重写这两个方法以达到去重的目的</p><h3 id="LinkedHashSet">LinkedHashSet</h3><p>有序、不重复、无索引</p><h4 id="底层原理-4">底层原理</h4><p>底层数据结构依然是哈希表，只是每个元素又额外的多了一个双链表的机制记录存储的顺序</p><h3 id="TreeSet">TreeSet</h3><p>可排序、不重复、无索引</p><h4 id="底层原理-5">底层原理</h4><p>底层是基于红黑树的数据结构实现排序的，增删改查性能都较好</p><h4 id="排序方式">排序方式</h4><h5 id="默认排序方式">默认排序方式</h5><p>使用TreeSet存储数据后读取时，如果不指定排序方式，java会按照默认的顺序排序后输出<br>对于数值类型: Integer , Double，默认按照从小到大的顺序进行排序。对于字符、字符串类型:按照字符在ASCII码表中的数字升序进行排序。</p><h5 id="实现Comparable接口">实现Comparable接口</h5><p>对于自定义对象或者想要指定排序方式的数值、字符类型的对象，可以通过实现Comparable接口来指定排序方式</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line"><span class="comment">//指定排序的规则</span></span><br><span class="line"><span class="comment">//只看年龄，我想要按照年龄的升序进行排列</span></span><br><span class="line"><span class="comment">//this表示当前要添加的元素；o表示已经在红黑树中存在的元素</span></span><br><span class="line"><span class="comment">//返回值为负数，认为当前添加的元素是小的，存左边</span></span><br><span class="line"><span class="comment">//返回值为正数，认为当前添加的元素是大的，存右边</span></span><br><span class="line"><span class="comment">//0，当前元素已经存在，舍弃</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.getAge() - o.getAge();</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="传递比较器Comparator">传递比较器Comparator</h5><p>当实现Comparable接口无法满足需求时，可以在创建TreeSet对象的时候，传递比较器Comparator(匿名内部类对象)指定规则</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后续可以简化为Lambda表达式</span></span><br><span class="line"><span class="title class_">TreeSet</span>&lt;<span class="built_in">string</span>&gt; ts = <span class="keyword">new</span> <span class="title class_">Treeset</span>&lt;&gt;(<span class="keyword">new</span> comparator&lt;<span class="title class_">String</span>&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> int <span class="title function_">compare</span>(<span class="params"><span class="built_in">string</span> o1，<span class="built_in">string</span> o2</span>)&#123;</span><br><span class="line"><span class="comment">//按照长度排序</span></span><br><span class="line">int i = o1.<span class="title function_">length</span>() - o2.<span class="title function_">length</span>();</span><br><span class="line"><span class="comment">//如果一样长则按照首字母排序</span></span><br><span class="line">i = i == <span class="number">0</span> ? o1.<span class="title function_">compareTo</span>(o2) : i;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="对比选择">对比选择</h3><p><strong>1.如果想要集合中的元素可重复</strong><br>用ArrayList集合，基于数组的。(用的最多)<br><strong>2.如果想要集合中的元素可重复，而且当前的增删操作明显多于查询</strong><br>用LinkedList集合，基于链表的。<br><strong>3.如果想对集合中的元素去重</strong><br>用HashSet集合，基于哈希表的。(用的最多)<br><strong>4.如果想对集合中的元素去重，而且保证存取顺序</strong><br>用LinkedHashSet集合，基于哈希表和双链表，效率低于HashSet。<br><strong>5.如果想对集合中的元素进行排序</strong><br>用TreeSet集合，基于红黑树。后续也可以用List集合实现排序。</p><h1>双列集合</h1><h2 id="双列集合的特点">双列集合的特点</h2><p>1.双列集合一次需要存一对数据,分别为键和值<br>2.键不能重复，值可以重复<br>3.键和值是一一对应的，每一个键只能找到自己对应的值<br>4.键＋值这个整体我们称之为“键值对”或者“键值对对象”，在Java中叫做“Entry对象”</p><h2 id="Map的常见API">Map的常见API</h2><img src="/post-img/Pasted image 20230719164300.png" alt="图片损坏" style="zoom:100%;" /><h3 id="部分方法的细节-2">部分方法的细节</h3><p><strong>put() 添加或覆盖</strong><br>在添加数据的时候，如果键不存在，那么直接把键值对对象添加到map集合当中,方法返回null<br>在添加数据的时候，如果键是存在的，那么会把原有的键值对对象覆盖，会把被覆盖的值进行返回。</p><h2 id="Map的遍历">Map的遍历</h2><h3 id="键找值">键找值</h3><p>先通过keySet()方法获取每一个键，再通过键寻找到每一个值，从而遍历<br>可以采用增强for，迭代器和lambda表达式的方法</p><h3 id="键值对">键值对</h3><p>通过entrySet()方法获取所有的键值对对象，返回一个Set集合<br>可以采用增强for，迭代器和lambda表达式的方法</p><h3 id="Lambda表达式">Lambda表达式</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//forEach的底层就是利用键值对的方法遍历的</span></span><br><span class="line"><span class="built_in">map</span>.forEach(<span class="literal">new</span> BiC onsumer&lt;<span class="built_in">String</span>,<span class="built_in">String</span>&gt;()&#123;</span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="literal">void</span> accept(<span class="built_in">String</span> key,<span class="built_in">String</span> value)&#123;</span><br><span class="line">System.out.println(key + <span class="string">&quot;=” + value);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">//可以简化为Lambda表达式</span></span><br><span class="line"><span class="string">map.forEach((key,value)-&gt;System.out.println(key+ &quot;</span>=<span class="string">&quot; +value));</span></span><br></pre></td></tr></table></figure><h2 id="HashMap">HashMap</h2><p>1.HashMap是Map里面的一个实现类。<br>2.没有额外需要学习的特有方法，直接使用Map里面的方法就可以了。<br>3.特点都是由键决定的:<strong>无序、不重复、无索引</strong><br>4.HashMap跟HashSet底层原理是一模一样的，都是哈希表结构<br>链表长度超过8且数组长度超过64时，会自动转为红黑树<br>5.依赖hashcode方法和equals方法保证键的唯一<br>如果键存储的是自定义对象，需要重写hashCode和equals方法<br>如果值存储的是自定义对象,，不需要重写hashCode和equals方法</p><h2 id="LinkedHashMap">LinkedHashMap</h2><p>1.由键决定:<strong>有序、不重复、无索引</strong><br>2.这里的有序指的是保证存储和取出的元素顺序一致<br>3.原理︰底层数据结构是依然哈希表，只是每个键值对元素又额外的多了一个双链表的机制记录存储的顺序。</p><h2 id="TreeMap">TreeMap</h2><p>1.TreeMap跟TreeSet底层原理一样，都是红黑树结构的，增删改查性能好<br>2.由键决定特性:<strong>不重复、无索引、可排序</strong><br>3.可排序:对键进行排序<br>默认按照键的从小到大进行排序，也可以自己规定键的排序规则（实现Comparable接口、传递比较器Comparator）</p><h2 id="可变参数">可变参数</h2><p>方法形参的个数可以发生变化<br>格式：属性类型…名字（int…args）<br>它的底层就是一个数组，只不过不用我们自己创建<br>注意：<br>1.方法的形参中最多只能写一个可变参数<br>2.在方法参数中，如果除了可变参数还有其他参数，可变参数要作为最后一个参数</p><h2 id="Collections">Collections</h2><p>不是集合，是一个工具类</p><h3 id="常用API：">常用API：</h3><img src="/post-img/Pasted image 20230719171244.png" alt="图片损坏" style="zoom:100%;" />]]></content>
    
    
    <summary type="html">java基础知识</summary>
    
    
    
    <category term="java" scheme="https://xlxq.fun/categories/java/"/>
    
    
    <category term="java" scheme="https://xlxq.fun/tags/java/"/>
    
  </entry>
  
</feed>

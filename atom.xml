<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>星落溪桥</title>
  
  
  <link href="https://xlxq.fun/atom.xml" rel="self"/>
  
  <link href="https://xlxq.fun/"/>
  <updated>2024-07-23T14:00:00.000Z</updated>
  <id>https://xlxq.fun/</id>
  
  <author>
    <name>星落溪桥</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>三次握手和四次挥手</title>
    <link href="https://xlxq.fun/posts/f45a2f4a.html"/>
    <id>https://xlxq.fun/posts/f45a2f4a.html</id>
    <published>2024-07-10T11:18:02.000Z</published>
    <updated>2024-07-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层协议。在建立连接和断开连接时，TCP 使用三次握手和四次挥手来确保通信的可靠性和正确性。</p><h1>三次握手与四次挥手</h1><h2 id="三次握手过程">三次握手过程</h2><ol><li><strong>客户端向服务器发送连接请求</strong>： 客户端发送一个 SYN（同步）标志位被置为 1 的数据包给服务器，并指定初始序列号（Seq=X）。</li><li><strong>服务器响应确认请求</strong>： 服务器收到 SYN 包后，如果同意连接，会发送一个 ACK（确认）标志位和 SYN 标志位都被置为 1 的数据包给客户端，表示确认收到请求，并分配自己的序列号（Seq=Y），同时也会回复一个确认序号（Ack=X+1），表示收到的请求已确认。</li><li><strong>客户端发送确认响应</strong>： 客户端收到服务器的确认后，也会向服务器发送一个 ACK 标志位被置为 1 的数据包，表示对服务器的响应已确认，同时也会回复一个确认序号（Ack=Y+1），表示收到的响应已确认。<br>这样，客户端与服务器之间的连接就建立起来了，可以开始进行数据的传输。</li></ol><h2 id="四次挥手过程">四次挥手过程</h2><ol><li><strong>客户端发送断开连接请求</strong>： 客户端发送一个 FIN（结束）标志位被置为 1 的数据包给服务器，表示客户端不再发送数据。</li><li><strong>服务器确认断开连接请求</strong>： 服务器收到客户端的 FIN 包后，会向客户端发送一个 ACK 标志位被置为 1 的数据包，表示收到了客户端的断开请求。</li><li><strong>服务器向客户端发送断开连接请求</strong>： 当服务器不再发送数据时，会向客户端发送一个 FIN 标志位被置为 1 的数据包，表示服务器准备好断开连接。</li><li><strong>客户端确认断开连接请求</strong>： 客户端收到服务器的 FIN 包后，会向服务器发送一个 ACK 标志位被置为 1 的数据包，表示确认收到服务器的断开请求。<br>当客户端收到确认后，等待一段时间（TIME_WAIT 状态，<code>2MSL</code>），确保服务器接收到确认信息，然后关闭连接。服务器在接收到客户端的确认后，也会关闭连接。这样，客户端与服务器之间的连接就断开了。</li></ol><h2 id="三次握手状态转变">三次握手状态转变</h2><h3 id="客户端">客户端</h3><ol><li><strong>CLOSED</strong>：初始状态，表示连接未建立。</li><li><strong>SYN_SENT</strong>：发送了SYN包后进入此状态，等待服务器的确认。</li><li><strong>ESTABLISHED</strong>：收到服务器的确认后进入此状态，连接建立成功。</li></ol><h3 id="服务器端">服务器端</h3><ol><li><strong>CLOSED</strong>：初始状态，表示连接未建立。</li><li><strong>LISTEN</strong>：准备接受连接请求，等待客户端发送SYN包。</li><li><strong>SYN_RCVD</strong>：收到客户端的SYN包后进入此状态，发送确认和自己的SYN包。</li><li><strong>ESTABLISHED</strong>：收到客户端的确认后进入此状态，连接建立成功。</li></ol><h2 id="四次挥手状态转变">四次挥手状态转变</h2><h3 id="客户端-2">客户端</h3><ol><li><strong>ESTABLISHED</strong>：初始状态，表示连接正常进行。</li><li><strong>FIN_WAIT_1</strong>：发送了FIN包后进入此状态，等待服务器的确认。</li><li><strong>FIN_WAIT_2</strong>：收到服务器的确认后进入此状态，等待服务器的FIN包或超时。</li><li><strong>TIME_WAIT</strong>：收到服务器的FIN包后进入此状态，等待服务器的确认或超时。</li><li><strong>CLOSED</strong>：收到服务器的确认后进入此状态，连接关闭。</li></ol><h3 id="服务器端-2">服务器端</h3><ol><li><strong>ESTABLISHED</strong>：初始状态，表示连接正常进行。</li><li><strong>CLOSE_WAIT</strong>：收到客户端的FIN包后进入此状态，发送确认。</li><li><strong>LAST_ACK</strong>：发送了自己的FIN包后进入此状态，等待客户端的确认。</li><li><strong>CLOSED</strong>：收到客户端的确认后进入此状态，连接关闭。</li></ol><h2 id="图解">图解</h2><img src="/post-img/Pasted image 20240317105405.png" alt="图片损坏" style="zoom:100%;" /><h1>为什么是三次握手</h1><h2 id="分析">分析</h2><ol><li>“握手”也就是客户端和服务器端进行数据通信的过程是需要资源的，而且由于TCP是通信的基础，因此在真实的网络请求中建立连接的次数是非常多的，因此需要尽可能地找到最小的“握手”次数来保证连接的稳定性</li><li>很显然，通过四次握手必然能够实现稳定的连接（双方能够互相发送消息），并且这种连接是具有实时性的，不会因为网络通信问题导致两端的连接状态不一致</li><li>现在的问题是能否将四次握手简化至三次甚至两次？如果简化至两次，考虑一种情况，如果只有两次握手，即客户端发送连接请求，服务器接受连接请求并发送确认，连接就建立成功了。但是，如果这个确认包由于某些原因在网络中被延迟，而客户端已经认为连接已经建立成功，那么客户端就会开始发送数据了。然而，服务器并不知道客户端已经开始发送数据，因为它从未收到客户端的确认，所以也不会发送数据的确认。这样就可能导致两边的连接状态不一致，客户端认为连接已建立，而服务器并不知情。当最终确认包到达服务器时，服务器可能会误解为这是一个新的连接请求，从而建立了一个新的连接。这就会导致两个问题：<strong>一是旧的连接处于半开状态，消耗了服务器的资源；二是客户端发送的数据在新连接上丢失，因为服务器并不知道它已经发送了数据。</strong></li><li>综上分析：<strong>三次握手是消耗资源最少的能够保证有效连接以及确保连接时效性的最佳连接确认方式</strong></li></ol><h2 id="三次握手的作用">三次握手的作用</h2><ol><li><strong>初始化序列号</strong>：在通信开始之前，需要确定<strong>初始的序列号以及确认号</strong>。这两个序列号是 TCP 进行数据传输的基础。通过三次握手，客户端和服务器可以相互交换初始的序列号，从而确保后续的数据传输能够正确地同步。</li><li><strong>确认双方的发送和接收能力</strong>：通过三次握手，客户端和服务器可以确认对方的发送和接收能力正常。在第三次握手中，服务器发送确认消息，客户端接收并发送确认消息，这样双方就可以确认彼此的能力，以及连接是否能够正常建立。</li><li><strong>防止旧连接的影响</strong>：在网络中，可能会存在旧的连接或者延迟的数据包。通过三次握手，可以确保只有最新的连接才能够建立，避免了旧连接对新连接的影响。</li><li><strong>防止重复的连接请求</strong>：如果没有三次握手，客户端可能会发送多个连接请求，导致服务器建立多个连接。通过三次握手，可以防止重复的连接请求，确保只有一条连接被正确地建立。</li></ol><h1>补充</h1><h2 id="MSL">MSL</h2><ol><li>MSL（Maximum Segment Lifetime，最大报文生存时间）是 TCP 协议中的一个概念，指的是 TCP 报文在网络中允许存在的最长时间。</li><li>MSL 的值通常由实现 TCP 协议的操作系统决定，一般为 2 分钟（120 秒）。</li><li>MSL 的主要作用是确保网络中的旧数据报文能够及时丢弃，以避免旧的报文在网络中产生混乱。当一个 TCP 连接被关闭时，连接的每一端都会在关闭之后等待 MSL 的时间，以确保连接中的所有数据报文都已经在网络中完全传输并被丢弃。这样可以确保网络中不会再出现与旧连接相关的数据报文，避免对新连接的影响。<br><strong>四次挥手时为什么要等2MSL</strong></li><li>保证A发送的最后一个ACK报文段一定能被B接收到</li><li>防止已失效的连接请求报文段重新出现在新的连接中（使本次请求产生的所有数据都消失在网络中）</li></ol>]]></content>
    
    
    <summary type="html">计算机基础</summary>
    
    
    
    <category term="计算机基础" scheme="https://xlxq.fun/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机基础" scheme="https://xlxq.fun/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>传输层协议详解</title>
    <link href="https://xlxq.fun/posts/82ec1c83.html"/>
    <id>https://xlxq.fun/posts/82ec1c83.html</id>
    <published>2024-07-10T11:18:02.000Z</published>
    <updated>2024-07-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>TCP</h1><h2 id="TCP头部格式">TCP头部格式</h2><p>四元组（<strong>源地址，源端口，目的地址，目的端口</strong>）可以唯一的确定一个连接。<br>源地址和目的地址的字段（32 位）是在 IP 头部中，作用是通过 IP 协议发送报文给对方主机。<br>源端口和目的端口的字段（16 位）是在 TCP 头部中，作用是告诉 TCP 协议应该把报文发给哪个进程。<br>（图源<a href="https://xiaolincoding.com/">小林coding</a>）<br><img src="/post-img/Pasted image 20240728200950.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="三次握手与四次挥手">三次握手与四次挥手</h2><p><a href="https://www.xlxq.fun/posts/f45a2f4a.html">三次握手和四次挥手 | 星落溪桥 (xlxq.fun)</a></p><h2 id="滑动窗口">滑动窗口</h2><h3 id="滑动窗口的基本概念">滑动窗口的基本概念</h3><p>滑动窗口是一种流量控制机制，主要目的是控制发送方<strong>可以发送而不需要等待确认（ACK）的最大字节数量</strong>。窗口的实现实际上是操作系统开辟的一个<strong>缓存空间</strong>，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。发送窗口和接收窗口分别位于发送方和接收方：</p><ul><li><strong>发送窗口</strong>：发送方可以在没有接收方确认的情况下连续发送的数据量。</li><li><strong>接收窗口</strong>：接收方通知发送方自己能够接收的最大数据量，以避免自身缓冲区溢出。</li></ul><h3 id="滑动窗口的工作原理">滑动窗口的工作原理</h3><p>滑动窗口机制的工作过程可以分为以下几个步骤：</p><ol><li><strong>初始化窗口</strong>：发送方初始化发送窗口，初始窗口大小根据网络情况和协议规定设定。</li><li><strong>数据发送</strong>：发送方在窗口范围内发送数据，每发送一个数据段（Segment）会占用窗口中的一个位置。</li><li><strong>确认ACK</strong>：接收方接收到数据后，会返回一个确认包（ACK），表示已经成功接收到数据，并告知发送方可以接收更多的数据。</li><li><strong>窗口滑动</strong>：当发送方收到接收方的ACK后，会移动窗口，使得更多的数据可以被发送。这一过程称为窗口的“滑动”。</li><li><strong>可用窗口大小计算</strong>：有两个指针分别指向<strong>发出但未收到确认的第一个字节、未发送但可发送范围的第一个字节的序列号</strong>，通过这两个指针所在位置以及当前滑动窗口大小可以计算得到当前可用的窗口大小（还可以发多少）</li></ol><h3 id="窗口大小调整">窗口大小调整</h3><p>通常窗口的大小是由接收方的窗口大小来决定的。TCP 头里有一个字段叫 <code>Window</code>，也就是窗口大小。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据，于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。<br>TCP的窗口大小并不是固定不变的，主要有以下几种情况会导致窗口大小的变化：</p><ul><li><strong>流量控制（Flow Control）</strong>：接收方通过调整窗口大小来控制发送方的发送速率，防止接收方缓冲区溢出。</li><li><strong>拥塞控制（Congestion Control）</strong>：发送方根据网络拥塞情况调整窗口大小，防止网络过载。主要包括以下几种算法：<ul><li><strong>慢启动（Slow Start）</strong>：初始窗口大小较小，随着每次成功的ACK，窗口指数级增长。</li><li><strong>拥塞避免（Congestion Avoidance）</strong>：在慢启动阈值（ssthresh）后，窗口线性增长，以避免拥塞。</li><li><strong>快速重传（Fast Retransmit）</strong>：当检测到丢包时，立即重传未确认的数据包。</li><li><strong>快速恢复（Fast Recovery）</strong>：在快速重传后，窗口减半，但不回到慢启动状态，而是进入拥塞避免状态。</li></ul></li></ul><h2 id="重传机制">重传机制</h2><h3 id="超时重传">超时重传</h3><p><strong>超时重传（Timeout Retransmission）</strong> 是当发送方发送一个数据包后没有在指定的时间内收到相应的ACK确认时，会认为数据包可能已经丢失，于是重新发送该数据包的机制。</p><ul><li><strong>超时计时器（RTO, Retransmission Timeout）</strong>：每个未确认的数据包都有一个对应的计时器，如果在计时器到期前没有收到ACK，就会触发重传。</li><li><strong>动态调整</strong>：RTO的设置通常是动态的，根据网络的往返时间（RTT, Round-Trip Time）不断调整，以适应当前网络状况。<strong>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</strong>。</li><li><strong>超时重传过程</strong>：<ol><li>发送方发送数据包并启动RTO计时器。</li><li>如果在RTO时间内收到ACK，重置计时器。</li><li>如果未收到ACK，RTO计时器到期后重传数据包，并重置RTO计时器。如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是<strong>超时间隔加倍</strong>。也就是每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。</li></ol></li></ul><h3 id="快速重传">快速重传</h3><p><strong>快速重传（Fast Retransmit）</strong> 是在没有等待RTO超时的情况下，通过接收方的重复ACK来快速检测并重传丢失的数据包。</p><ul><li><strong>重复ACK</strong>：如果接收方收到的一个数据包超出预期顺序，就会立即发送一个重复的ACK来确认最后一个按序收到的数据包。</li><li><strong>快速重传过程</strong>：<ol><li>发送方发送数据包。</li><li>接收方发现数据包丢失，发送重复ACK。</li><li>当发送方连续收到三个重复ACK（表示网络中的一个数据包很可能丢失），立即重传丢失的数据包，而不等待RTO计时器到期。</li></ol></li></ul><h3 id="SACK（选择性确认）">SACK（选择性确认）</h3><p><strong>SACK（Selective Acknowledgment）</strong> 是一种TCP扩展， 在TCP 头部选项字段里加一个 <code>SACK</code> ，通过允许接收方告知发送方已正确接收到的非连续数据块，从而提高了数据重传的效率。</p><ul><li><strong>传统ACK问题</strong>：传统的TCP只允许接收方确认按序接收的数据，这在高丢包率环境下效率较低。</li><li><strong>SACK的优点</strong>：SACK使得接收方可以告诉发送方哪些具体的数据块已经成功接收，这样发送方只需重传那些丢失的数据块，而不是整个数据窗口。</li><li><strong>SACK选项</strong>：在TCP首部中加入SACK选项，包含已接收的非连续数据块的范围。</li><li><strong>SACK过程</strong>：<ol><li>接收方接收到数据包，使用SACK选项通知发送方已接收的数据块。</li><li>发送方根据SACK信息，选择性重传未确认的数据块，提高重传效率。</li></ol></li></ul><h3 id="D-SACK（重复选择性确认）">D-SACK（重复选择性确认）</h3><p><strong>D-SACK（Duplicate Selective Acknowledgment）</strong> 是SACK的一种扩展，用于检测并处理冗余重传的情况。</p><ul><li><strong>冗余重传问题</strong>：在某些情况下，发送方可能会不必要地重传已经成功接收的数据块，导致网络资源浪费。</li><li><strong>D-SACK功能</strong>：接收方使用D-SACK通知发送方已接收到重复的数据块，帮助发送方识别和调整重传策略。</li><li><strong>D-SACK过程</strong>：<ol><li>接收方收到重复数据包，使用D-SACK选项通知发送方重复接收的数据块。</li><li>发送方根据D-SACK信息，调整重传逻辑，避免不必要的重传，提高传输效率。</li></ol></li></ul><h2 id="流量控制">流量控制</h2><p>在TCP连接中，发送方和接收方通过滑动窗口协议进行数据传输。接收窗口是接收方通告给发送方的一个值，表示接收方当前可以接收的数据量。发送方根据这个窗口大小调整发送数据的速率，从而防止接收方的缓冲区溢出。</p><h3 id="流量控制的工作原理">流量控制的工作原理</h3><p>TCP流量控制的工作机制如下：</p><ol><li><strong>初始连接</strong>：在TCP三次握手过程中，双方会交换初始接收窗口大小。</li><li><strong>数据传输</strong>：<ul><li>发送方在发送数据时，会根据接收方通告的窗口大小控制发送的数据量。</li><li>每当接收方收到数据并成功处理后，会更新接收窗口大小，并在ACK报文中通知发送方。</li></ul></li><li><strong>窗口滑动</strong>：随着数据的发送和接收，窗口会不断滑动，表示新的数据可以被发送和接收。</li></ol><h3 id="流量控制过程详解">流量控制过程详解</h3><ol><li><strong>发送方初始化窗口</strong>：发送方根据接收方在三次握手中通告的初始窗口大小，开始发送数据。</li><li><strong>接收方处理数据</strong>：<ul><li>接收方处理并缓存接收到的数据，同时更新接收窗口大小。</li><li>接收窗口大小由接收方的缓冲区空间决定，接收方需要保证不会因为数据过多而导致缓冲区溢出。</li></ul></li><li><strong>ACK和窗口更新</strong>：<ul><li>接收方发送ACK报文，确认已成功接收到的数据，并在报文中包含当前的接收窗口大小。</li><li>发送方根据接收方通告的窗口大小调整接下来的数据发送量。</li></ul></li><li><strong>窗口关闭和打开</strong>：<ul><li>如果接收方的缓冲区已满（或可用窗口太小），接收窗口大小会变为零，此时发送方必须停止发送数据，直到接收方通告新的窗口大小。</li><li>当接收方处理完部分数据并释放缓冲区空间后，会发送一个更新窗口大小的ACK报文，通知发送方可以继续发送数据。</li></ul></li></ol><h3 id="流量控制的优势">流量控制的优势</h3><ul><li><strong>避免丢包</strong>：通过控制发送数据的速率，避免了接收方缓冲区溢出，从而减少了数据包的丢失。</li><li><strong>提高传输效率</strong>：动态调整发送速率，使得数据传输更加高效，充分利用了网络资源。</li><li><strong>适应网络变化</strong>：流量控制机制能够根据网络状况和接收方的处理能力，实时调整数据发送速率。</li></ul><h2 id="拥塞控制">拥塞控制</h2><p>一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大…<strong>拥塞控制</strong>目的就是<strong>避免发送方的数据填满整个网络。</strong></p><h3 id="慢启动">慢启动</h3><p><strong>慢启动</strong>是TCP在建立连接或检测到网络拥塞后，初始阶段使用的一种算法。其目的是逐步增加发送窗口大小，以避免突然向网络注入大量数据。</p><ol><li><strong>初始状态</strong>：发送方初始化拥塞窗口（cwnd）为一个较小的值，通常为1个MSS（最大报文段大小）。</li><li><strong>指数增长</strong>：每当收到一个ACK确认，cwnd增加一个MSS。结果是每轮RTT（Round-Trip Time）后，cwnd的大小翻倍。</li><li><strong>达到阈值</strong>：当cwnd达到一个预定义的慢启动阈值（ssthresh）时，慢启动阶段结束，进入拥塞避免阶段。</li></ol><h3 id="拥塞避免">拥塞避免</h3><p><strong>拥塞避免</strong>算法在慢启动结束后，通过线性增长的方式逐步增加cwnd，以避免网络拥塞。</p><ol><li><strong>线性增长</strong>：每个RTT结束时，cwnd增加一个MSS/cwnd的大小。</li><li><strong>检测拥塞</strong>：如果检测到数据包丢失（通过超时或三次重复ACK），认为发生了拥塞，调整ssthresh并重新进入拥塞控制阶段，即cwnd充重置为1。</li></ol><h3 id="快速重传-2">快速重传</h3><p><strong>快速重传</strong>是TCP在收到三个重复ACK（即相同的ACK连续三次出现）后，立即重传丢失的数据段，而不等待重传超时（RTO）到期。</p><ol><li><strong>重复ACK</strong>：接收方收到乱序数据段后，发送重复ACK。</li><li><strong>触发重传</strong>：发送方在收到三个重复ACK后，立即重传丢失的数据段。</li><li><strong>进入快速恢复</strong>：重传后，进入快速恢复阶段。</li></ol><h3 id="快速恢复">快速恢复</h3><p><strong>快速恢复</strong>算法在快速重传后，避免重新进入慢启动阶段，而是通过调整cwnd和ssthresh，快速恢复数据传输。</p><ol><li><strong>调整cwnd和ssthresh</strong>：检测到丢包后，ssthresh设置为cwnd的一半，cwnd设置为ssthresh+3个MSS。</li><li><strong>拥塞避免模式</strong>：进入拥塞避免模式，通过线性增长cwnd进行数据传输。</li><li><strong>恢复正常</strong>：当新的ACK确认所有丢失的数据段后，cwnd恢复到ssthresh，继续正常传输。</li></ol><h1>UDP</h1><h2 id="UDP头部格式">UDP头部格式</h2><p>（图源<a href="https://xiaolincoding.com/">小林coding</a>）<br><img src="/post-img/Pasted image 20240728204117.png" alt="图片损坏" style="zoom:100%;" /></p><h1>TCP和UDP对比</h1><p>一句话总结方便记忆：<br><strong>TCP面向连接，保证可靠性，面向字节流，头部20字节，只支持一对一连接，有拥塞控制等多种机制保证不丢失，不重复，不乱序，适用于需要可靠传输的场景；<br>UDP面向无连接，不保证可靠性，面向报文，头部8字节，支持各种连接，无状态，适用于对传输速度和实时性要求较高，但对数据丢失不敏感的场景。</strong></p><ol><li><strong>连接方式</strong>：TCP是面向连接的协议，在数据传输前，必须建立一个稳定的连接（通过三次握手机制），传输结束后需要拆除连接（通过四次挥手机制）。而UDP是无连接的协议，数据传输前不需要建立连接，直接将数据发送给接收方。</li><li><strong>可靠性</strong>：TCP提供可靠的数据传输，它通过序列号、确认应答（ACK）、超时重传、流量控制、拥塞控制等机制保证数据的完整性和正确顺序，保证无差错、不丢失、不重复、并且按序到达。而UDP不保证数据传输的可靠性，它不提供序列号、确认应答、重传机制，因此数据可能会丢失、重复或乱序。</li><li><strong>数据传输方式</strong>：TCP是面向字节流的数据传输，数据被分割成段（segment），每个段都被序列化和确认。而UDP是面向数据报的数据传输，数据被封装成独立的报文（datagram），每个报文都是一个完整的单元。</li><li><strong>传输效率</strong>：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</li><li><strong>首部开销</strong>：TCP首部较大，最小为20字节，包含序列号、确认号、窗口大小等控制信息。而UDP首部较小，为8字节，仅包含源端口、目的端口、长度和校验和。</li><li><strong>是否提供广播或多播服务</strong>：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</li><li><strong>是否有状态</strong>：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了。</li><li><strong>使用场景</strong>：TCP适用于需要可靠传输的场景，如文件传输（FTP）、电子邮件（SMTP）、网页浏览（HTTP/HTTPS）等。而UDP适用于对传输速度和实时性要求较高，但对数据丢失不敏感的场景，如视频流（VoIP）、在线游戏、DNS查询、广播和组播等。</li></ol>]]></content>
    
    
    <summary type="html">计算机基础</summary>
    
    
    
    <category term="计算机基础" scheme="https://xlxq.fun/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机基础" scheme="https://xlxq.fun/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>应用层协议详解</title>
    <link href="https://xlxq.fun/posts/48865a1.html"/>
    <id>https://xlxq.fun/posts/48865a1.html</id>
    <published>2024-07-10T11:18:02.000Z</published>
    <updated>2024-07-10T11:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1>HTTP</h1><h2 id="定义">定义</h2><p>HTTP：超文本传输协议<br><strong>超文本</strong>：文字、图片、视频等的混合体，例如HTML，本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，再经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。<br><strong>传输</strong>：是说HTTP是一种<strong>两点之间传输数据</strong>的约定和规范，并且这里的两点之间可以有中转，并且是双向的<br><strong>协议</strong>：协表明有<strong>两个以上的参与者</strong>，议表明它是一种<strong>约定和规范</strong><br>综上所述：<strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p><h2 id="常见状态码">常见状态码</h2><p><code>1xx</code> 类状态码属于<strong>提示信息</strong>，是协议处理中的一种中间状态，实际用到的比较少。<br><code>2xx</code> 类状态码表示服务器<strong>成功</strong>处理了客户端的请求，也是我们最愿意看到的状态。</p><ul><li>「<strong>200 OK</strong>」是最常见的成功状态码，表示一切正常。如果是非 <code>HEAD</code> 请求，服务器返回的响应头都会有 body 数据。</li><li>「<strong>204 No Content</strong>」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li><li>「<strong>206 Partial Content</strong>」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。<br><code>3xx</code> 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。301 和 302 都会在响应头里使用字段 <code>Location</code>，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</li><li>「<strong>301 Moved Permanently</strong>」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。</li><li>「<strong>302 Found</strong>」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。</li><li>「<strong>304 Not Modified</strong>」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。<br><code>4xx</code> 类状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</li><li>「<strong>400 Bad Request</strong>」表示客户端请求的报文有错误，但只是个笼统的错误。</li><li>「<strong>403 Forbidden</strong>」表示服务器禁止访问资源，并不是客户端的请求出错。</li><li>「<strong>404 Not Found</strong>」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。<br><code>5xx</code> 类状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</li><li>「<strong>500 Internal Server Error</strong>」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。</li><li>「<strong>501 Not Implemented</strong>」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。</li><li>「<strong>502 Bad Gateway</strong>」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</li><li>「<strong>503 Service Unavailable</strong>」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。</li></ul><h2 id="常见字段">常见字段</h2><h3 id="请求字段（Request-Headers）">请求字段（Request Headers）</h3><ol><li><strong>Host</strong>：请求的服务器地址。</li><li><strong>User-Agent</strong>：发出请求的用户代理的详细信息，通常是浏览器或其他客户端软件。</li><li><strong>Accept</strong>：客户端能够接收的内容类型，如<code>text/html</code>、<code>application/json</code>等。</li><li><strong>Accept-Language</strong>：客户端希望接受的语言，如<code>en-US</code>、<code>zh-CN</code>等。</li><li><strong>Accept-Encoding</strong>：客户端支持的编码方式，如<code>gzip</code>、<code>deflate</code>。</li><li><strong>Connection</strong>：控制不同请求/响应之间连接的选项，常见值为<code>keep-alive</code>。</li><li><strong>Authorization</strong>：包含证明客户端有权查看特定资源的凭证信息。</li><li><strong>Content-Type</strong>：请求体中内容的类型，如<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>。</li><li><strong>Content-Length</strong>：请求体的长度。</li><li><strong>Cookie</strong>：服务器发送的cookie。</li></ol><h3 id="响应字段（Response-Headers）">响应字段（Response Headers）</h3><ol><li><strong>Status Code</strong>：响应状态码，如<code>200 OK</code>、<code>404 Not Found</code>。</li><li><strong>Content-Type</strong>：响应内容的MIME类型。</li><li><strong>Content-Length</strong>：响应内容的长度。</li><li><strong>Content-Encoding</strong>：响应内容的编码方式。</li><li><strong>Set-Cookie</strong>：服务器向客户端发送的cookie。</li><li><strong>Cache-Control</strong>：告诉浏览器关于缓存如何处理响应的指令。</li><li><strong>ETag</strong>：资源的特定版本标识符。</li><li><strong>Expires</strong>：响应过期的日期/时间。</li><li><strong>Last-Modified</strong>：资源最后修改的日期和时间。</li><li><strong>Server</strong>：服务器软件信息。</li></ol><h2 id="常见方法">常见方法</h2><p>HTTP请求方法主要用于定义对资源的操作。这里有一些常见的HTTP方法和它们的基本用途：</p><ol><li><strong>GET</strong>：<ul><li>用途：请求指定的页面信息，并返回实体主体。</li><li>特点：幂等（多次请求同一资源的效果相同），通常用于获取数据，不应当引起服务器状态的改变。</li></ul></li><li><strong>POST</strong>：<ul><li>用途：向指定资源提交数据，请求服务器进行处理（例如提交表单或上传文件）。</li><li>特点：数据被包含在请求体中，可以引起服务器状态的改变，不是幂等的。</li></ul></li><li><strong>PUT</strong>：<ul><li>用途：从客户端向服务器传送的数据取代指定的文档的内容。</li><li>特点：幂等，通常用于更新资源。如果资源不存在，PUT方法可以创建一个新资源。</li></ul></li><li><strong>DELETE</strong>：<ul><li>用途：请求服务器删除指定的页面。</li><li>特点：幂等，用于删除资源。</li></ul></li></ol><h3 id="GET和POST对比">GET和POST对比</h3><p>GET用于获取资源,POST用于修改资源<br>GET请求参数位于url路径,明文显示,长度有限制,只支持askii编码<br>POST请求参数位于请求体,相对安全,理论上没有长度限制,支持多种编码形式(字段定义)</p><h2 id="各版本对比">各版本对比</h2><p>到目前为止，HTTP 常见到版本有 HTTP1.0，HTTP/1.1，HTTP/2.0，HTTP/3.0，不同版本的 HTTP 特性是不一样的。<br><img src="/post-img/Pasted image 20240721202156.png" alt="图片损坏" style="zoom:100%;" /><br>（图源<a href="https://xiaolincoding.com/">小林coding</a>）</p><h3 id="HTTP-1-0">HTTP/1.0</h3><p>优点：</p><ul><li><strong>简单易懂</strong>：非常基础，易于理解和实现。</li><li><strong>适合小型请求</strong>：对于小型或简单的文档传输效率较高。<br>缺点：</li><li><strong>无连接持续</strong>：每个请求都需要建立和关闭新的 TCP 连接，增加了延迟。</li><li><strong>重复的TCP连接开销</strong>：多个请求需要重复进行连接建立和断开，消耗资源且慢。</li></ul><h3 id="HTTP-1-1">HTTP/1.1</h3><p>优点：</p><ul><li><strong>连接持久化</strong>：通过重用 TCP 连接，减少了连接建立的延迟。</li><li><strong>管线化技术</strong>：允许在同一连接上同时发送多个请求，理论上可以提高页面加载速度。</li><li><strong>更丰富的缓存处理和错误通知</strong>：增加了缓存控制选项和更详细的状态响应。<br>缺点：</li><li><strong>管线化受限</strong>：实际应用中管线化往往受到<strong>队头阻塞</strong>问题的影响，效果不明显。</li><li><strong>头部未压缩</strong>：尽管增加了许多功能，但头部数据未压缩，导致冗余数据传输。</li><li><strong>被动响应</strong>：请求只能从客户端开始，服务器只能被动响应。</li></ul><h3 id="HTTP-2">HTTP/2</h3><p>优点：</p><ul><li><strong>基于HTTPS</strong>：保证了数据安全性。</li><li><strong>多路复用</strong>：允许多个请求在单一TCP连接上并行传输，多个 Stream 复用在一条 TCP 连接，通过唯一的Stream ID区分。</li><li><strong>头部压缩</strong>：使用 HPACK 压缩算法，减少了头部大小。</li><li><strong>服务器推送</strong>：客户端和服务器<strong>双方都可以建立 Stream</strong>， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。<br>缺点：</li><li><strong>加密要求</strong>：虽然提高了安全性，但加密操作也增加了计算开销。</li><li><strong>队头阻塞问题仍存在</strong>：虽然改善了，但仍然存在于TCP连接中，TCP 是字节流协议，必须等待收到的字节数据完整到达，如果没有需要等待重传</li></ul><h3 id="HTTP-3">HTTP/3</h3><p>优点：</p><ul><li><strong>基于 QUIC</strong>：基于UDP，改善了建立连接的延迟，支持更快的错误恢复，并且解决了队头阻塞问题</li><li><strong>改善恶劣网络性能</strong>：在网络条件变化大的环境下保持连接的稳定性更好。</li><li><strong>更细粒度的控制</strong>：单独的流控制减少了队头阻塞的问题。<br>缺点：</li><li><strong>普及程度</strong>：因为是基于 UDP，需要更多的基础设施更新和优化。</li><li><strong>资源使用</strong>：QUIC 协议可能会比基于 TCP 的协议使用更多的计算资源。</li></ul><h3 id="HTTPS">HTTPS</h3><p>HTTPS（超文本传输协议安全）并不是 HTTP 的一个版本，而是对 HTTP 协议的一个扩展，其主要目的是增强安全性。HTTPS 通过在 HTTP 顶层运行 SSL/TLS 加密协议，确保了数据传输的安全性和完整性，以及服务器和客户端的身份验证。<br>下面是 HTTPS 的一些核心特点：</p><ol><li><strong>加密</strong>:HTTPS 通过使用 SSL/TLS 协议，对传输的数据进行加密，这保证了数据在互联网上传输过程中不能被窥视或篡改。这包括 URL、请求内容、响应内容以及 HTTP 头部信息。</li><li><strong>身份验证</strong>:HTTPS 使用 SSL/TLS 中的公钥和私钥机制，帮助确保通信双方的身份。这通常通过使用证书实现，证书由可信的第三方证书颁发机构（CA）签发。这个过程帮助客户端确认它所连接的服务器就是其期望连接的服务器，防止了中间人攻击。</li><li><strong>数据完整性</strong>:通过加密过程中使用的完整性校验，HTTPS 确保数据在传输过程中没有被更改。这意味着发送方和接收方都能验证数据的完整性。</li><li><strong>使用端口和协议</strong>:HTTPS 通常运行在 TCP 端口 443 上，而不是 HTTP 默认的端口 80。这是从技术上区分 HTTP 和 HTTPS 的一个方式，但它们在应用层使用的是相同的协议。</li><li><strong>性能考虑</strong>:虽然 HTTPS 在安全性方面提供了显著的优势，但加密和解密过程需要额外的处理资源，这可能影响性能。随着技术的发展，这种性能差距已经大大减少，现代的网络基础设施和优化算法使得 HTTPS 可以在保持高安全性的同时，接近 HTTP 的性能。</li></ol><h1>DNS</h1><p>DNS协议（域名系统协议）是一个位于应用层的协议，它定义了域名和IP地址之间的查询和响应过程。DNS 协议允许用户通过域名访问网站，而无需记住复杂的IP地址。以下是DNS协议在计算机网络层面的详细描述：</p><h2 id="工作原理">工作原理</h2><p>DNS 协议的基本功能是解析域名到 IP 地址，即<strong>域名和 IP 地址的映射问题</strong>。这个过程通过一系列网络请求和响应实现：</p><ol><li><strong>用户输入域名</strong>：用户在浏览器等客户端应用程序中输入一个域名，如 <code>www.example.com</code>。</li><li><strong>本地 DNS 解析器查询</strong>：客户端首先查询本地 DNS 缓存（在这之前还会先查本地hosts列表），查看是否已经有这个域名的解析结果。如果没有，客户端的 DNS 解析器会向配置的 DNS 服务器发送一个 DNS 查询请求。</li><li><strong>递归和迭代查询</strong>：<ul><li><strong>DNS服务器</strong>：依次为根、顶级、权威、本地DNS服务器。</li><li><strong>递归查询</strong>：客户端的请求通常发送到一个递归DNS服务器，这通常由用户的ISP（互联网服务提供商）提供。这个服务器起着代理的作用，会负责处理完整的解析过程，向客户端提供最终结果。</li><li><strong>迭代查询</strong>：递归DNS服务器接收到查询后，可能会从根DNS服务器开始，逐级查询顶级域名服务器（TLD服务器）和权威DNS服务器，直到找到具体的IP地址。</li></ul></li></ol><h2 id="传输协议">传输协议</h2><p>DNS 通常使用 UDP 协议在端口 53 上运行，因为 UDP 允许快速的查询和响应，适合DNS的需求，不需要建立连接。在需要更可靠传输或数据量较大（如区域传输）时，DNS 会使用 TCP 协议。</p><h2 id="DNS记录">DNS记录</h2><p>DNS 服务器在响应查询时，需要查询自己的数据库，数据库中的条目被称为 <strong>资源记录(Resource Record，RR)</strong> 。RR 提供了主机名到 IP 地址的映射。RR 是一个包含了<code>Name</code>, <code>Value</code>, <code>Type</code>, <code>TTL</code>四个字段的四元组。<br><code>TTL</code>是该记录的生存时间，它决定了资源记录应当从缓存中删除的时间。<br><code>Name</code>和<code>Value</code>字段的取值取决于<code>Type</code>：例如A（主机名–&gt;IPv4）、AAAA（主机名–&gt;IPv6）、CNAME（主机名–&gt;主机名）等。</p><h1>DHCP</h1><p>DHCP（动态主机配置协议，Dynamic Host Configuration Protocol）是一个应用层协议，它位于TCP/IP模型的应用层，主要用于自动分配网络配置给网络设备，从而简化网络管理。它广泛应用于各种网络环境中，尤其是在大型网络中，能够有效地管理IP地址分配和配置。</p><h2 id="DHCP的主要功能">DHCP的主要功能</h2><ol><li><strong>自动分配IP地址</strong>：DHCP服务器能够自动为网络中的设备分配IP地址，这些地址可以是永久分配（静态）或临时分配（动态）。</li><li><strong>配置更新</strong>：除了IP地址，DHCP还可以自动分配子网掩码、默认网关、DNS服务器地址等网络配置信息。</li><li><strong>租约机制</strong>：DHCP分配给客户端的IP地址具有一定的有效期（称为租约），租约到期后，客户端需要重新请求IP地址续约。</li></ol><h2 id="DHCP的工作原理">DHCP的工作原理</h2><p>DHCP的操作包含以下四个基本步骤，通常被称为DORA过程：</p><ol><li><strong>Discover（发现）</strong>：<ul><li>DHCP客户端在网络上发送一个DHCP发现（Discover）广播包，寻找可用的DHCP服务器。</li></ul></li><li><strong>Offer（提供）</strong>：<ul><li>DHCP服务器接收到发现请求后，向客户端发送一个DHCP提供（Offer）广播包，提供一个IP地址和其他网络配置信息。</li></ul></li><li><strong>Request（请求）</strong>：<ul><li>客户端从一个或多个DHCP服务器收到提供后，选择一个，并通过发送DHCP请求（Request）广播包向选定的服务器请求这些网络配置信息。</li></ul></li><li><strong>Acknowledgment（确认）</strong>：<ul><li>DHCP服务器接收到请求后，发送一个DHCP确认（Acknowledgment）包给客户端，确认网络配置信息的分配和IP地址的租约。</li></ul></li></ol><h1>补充</h1><h2 id="HPACK-算法">HPACK 算法</h2><p>在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号。如果同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。</p><h2 id="HTTPS加密方式">HTTPS加密方式</h2><p><strong>对称加密和非对称加密</strong><br>在进行身份验证时进行非对称加密,后续数据传输进行对称加密<br>对称加密:加密方和解密方使用同一密钥,互相加解密<br>非对称加密:分为公钥和私钥,公钥可以随意发放,私钥自己留用，公钥可以解密私钥加密的数据,私钥可以解密公钥加密的数据<br><strong>HTTPS怎么保证对方可信</strong><br>服务器需要向CA机构获取认证证书,证书上有用机构的私钥加密的电子签名<br>认证阶段服务器向对方发送认证证书,对方通过电子签名的公钥解析电子签名,确保对方被认证过<br>认证完成后通信过程中使用对称加密来加密数据<br><strong>HTTP 与 HTTPS 有哪些区别</strong></p><ul><li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</li><li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</li><li>两者的默认端口不一样，HTTP 默认端口号是 80，HTTPS 默认端口号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的</li></ul>]]></content>
    
    
    <summary type="html">计算机基础</summary>
    
    
    
    <category term="计算机基础" scheme="https://xlxq.fun/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机基础" scheme="https://xlxq.fun/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>网络分层模型和常见协议</title>
    <link href="https://xlxq.fun/posts/76e23c1c.html"/>
    <id>https://xlxq.fun/posts/76e23c1c.html</id>
    <published>2024-07-10T11:18:02.000Z</published>
    <updated>2024-07-10T11:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>网络分层模型是为了简化网络设计和维护，将复杂的网络通信过程分解为若干层次，每一层都有其独特的功能和对应的协议。最常用的网络模型是 OSI（开放系统互连）模型和 TCP/IP 模型。</p><h1>OSI 模型</h1><p>OSI 模型由国际标准化组织（ISO）提出，包含七层：</p><ol><li><strong>应用层</strong>（Application Layer）：提供网络服务给应用程序，例如 HTTP、FTP、SMTP。</li><li><strong>表示层</strong>（Presentation Layer）：处理数据的表示方式、编码和转换功能，例如加密解密、转换文件格式。</li><li><strong>会话层</strong>（Session Layer）：建立、管理和终止会话，控制连接和端到端的数据交换。</li><li><strong>传输层</strong>（Transport Layer）：负责数据的端到端传输和错误恢复，例如 TCP、UDP。</li><li><strong>网络层</strong>（Network Layer）：处理数据包从源到目的地的传递和路由选择，例如 IP、ICMP。</li><li><strong>数据链路层</strong>（Data Link Layer）：处理数据帧的传输，包括错误检测和修正，例如 Ethernet、PPP。</li><li><strong>物理层</strong>（Physical Layer）：处理数据的物理传输，包括电缆、光纤、无线电传输等。</li></ol><h1>TCP/IP 模型</h1><p>TCP/IP 模型是互联网的基础，通常被分为四层：</p><ol><li><strong>应用层</strong>：等同于 OSI 模型的应用层、表示层和会话层，处理高级应用协议，例如 HTTP、SMTP、FTP。</li><li><strong>传输层</strong>：提供端到端的数据传输服务，使用 TCP（传输控制协议）和 UDP（用户数据报协议）。</li><li><strong>网络层</strong>：负责数据包的选择和转发，使用的是 IP 协议，包括 IPv4 或 IPv6。</li><li><strong>网络接口层</strong>：相当于 OSI 模型的数据链路层和物理层，负责数据帧的物理传输。</li></ol><h1>常见协议</h1><p>在 TCP/IP 模型中，通信协议按照四层结构进行划分，每层担任不同的通信任务，并使用各自的协议来执行这些任务。以下是按照 TCP/IP 四层模型划分的主要协议类型：</p><h2 id="应用层">应用层</h2><p>应用层包括所有针对特定应用的协议，这些协议直接为用户应用程序如网络浏览器、电子邮件客户端等提供服务。主要协议包括：</p><ul><li><strong>HTTP</strong>（超文本传输协议）：Web 浏览和数据访问的主要协议。</li><li><strong>HTTPS</strong>（HTTP 安全）：安全版本的 HTTP，使用 SSL/TLS 加密。</li><li><strong>FTP</strong>（文件传输协议）：用于在网络中传输文件。</li><li><strong>SMTP</strong>（简单邮件传输协议）：用于发送电子邮件。</li><li><strong>POP3</strong>（邮局协议第三版）和 <strong>IMAP</strong>（互联网消息访问协议）：用于接收电子邮件。</li><li><strong>DNS</strong>（域名系统）：将域名解析为 IP 地址。</li><li><strong>SSH</strong>（安全外壳协议）：用于安全访问远程计算机。</li></ul><h2 id="传输层">传输层</h2><p>传输层负责提供进程与进程之间的通信。在这一层，协议主要处理数据传输的细节，确保数据正确且有效地从源头传到目的地。主要协议包括：</p><ul><li><strong>TCP</strong>（传输控制协议）：提供可靠的、面向连接的数据传输服务。确保数据包正确顺序到达，广泛用于需要高可靠性的应用，如网页浏览、文件传输、电子邮件等。</li><li><strong>UDP</strong>（用户数据报协议）：提供无连接的数据传输服务，适用于对速度要求高但可以容忍一定数据丢失的应用，如视频流和在线游戏。</li></ul><h2 id="网络层">网络层</h2><p>网络层负责处理数据包在网络中的活动，包括数据包的路由选择和传输。主要协议包括：</p><ul><li><strong>IP</strong>（互联网协议）：核心协议，负责寻址和路由。IP 协议有两个版本：<ul><li><strong>IPv4</strong>：最广泛使用的版本。</li><li><strong>IPv6</strong>：新版本，提供更大的地址空间和改进的特性。</li></ul></li><li><strong>ICMP</strong>（互联网控制消息协议）：用于发送错误消息和网络通信的控制消息。</li><li><strong>ARP</strong>（地址解析协议）：用于解析网络层的 IP 地址到数据链路层的物理地址。</li></ul><h2 id="链路层">链路层</h2><p>链路层处理与物理网络的接口，包括数据在物理网络媒介上的传输。这一层的协议主要关注于本地网络范围内的数据交换。主要协议包括：</p><ul><li><strong>Ethernet</strong>：最常用的局域网技术。</li><li><strong>PPP</strong>（点对点协议）：在点对点连接中封装网络层数据包。</li><li><strong>Wi-Fi</strong>：无线局域网标准。</li></ul>]]></content>
    
    
    <summary type="html">计算机基础</summary>
    
    
    
    <category term="计算机基础" scheme="https://xlxq.fun/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机基础" scheme="https://xlxq.fun/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>网络层协议详解</title>
    <link href="https://xlxq.fun/posts/f28a47be.html"/>
    <id>https://xlxq.fun/posts/f28a47be.html</id>
    <published>2024-07-10T11:18:02.000Z</published>
    <updated>2024-07-10T11:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1>IP</h1><p>IP地址是互联网协议地址（Internet Protocol Address）的简称，是分配给每个连接到网络的设备的数字标签。IP地址用于设备的识别和位置寻址。IP地址主要有两种类型：IPv4 和 IPv6。</p><h2 id="IPv4-地址结构">IPv4 地址结构</h2><p>IPv4 地址是目前最广泛使用的IP地址形式，它是一个32位的数字，通常表示为四个十进制数，每个数介于0到255之间，数之间用点（<code>.</code>）分隔。例如：192.168.1.1。</p><h3 id="分类">分类</h3><p>早期IP地址显得很有余裕，因此被分为几个类别来达到简化路由表和简化地址管理和分配过程的目的。</p><h4 id="网络规模的适应性">网络规模的适应性</h4><p>IP地址分类允许不同规模的网络选择最合适的地址类别：</p><ul><li><strong>A类地址</strong>用于规模很大的网络，如国际性企业或主要的网络服务提供商。</li><li><strong>B类地址</strong>适用于中等规模的网络，如大学或大型公司。</li><li><strong>C类地址</strong>用于小规模网络，如小型企业或局域网。</li></ul><h4 id="简化路由">简化路由</h4><p>通过将IP地址分为几个固定的类别，可以简化路由表的结构。因为同一类别的地址具有相同长度的网络前缀，路由器可以通过检查IP地址的前几位就能快速决定如何转发数据包。这种方式在早期互联网上帮助减少了路由器的处理负担，并提高了路由效率。</p><h4 id="地址分配和管理">地址分配和管理</h4><p>IP地址的分类简化了地址的分配和管理过程。每个类别的地址都有预定的网络和主机部分，这使得网络管理员可以更容易地根据组织的规模和需求分配地址。此外，这也便于实施统一的管理策略和监控网络使用情况。</p><h4 id="具体分类">具体分类</h4><p>IPv4 地址按照首个字节的值被分为几个类别：</p><ul><li><strong>A类</strong>：第一个字节在1到126之间（网络部分为8位，主机部分为24位）。例如：10.0.0.1。</li><li><strong>B类</strong>：第一个字节在128到191之间（网络部分为16位，主机部分为16位）。例如：172.16.0.1。</li><li><strong>C类</strong>：第一个字节在192到223之间（网络部分为24位，主机部分为8位）。例如：192.168.1.1。</li><li><strong>D类</strong>：第一个字节在224到239之间，用于多播。</li><li><strong>E类</strong>：第一个字节在240到255之间，保留作为实验和研究用途。<br>每个IP类别有特定的默认子网掩码，例如A类地址的默认子网掩码是255.0.0.0，B类是255.255.0.0，C类是255.255.255.0。</li></ul><h2 id="IPv6-地址结构">IPv6 地址结构</h2><p>IPv6 地址是为了解决IPv4地址耗尽的问题而设计的，它有128位长，通常用八组四个十六进制数表示，每组之间用冒号（<code>:</code>）分隔。例如：2001:0db8:85a3:0000:0000:8a2e:0370:7334。<br>IPv6 地址的表示还可以简化，比如省略前导零或者用双冒号（<code>::</code>）代替一系列的零。但是双冒号在一个地址中只能使用一次，以保证地址的唯一解析。</p><h3 id="优点">优点</h3><ul><li>IPv6 可自动配置，即使没有 DHCP 服务器也可以实现自动分配IP地址。</li><li>IPv6 包头包首部长度采用固定的值 <code>40</code> 字节（将额外字段通过软链指向的形式确定为固定长度），去掉了包头校验和，简化了首部结构，减轻了路由器负荷，大大<strong>提高了传输的性能</strong>。</li><li>IPv6 有应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能，大大<strong>提升了安全性</strong>。</li></ul><h2 id="CIDR-无分类地址">CIDR 无分类地址</h2><p>CIDR（Classless Inter-Domain Routing，无类别域间路由）是一种用于提高IP地址分配效率和灵活性的方法，特别是在互联网上。CIDR于1993年引入，以解决传统的基于类的IP地址分类方法（如A类、B类、C类）的缺陷，并缓解IPv4地址快速耗尽的问题。CIDR的核心在于它允许网络管理员使用可变长度的子网掩码，从而更加精确地定义网络和主机部分的界限。并且在IPv6中得到广泛应用。</p><h3 id="早期分类法的缺陷">早期分类法的缺陷</h3><ol><li><strong>同一网络下没有地址层次</strong>，比如一个公司里用了 B 类地址，但是可能需要根据生产环境、测试环境、开发环境来划分地址层次，而这种 IP 分类是没有地址层次划分的功能，所以这就缺少地址的灵活性。</li><li>A、B、C类不能很好的与现实网络匹配。C 类地址能包含的最大主机数量实在太少了，只有 254，而 B 类地址能包含的最大主机数量又太多了，6 万多台机器放在一个网络下面，多余的地址被浪费了。</li></ol><h3 id="CIDR表示法">CIDR表示法</h3><p>CIDR使用斜杠后缀来表示网络地址和它的位掩码的长度。格式为：<code>IP地址/掩码位数</code>。掩码位数指出IP地址中用于表示网络地址的位数。<br>例如，<code>192.168.0.0/24</code>表示前24位是网络地址，剩余的8位是主机地址。这种表示法允许在网络设计时更灵活地分配IP地址空间。</p><h4 id="网络号、主机号和子网掩码">网络号、主机号和子网掩码</h4><ol><li><strong>网络号（Network ID）</strong>：<ul><li>网络号是IP地址中用于标识特定网络的部分。在一个网络中，所有设备的网络号都相同，而主机号不同。</li><li>对于IPv4地址，根据其类别（A、B、C类），网络号的长度会有所不同。例如，A类地址的前8位是网络号，B类的前16位是网络号，C类的前24位是网络号。</li></ul></li><li><strong>主机号（Host ID）</strong>：<ul><li>主机号是IP地址中用于标识网络中的具体设备的部分。</li><li>在同一网络内，每个设备的主机号必须是唯一的。</li></ul></li><li><strong>子网掩码</strong>：<ul><li>用于指示IP地址中哪些位是网络部分（包括子网部分），哪些位是主机部分的一个32位数。子网掩码在网络位上是连续的1，主机位上是0。</li><li>子网掩码允许网络管理员将一个较大的网络划分为若干个较小的网络（子网），每个子网具有自己的网络地址。</li></ul></li></ol><h4 id="子网网络地址和子网主机地址">子网网络地址和子网主机地址</h4><ol><li><strong>子网网络地址</strong>：<ul><li>子网网络地址（或简称子网地址）是子网中的一个特殊地址，其中所有主机位都设置为0。这个地址用于标识子网本身，而不是子网中的某个具体设备。</li><li>例如，对于子网掩码<code>255.255.255.0</code>和IP地址<code>192.168.1.1</code>，子网地址是<code>192.168.1.0</code>。</li></ul></li><li><strong>子网主机地址</strong>：<ul><li>子网中除了网络地址和广播地址外的其他地址都是子网主机地址，用于标识子网中的各个设备。</li><li>在同一子网内，每个设备的子网主机地址必须是唯一的。</li><li>子网主机地址是从网络地址的下一个地址开始，直到广播地址（所有主机位全1）的前一个地址结束。</li></ul></li></ol><h3 id="CIDR的优点">CIDR的优点</h3><ol><li><strong>更灵活的地址分配</strong>：网络大小可以根据实际需要定制，不再受传统A、B、C类网络划分的限制。</li><li><strong>减少路由表项</strong>：CIDR支持路由聚合（也称为路由汇总），可以将多个小网络合并为一个路由表项，这减少了全球互联网路由表的大小，提高了路由效率。</li><li><strong>更有效的IP地址利用率</strong>：通过允许创建细粒度的子网，CIDR减少了IP地址的浪费。</li></ol><h3 id="CIDR与子网掩码">CIDR与子网掩码</h3><p>CIDR通过使用可变长度的子网掩码来工作，这种掩码直接显示了地址中网络部分的位数。例如，如果掩码位数是24，则子网掩码为255.255.255.0，这意味着IP地址的前三个字节用于网络地址，最后一个字节用于主机地址。这种方法大大增加了网络地址分配的灵活性。</p><h1>ICMP</h1><p>ICMP 全称是 <strong>Internet Control Message Protocol</strong>，也就是<strong>互联网控制报文协议</strong>，是一个核心的互联网协议，它用于在IP主机、路由器之间传递控制消息，主要用于<strong>提供反馈有关网络中存在的问题</strong>，而不是直接传输应用程序数据。</p><h2 id="主要功能">主要功能</h2><p>ICMP执行许多网络功能，其中最常见的包括：</p><ol><li><strong>错误报告</strong>：ICMP用于报告错误情况，例如目标不可达、包含生存时间过期的数据包（Time Exceeded）、重定向消息等。</li><li><strong>诊断工具</strong>：ICMP也用于实现如Ping和Traceroute这类网络诊断工具。Ping使用ICMP回显请求（Echo Request）和回显应答（Echo Reply）消息来检查两台主机之间的连通性。Traceroute用于显示数据包从源主机到目的主机之间经过的路由路径。</li><li><strong>网络设备配置</strong>：某些类型的ICMP消息用于网络设备的初始配置或其他功能。</li></ol><h2 id="ICMP消息类型">ICMP消息类型</h2><p>ICMP 大致可以分为两大类：</p><ul><li>一类是用于诊断的查询消息，也就是「<strong>查询报文类型</strong>」</li><li>另一类是通知出错原因的错误消息，也就是「<strong>差错报文类型</strong>」<br>ICMP消息有多种类型，每种类型都有一个特定的目的。这些类型包括：</li><li><strong>目的不可达</strong>（Destination Unreachable）：当数据无法成功传递时，发送此消息。它可能是由于网络无法到达、主机无法到达、协议无法到达、端口无法到达等原因。</li><li><strong>源点抑制</strong>（Source Quench）：这是一种流控消息，用于请求发送方减少发送速度，现已废弃。</li><li><strong>重定向</strong>（Redirect Message）：告诉主机更改路由表，使用不同的路由器转发数据包。</li><li><strong>时间超过</strong>（Time Exceeded）：当数据包在网络中的生存时间（TTL）达到零时发送，用于防止数据包无限循环。</li><li><strong>参数问题</strong>（Parameter Problem）：指出数据包头部的某些字段不正确。</li><li><strong>时间戳请求/时间戳回复</strong>（Timestamp）：用于记录信息传递的时间，帮助同步网络上的时间。</li><li><strong>回显请求/回显应答</strong>（Echo Request and Echo Reply）：用于网络连通性测试，例如Ping命令。</li></ul><h1>NAT和NAPT</h1><p><strong>NAT（网络地址转换，Network Address Translation）</strong> 和 <strong>NAPT（网络地址端口转换，Network Address Port Translation）</strong> 是两种广泛使用的网络技术，它们通过修改经过设备的数据包中的IP地址和端口信息，以实现特定的网络管理目的，如IP地址节省、内网与外网的通信隔离和安全性增强。</p><h2 id="NAT">NAT</h2><p>NAT 主要用于将一个地址空间内的IP地址转换为另一个地址空间的IP地址，通常用于将私有（非全球唯一）IP地址转换为公有（全球唯一）IP地址。这种技术在家庭和企业网络中非常常见，用于连接到互联网的路由器上，允许多个设备共享一个或几个公网IP地址。</p><h3 id="基本工作原理：">基本工作原理：</h3><ol><li><strong>出站转换</strong>：当内网设备（使用私有IP）发送数据到互联网时，NAT设备会将数据包中的源私有IP地址替换为公网IP地址。目的地服务器看到的是这个公网IP地址。</li><li><strong>入站转换</strong>：对于返回的数据包，NAT设备查找之前建立的转换表，将目标地址从公网IP改回原始设备的私有IP地址，以确保数据包正确送达发送请求的内部设备。</li></ol><h2 id="NAPT-Network-Address-Port-Translation">NAPT (Network Address Port Translation)</h2><p>NAPT 是 NAT 的一种形式，通常称为端口地址转换（PAT）。NAPT 不仅转换IP地址，还转换数据包中的端口号，使多个设备可以共享单个IP地址。</p><h3 id="基本工作原理：-2">基本工作原理：</h3><ol><li><strong>出站数据包</strong>：当数据包从内部网络发出时，NAPT设备修改源IP地址和源端口号，数据包的源端口和IP组合会被替换为外部的公网IP和一个新的端口号。</li><li><strong>入站数据包</strong>：对于从外部返回的数据包，NAPT设备使用其维护的映射表找到对应的内部IP地址和端口号，将数据包的目的IP和端口转换回原始的内部网络地址和端口。</li></ol><h1>ARP</h1><p>地址解析协议（ARP）是一个用于解析网络层地址（如IPv4地址）为链路层地址（如以太网MAC地址）的关键网络协议。ARP操作主要发生在同一物理网络内或局域网（LAN）中。</p><h2 id="ARP的基本工作机制">ARP的基本工作机制</h2><p>关键词：<strong>ARP 表、广播问询、单播响应</strong></p><ol><li><strong>ARP查询过程</strong>：<ul><li>当主机A需要与同一局域网上的主机B通信，但不知道B的MAC地址时，A会在其ARP表中查找B的IP地址。</li><li>如果ARP表中没有相应记录，A会构造一个ARP请求数据包。这个数据包包含A的IP和MAC地址，以及B的IP地址，但B的MAC地址部分留空。</li><li>由于A不知道B的MAC地址，它会使用以太网的广播MAC地址（FF:FF:FF:FF:FF），将ARP请求包通过局域网广播给所有设备。</li></ul></li><li><strong>ARP响应过程</strong><ul><li>局域网内的所有设备接收到这个ARP请求，但只有IP地址匹配的设备（即B）会回应。</li><li>B检查ARP请求中的目标IP地址，发现与自己的IP地址相符，于是构造一个ARP响应数据包。这个响应包含B的IP地址和MAC地址，以及A的IP地址和接收到的A的MAC地址。</li><li>B将这个ARP响应包直接发送给A（单播），而不是广播到网络上。</li></ul></li><li><strong>ARP表的更新</strong>：<ul><li>当A接收到来自B的ARP响应后，A会在其ARP表中添加或更新一条记录，包括B的IP地址和对应的MAC地址。这条记录通常会在ARP表中保持一定时间（如20分钟），之后会被刷新。</li><li>同样，B在回应ARP请求时，也可能会在其ARP表中添加A的IP和MAC地址。</li></ul></li></ol><h2 id="不同局域网的通信">不同局域网的通信</h2><ul><li>如果A和B不在同一局域网内，ARP请求则不能直接到达B。在这种情况下，A需要通过一个路由器进行通信。</li><li>A会检查其路由表，找到到达B的IP地址所需的下一跳路由器的IP地址。</li><li>A将使用ARP来解析这个路由器的MAC地址（如果不在ARP表中的话），然后将数据发送到路由器。路由器在接收到数据后，将负责将数据转发到B所在的网络。</li><li>路由器在转发之前可能还需要进行自己的ARP过程，以解析B的MAC地址（如果B的MAC地址不在其ARP表中的话）。</li></ul><h1>补充</h1><h2 id="计算特定子网中可用的主机数量">计算特定子网中可用的主机数量</h2><p>在计算特定子网中可用的主机数量时，需要减去两个特定的地址：网络地址和广播地址。这两个地址在每个子网中具有特殊的用途，因此它们不能分配给单个主机作为其独立的IP地址。下面详细解释这两个地址的作用和为什么需要在主机数量计算中将它们排除：</p><h3 id="网络地址">网络地址</h3><p>网络地址是用来标识子网本身的，它是该子网中的第一个地址。在网络地址中，所有的主机位都设置为0。例如，如果子网掩码是255.255.255.0（或 /24），那么对于192.168.1.0/24这个子网，网络地址就是192.168.1.0。这个地址用于在网络层面上标识整个网络，而不是网络中的某个具体设备。</p><h3 id="广播地址">广播地址</h3><p>广播地址是子网中的最后一个地址，用于向子网内的所有设备发送数据。在广播地址中，所有的主机位都设置为1。继续使用上述例子，对于192.168.1.0/24这个子网，广播地址将是192.168.1.255。网络中的设备使用这个地址来发送广播消息，即向同一局域网中的所有设备发送数据。</p>]]></content>
    
    
    <summary type="html">计算机基础</summary>
    
    
    
    <category term="计算机基础" scheme="https://xlxq.fun/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机基础" scheme="https://xlxq.fun/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>从计算机网络角度看访问网页全过程</title>
    <link href="https://xlxq.fun/posts/a53d459c.html"/>
    <id>https://xlxq.fun/posts/a53d459c.html</id>
    <published>2024-07-10T11:18:02.000Z</published>
    <updated>2024-07-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>解析URL—生成HTTP请求消息</h1><p>url的组成部分：</p><ul><li><strong>协议</strong>： URL的开头是协议，它指定了如何访问资源。常见的协议包括 <code>http</code>（超文本传输协议）、<code>https</code>（安全的超文本传输协议）、<code>ftp</code>（文件传输协议）等。协议后跟冒号和两个斜杠，例如 <code>https://</code>。</li><li><strong>域名</strong>： 域名是资源所在服务器的网络地址。在URL中，域名紧跟在协议后面，例如 <code>www.example.com</code>。域名有时也包括子域名（如 <code>www</code>）。</li><li><strong>端口</strong>： 端口是可选的，位于域名之后，由冒号隔开。如果未指定，HTTP默认使用端口80，HTTPS默认使用端口443。例如 <code>https://www.example.com:443</code>。</li><li><strong>路径</strong>： 路径指定服务器上资源的具体位置。例如，在 <code>https://www.example.com/index.html</code> 中，<code>/index.html</code> 是路径，指向服务器上名为 <code>index.html</code> 的文件。</li><li><strong>查询字符串</strong>： 查询字符串（可选）开始于问号 <code>?</code>，后跟一个或多个参数，用于传递额外信息给服务器。例如， <code>https://www.example.com/search?q=example</code> 中的 <code>q=example</code> 是查询参数，用于搜索关键词。<br>对 <code>URL</code> 进行解析之后，浏览器确定了 Web 服务器和文件路径，接下来就是根据这些信息来生成 HTTP 请求消息了。</li></ul><h1>DNS解析获取IP</h1><p>通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 <code>Web</code> 服务器。<br>但在发送之前，还有一项工作需要完成，那就是<strong>查询服务器域名对应的 IP 地址</strong>，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。详见<a href="http://www.xlxq.fun/posts/48865a1.html">应用层协议详解</a></p><h1>TCP连接</h1><p>关于TCP报文格式以及其他详细介绍，见<a href="http://www.xlxq.fun/posts/82ec1c83.html">传输层协议详解</a><br>在 HTTP 传输数据之前，首先需要 TCP 建立连接，TCP 连接的建立，通常称为<a href="http://www.xlxq.fun/posts/f45a2f4a.html">三次握手</a></p><h1>ARP获取MAC</h1><p>ARP用于将IP地址解析为MAC地址，详细过程见<a href="http://www.xlxq.fun/posts/f28a47be.html">网络层协议详解</a></p><h1>HTTP 请求与响应</h1><h2 id="发送-HTTP-请求">发送 HTTP 请求</h2><ul><li><strong>构建请求报文</strong>：浏览器构建一个 HTTP 请求报文，包括请求行、请求头和请求体。<ul><li><strong>请求行</strong>：<code>GET / HTTP/1.1</code></li><li><strong>请求头</strong>：包含 Host、User-Agent、Accept 等信息。</li></ul></li><li><strong>发送请求</strong>：通过已建立的 TCP 连接，将 HTTP 请求发送到服务器。</li></ul><h2 id="服务器处理请求">服务器处理请求</h2><ul><li><strong>解析请求</strong>：服务器接收到 HTTP 请求后，解析请求行和请求头。</li><li><strong>生成响应</strong>：服务器根据请求内容，生成相应的 HTTP 响应报文，包括状态行、响应头和响应体。<ul><li><strong>状态行</strong>：<code>HTTP/1.1 200 OK</code></li><li><strong>响应头</strong>：包含 Content-Type、Content-Length 等信息。</li><li><strong>响应体</strong>：包含网页的 HTML 内容。</li></ul></li></ul><h2 id="发送-HTTP-响应">发送 HTTP 响应</h2><ul><li><strong>通过 TCP 连接</strong>：服务器将 HTTP 响应报文通过 TCP 连接发送回客户端。</li></ul><h1>浏览器渲染网页</h1><h2 id="解析-HTML">解析 HTML</h2><ul><li><strong>DOM 树</strong>：浏览器解析 HTML，生成 DOM（文档对象模型）树。</li><li><strong>CSSOM 树</strong>：解析 CSS，生成 CSSOM（CSS 对象模型）树。</li><li><strong>渲染树</strong>：结合 DOM 树和 CSSOM 树，生成渲染树。</li></ul><h2 id="布局与绘制">布局与绘制</h2><ul><li><strong>布局</strong>：计算每个元素的尺寸和位置。</li><li><strong>绘制</strong>：将渲染树的每个节点绘制到屏幕上。</li></ul><h2 id="处理资源">处理资源</h2><ul><li><strong>外部资源</strong>：浏览器遇到 <code>&lt;img&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;link&gt;</code> 等标签时，发送新的 HTTP 请求下载资源。</li><li><strong>异步请求</strong>：如果遇到 JavaScript 发起的异步请求（如 AJAX），则重复 DNS 解析、TCP 连接和 HTTP 请求过程。</li></ul><h1>TCP 连接断开</h1><p>TCP连接通过四次挥手断开<a href="http://www.xlxq.fun/posts/f45a2f4a.html">三次握手和四次挥手 | 星落溪桥</a></p>]]></content>
    
    
    <summary type="html">计算机基础</summary>
    
    
    
    <category term="计算机基础" scheme="https://xlxq.fun/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机基础" scheme="https://xlxq.fun/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络面试题总结</title>
    <link href="https://xlxq.fun/posts/5821aef2.html"/>
    <id>https://xlxq.fun/posts/5821aef2.html</id>
    <published>2024-07-10T11:18:02.000Z</published>
    <updated>2024-07-23T14:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要总结面试中常出现的计算机网络相关问题，仅作简要回答。</p><p><strong>OSI七层模型，TCP/IP模型，每层是干嘛的，有什么常见的协议</strong><br>应用,表示,会话,传输,网络,数据链路,物理<br>应用,传输,网络,网际接口<br>应用:http,smtp,pop3<br>传输:tcp,udp<br>网络:ip,icmp,arp,nat<br><strong>http的特点</strong><br>无状态,明文传输<br><strong>http为什么是无状态的，有什么好处</strong><br>http的报文不会保存用户的信息,减轻服务器的负担,更好处理并发<br><strong>可以用什么保持状态</strong><br><strong>cookie和session有什么区别</strong><br>cookie保存的数据较少,保存在浏览器,可以随报文在客户端和服务器端传递,持续时间较长<br>session可以基于保存在cookie中的sessionID获取用户信息,保存在服务器端,可以保存大量数据,但持续时间较短<br><strong>子网掩码的作用</strong><br>子网掩码是用于划分网络地址和主机地址的一个32位二进制数。<br>它与IP地址结合使用，用于确定一个IP地址中哪些位表示网络地址，哪些位表示主机地址。<br>子网掩码的作用主要有两个方面：</p><ol><li>确定网络地址：子网掩码通过将IP地址中的网络部分与主机部分进行分隔，将网络地址和主机地址进行划分。子网掩码中的1表示网络部分，0表示主机部分。通过与IP地址进行逻辑与运算，可以得到网络地址。</li><li>确定主机地址范围：子网掩码中的0表示主机部分，确定了主机地址的范围。主机地址范围是指在同一个网络中可以分配给主机的不同IP地址。子网掩码中主机部分的位数决定了主机地址的数量，可以根据主机地址范围来分配IP地址给不同的主机。保留两个地址：网络地址（表示整个子网）和广播地址<br>子网掩码的正确配置对于网络通信的正常运行非常重要。它可以帮助路由器和交换机等网络设备正确地识别网络地址和主机地址，实现数据的正确传输和路由。</li></ol><p><strong>https和http有什么区别</strong><br>https端口443,http80<br>https在http基础上采用了ssl/tls加密,数据在网络中不再明文传递,更加安全<br>https由于加密需要申请证书，并且消耗更多cpu和内存资源<br><strong>http的常见状态码</strong><br>1xx中间状态<br>2xx成功:200OK一切顺利,204NoContent处理成功但不返回任何数据<br>3xx:301Moved Permanently 永久重定向,302found临时重定向<br>4xx:客户端错误400badRequest:http请求有问题,401unauthorized未认证,403forbidden请求被禁止,404notFound请求的资源没找到<br>5xx:服务器状态异常:500internetServerError服务器出问题bug,502badGateway服务器返回错误响应<br><strong>http1.0短连接，http1.1长连接</strong><br>短连接:每次发送请求都进行一次TCP连接<br>长连接:一次TCP连接可以处理多次请求<br>流水线:不用等到服务器返回响应就可以继续发送下一次请求,有可能造成队头阻塞<br><strong>https的加密方式</strong><br><strong>对称加密和非对称加密</strong><br>在进行身份验证时进行非对称加密,后续数据传输进行对称加密<br>对称加密:加密方和解密方使用同一密钥,互相加解密<br>非对称加密:分为公钥和私钥,公钥可以随意发放,私钥自己留用，公钥可以解密私钥加密的数据,私钥可以解密公钥加密的数据<br><strong>https怎么保证对方可信</strong><br>服务器需要向CA机构获取认证证书,证书上有用机构的私钥加密的电子签名<br>认证阶段向对方发送认证证书,对方通过电子签名的公钥解析电子签名,确保对方被认证过<br><strong>http的常见请求方法</strong><br>GET:请求指定的资源<br>POST:向指定资源提交数据，进行处理<br>DELETE:请求服务器删除指定的资源<br>PUT:向指定资源位置上传最新内容<br><strong>GET和POST的区别</strong><br>GET用于获取资源,POST用于修改资源<br>GET请求参数位于url路径,明文显示,长度有限制,只支持askii编码<br>POST请求参数位于请求体,相对安全,理论上没有长度限制,支持多种编码形式(字段定义)<br><strong>GET请求为什么参数需要编码</strong><br>参数用的是key=value的形式,如果不编码,要是key或者value里面有类似=这样会引起歧义的字符,会无法解析或解析错误<br><strong>从输入网址到获得页面的过程</strong><br>浏览器解析url,通过dns解析获取ip<br>浏览器与服务器建立tcp<br>浏览器构建并发送http请求<br>服务器接收请求并处理<br>服务器返回响应<br>客户端解析获取相应的资源,解析并渲染获取页面<br>关闭tcp连接<br><strong>DNS协议，过程</strong><br>dns是基于udp,将域名解析获取对应服务器的ip的一种协议<br>通过dns服务器进行,分为根,顶级,权威,本地<br>dns解析式,依次查询浏览器缓存,本地dns服务器,如果找不到,<br>可以采用迭代或递归的方式访问根<br>迭代就是指路,依次访问根,顶级,权威返回给本地<br>递归就是根去访问顶级,权威,再逐级向上返回最后回到根再返回给本地<br>本地缓存后返回给浏览器ip<br><strong>IP地址和MAC地址</strong><br>IP地址是逻辑地址,是可以变化的;MAC地址是网卡制造商制造时赋予的全球唯一标记<br>IP地址32位,MAC地址48位(前24位由IEEE管理,后24位由网卡制造商分配保证不会重复)<br><strong>ARP</strong><br>地址解析协议:ARP 表、广播问询、单播响应<br>查询分组和响应分组,包含发送和接收的 IP 地址、发送和接收的 MAC 地址<br>(发送查询分组不知道对方的MAC地址,采用广播地址)<br>每台网络设备维护一个ARP表,A需要获取某台网络设备B的MAC地址时<br>先解析ip地址判断其是否与自己处在同一局域网下,如果是则直接采用广播地址向局域网中每一台设备发送查询分组,B收到该分组后会构造ARP响应分组定向发送给A,并在自己的ARP表中增加一条记录&lt;ip,mac,ttl&gt;(ttl一般是20分钟)<br>A收到后可以进行解析获取B的MAC地址,向自己的ARP表中增加一条记录<br>如果不在同一局域网下,则要先获取当前局域网中对方局域网的本子网接口路由器<br>通过该路由器中转一下,基本流程同上(路由器也是网络设备,有MAC)<br><strong>TCP，UDP区别</strong><br>TCP面向连接,保证可靠性,面向字节流,头部20字节，只支持一对一连接，有拥塞控制<br>UDP面向无连接，不保证可靠性，面向报文，头部8字节，支持各种连接<br><strong>TCP怎么保证可靠性</strong><br>数据包校验，失序数据包重排序，丢弃重复数据，应答机制，超时重发，流量控制<br><strong>TCP拥塞控制</strong><br>防止过多的数据注入网络，使网络中的路由器或链路过载<br>慢启动，拥塞避免，快重传，快恢复<br>从1开始指数增长，加法增大，收到三个重复确认时立即进行重传，并将拥塞窗口减小一半<br><strong>TCP流量控制</strong><br>发送方和接收方各自维护一个流量窗口，接收方的窗口大小取决于应用，系统，硬件的控制，发送方的窗口大小则取决于接收窗口。接收方可以通过发送含有window字段的确认报文来控制发送窗口的大小，影响发送的速率，防止发送和接收的速度不匹配导致数据丢失<br><strong>三次握手，四次挥手</strong><br>三次握手：<br>1.客户端发起连接请求生成随机起始序列号seq，标志位SYN=1，CLOSE—&gt;SYN_SENT<br>2.服务端生成确认号ack=seq+1，随机起始序列号seq，标志位SYN=1,ACK=1,LISTEN—&gt;SYN_RCVD<br>3.客户端收到响应，返回ACK=1，seq=ack，ack=seq+1，双方都进入ESTABLISHED<br>四次挥手：<br>1.A向B发送连接释放报文（FIN=1,seq），停止发送数据，进入FIN_WAIT_1<br>2.B收到后发送确认报文（ACK=1,ack,seq），进入CLOSED_WAIT，A—&gt;B连接释放<br>3.A收到B的确认报文，进入FIN_WAIT_2<br>4.B发送完数据，发送连接释放报文（FIN=1,ACK=1,seq，ack），进入LAST_ACK<br>5.A发送确认报文（ACK=1,seq，ack），进入TIME_WAIT，等待2MSL后关闭进入CLOSED<br>B收到确认报文后关闭，否则重传连接释放报文段<br><strong>为什么要等2MSL，MSL具体是多少</strong><br>保证A发送的最后一个ACK报文段一定能被B接收到<br>防止已失效的连接请求报文段重新出现在新的连接中（使本次请求产生的所有数据都消失在网络中）<br><strong>为什么不是两次握手</strong><br>防止已失效的连接请求报文段重新被接收到，导致服务器端一直处于连接无法关闭状态<br><strong>IP地址分类</strong><br>ABCDE:五类<br>0，10，110，1110，11110</p>]]></content>
    
    
    <summary type="html">持续更新...</summary>
    
    
    
    <category term="计算机基础" scheme="https://xlxq.fun/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机基础" scheme="https://xlxq.fun/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JFR(java flight recoder)</title>
    <link href="https://xlxq.fun/posts/faf12a24.html"/>
    <id>https://xlxq.fun/posts/faf12a24.html</id>
    <published>2024-04-05T11:18:02.000Z</published>
    <updated>2024-04-05T11:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1>什么是JFR</h1><p>Java Flight Recorder (JFR) 是 Java 虚拟机 (JVM) 中的一个事件记录器，它能够记录运行时的各种信息，如方法调用、垃圾回收、线程活动等，用于监控和调优 Java 应用程序的性能。使用 Java Flight Recorder，可以轻松地收集和分析应用程序在生产环境中的运行时信息，以便更好地理解应用程序的行为、性能瓶颈和潜在问题。它提供了丰富的事件类型，可以捕获各种级别的信息，从 JVM 内部的细节到应用程序级别的指标都可以覆盖。这些事件可以导出为 JFR 文件，然后可以使用 JMC 或其他工具对其进行分析。</p><h1>关键概念</h1><h2 id="事件">事件</h2><p>JFR 收集 Java 应用程序运行时 JVM 中发生的事件。这些事件与JVM本身的状态或者程序的状态有关。事件具有名称、时间戳和附加信息（如线程信息、执行堆栈和堆状态）。</p><p>JFR收集<strong>三种类型的事件</strong>：</p><ul><li><strong>即时事件</strong>一旦发生就会立即记录</li><li>如果持续时间超过指定阈值，则记录<strong>持续时间事件</strong></li><li><strong>样本事件</strong>用于对系统活动进行采样</li></ul><h2 id="数据流">数据流</h2><p>JFR 收集的事件包含大量数据。因此，JFR 的数据导出被设计为异步执行，不会妨碍程序。<br>JFR 将有关事件的数据保存在单个输出文件<code>Flight.jfr</code> 中。<br>众所周知，磁盘 I/O 操作的开销相当大。因此，JFR 在将数据块刷新到磁盘之前使用<strong>各种缓冲区</strong>来存储收集到的数据。由于在同一时刻，一个程序可能有多个具有不同选项的注册进程。因此，我们可能会在输出文件中发现比请求的数据更多的数据，或者可能不按时间顺序排列。但如果我们使用 JMC，我们甚至可能不会注意到这一事实，因为它按时间顺序可视化事件。<br><strong>在极少数情况下，JFR 可能无法刷新数据</strong>（例如，事件太多或停电时）。如果发生这种情况，JFR 会尝试通知我们输出文件可能缺少一段数据。</p><h1>特性</h1><p>JFR具有以下关键特性：</p><ol><li><strong>低开销的持续性能监控</strong>: JFR 可以在生产环境中以低开销的方式持续地监控 JVM 的性能，旨在<strong>尽可能少地影响正在运行的应用程序的性能</strong>。它通过轻量级的事件采集机制来收集数据，几乎不会对应用程序的性能产生影响。</li><li><strong>丰富的事件数据</strong>: JFR 可以收集丰富的事件数据，包括 CPU 使用情况、内存分配情况、线程活动、垃圾收集情况、锁竞争、I/O 操作等。基于事件采集可以分析非常底层的信息，例如对象分配，方法采样与热点方法定位与调用堆栈，安全点分析与锁占用时长与堆栈分析，GC 相关分析以及 JIT 编译器相关分析</li><li><strong>低延迟的数据记录</strong>: JFR 使用异步方式记录事件数据，因此几乎不会对应用程序的性能产生明显的影响。它能够以很低的延迟记录事件，即使在高负载的情况下也能保持高效率。</li><li><strong>动态配置</strong>: JFR 允许用户在运行时动态地配置数据采集和记录行为。可以通过 JFR 控制台或者命令行工具来启动、停止、配置和导出录制会话。</li><li><strong>完善的API定义</strong>：用户可以自定义事件生产与消费。</li></ol><h1>使用</h1><p>为了使用JFR，我们可以通过两种方式来激活它：</p><ol><li>当启动 Java 应用程序时，通过命令行传递参数启动</li><li>当 Java 应用程序已在运行时，传递jcmd工具的诊断命令<br>JFR停止收集后，可以获得本次收集的jfr文件，将该文件提供给可视化工具（例如JMC，<strong>Java Mission Control</strong>），就可以以直观的方式可视化有关事件的数据，从而准确分析程序的性能瓶颈</li></ol><h2 id="命令行启动">命令行启动</h2><p>使用javac将.java文件编译为.class文件后，可以使用以下命令启动JFR：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//<span class="type">path</span>-<span class="keyword">to</span>-<span class="keyword">class</span>-file 是应用程序的入口点_*.class_文件。</span><br><span class="line">java -XX:+UnlockCommercialFeatures -XX:+FlightRecorder </span><br><span class="line">  -XX:StartFlightRecording=duration=<span class="number">200</span>s,filename=flight.jfr <span class="type">path</span>-<span class="keyword">to</span>-<span class="keyword">class</span>-file</span><br></pre></td></tr></table></figure><p>此命令启动应用程序并激活JFR，记录立即开始，持续时间不超过 200 秒。收集的数据保存在输出文件 Flight.jfr 中。</p><h2 id="jcmd工具">jcmd工具</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jcmd &lt;pid|MainClass&gt; &lt;command&gt; [parameters]</span><br><span class="line">eg:  jcmd 1234 JFR.start <span class="attribute">duration</span>=100s <span class="attribute">filename</span>=flight.jfr</span><br></pre></td></tr></table></figure><p>&lt;command&gt;包括:</p><ul><li><strong>JFR.start</strong>  – 开始新的 JFR 录制</li><li><strong>JFR.check</strong>  – 检查正在运行的 JFR 记录</li><li><strong>JFR.stop</strong>  – 停止特定的 JFR 录制</li><li><strong>JFR.dump</strong>  – 将 JFR 记录的内容复制到文件<br>每个命令都有一系列参数,具体可参考<a href="https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/comline.htm#JFRUH190">Java Flight Recorded 官方文档</a>。</li></ul>]]></content>
    
    
    <summary type="html">JFR基本概念</summary>
    
    
    
    <category term="可观测" scheme="https://xlxq.fun/categories/%E5%8F%AF%E8%A7%82%E6%B5%8B/"/>
    
    
    <category term="可观测" scheme="https://xlxq.fun/tags/%E5%8F%AF%E8%A7%82%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>OpenTelemetry</title>
    <link href="https://xlxq.fun/posts/381cfacc.html"/>
    <id>https://xlxq.fun/posts/381cfacc.html</id>
    <published>2024-03-24T11:18:02.000Z</published>
    <updated>2024-03-24T11:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1>为什么需要OpenTelemetry</h1><ol><li><strong>分布式系统复杂性增加</strong>：随着云计算和微服务架构的普及，现代软件系统变得越来越复杂。在这样的系统中，一个请求可能会涉及多个服务和组件，跨越多个服务器和数据中心。因此，跟踪请求在系统中的路径和性能变得至关重要，以便定位和解决潜在的问题。</li><li><strong>缺乏标准化的跟踪和监控解决方案</strong>：过去，每个厂商或项目可能会使用自己的监控工具和方法，导致了监控数据的碎片化和不一致性。OpenTelemetry的出现（OpenTracing和OpenCensus合并而来）为开发人员提供了一个<strong>统一的标准</strong>，使得跨不同系统和语言的监控数据能够更加一致和可比较。</li><li><strong>提高系统的可观察性</strong>：可观察性是指<strong>对系统内部状态和行为的理解和监控程度</strong>。通过使用OpenTelemetry，开发人员可以更好地了解他们的系统在运行时的状态和行为，从而及时发现和解决潜在的问题，提高系统的可靠性和稳定性。</li></ol><h1>基本概念</h1><h2 id="可观测性">可观测性</h2><p>可观测性使我们能够通过提出关于某个系统的问题从外部了解该系统，而无需了解其内部工作方式，这需要应用程序能够发出<code>跟踪</code>，<code>日志</code>，<code>指标</code>等<code>信号</code>,以便我们能提出相关的问题</p><h3 id="日志（logs）">日志（logs）</h3><ol><li><strong>日志</strong>是由服务或其他组件发出的<strong>带时间戳的消息</strong>。</li><li>日志不一定与任何特定的用户请求或事务相关联，区别于跟踪。</li><li>它们几乎存在于软件的各个地方，并且过去被开发人员和操作员广泛依赖，以帮助他们理解系统行为。在 OpenTelemetry 中，任何不属于分布式追踪或度量的数据都被视为日志。例如，事件（Events）是一种特定类型的日志。日志通常包含详细的调试/诊断信息，例如操作的输入、操作的结果以及与该操作有关的任何支持性元数据。</li><li>通常缺乏上下文信息，需要作为span的一部分或与跟踪和跨度相关联时，才更好发挥作用。</li></ol><h3 id="跟踪（Distributed-Traces）">跟踪（Distributed Traces）</h3><ol><li>也称<strong>分布式跟踪</strong>，记录了请求（由应用程序或最终用户发起）在多服务架构中传播时所经过的路径，比如微服务和无服务器应用程序。</li><li>提高了我们应用程序或系统的健康状况的可见性，可以在分布式系统中确定性能问题的原因，或者调试在本地难以重现的行为</li><li>跟踪通过 <strong>分解请求在分布式系统中的传递过程</strong> 来便于调试和理解分布式系统</li><li>一个跟踪由一个或多个<strong>跨度</strong>组成。第一个跨度表示根跨度，每个根跨度表示从开始到结束的请求，更低层级的跨度提供了有关请求期间发生的更详细的上下文（或组成请求的步骤）的信息。</li></ol><h4 id="跨度（spans）">跨度（spans）</h4><p><strong>跨度</strong>跟踪请求所进行的具体操作，描绘了该操作执行期间发生了什么事情。包含名称、与时间相关的数据、结构化日志消息和其他元数据（即属性），以提供有关所跟踪操作的信息。如：</p><ol><li><strong>上下文（Context）</strong>：span 的上下文包括了<strong>唯一标识</strong>该 span 的 ID，以及与其他 span 之间<strong>建立关联所需的信息</strong>，比如父 span 的 ID、当前跟踪（trace）的 ID 等。</li><li><strong>属性（Attributes）</strong>：属性是键值对，用于描述 span 的<strong>特征和元数据信息</strong>。例如，可以记录 span 的名称、开始时间、持续时间、所属服务的名称、请求的 URL 等。属性通常用于标识和分类 span，以及提供有关 span 执行上下文的其他信息。</li><li><strong>事件（Events）</strong>：事件是与 span 相关的<strong>时间戳和描述性消息</strong>的组合。它们用于记录 span 执行期间发生的重要事件，比如函数调用、数据库查询、网络请求等。通过记录事件，可以了解 span 的执行流程，以及在执行过程中发生的具体操作。</li><li><strong>链接（Links）</strong>：链接用于<strong>建立 span 之间的关系</strong>，通常用于描述跨越服务边界的操作。一个 span 可能会链接到其他 span，以表示它们之间的逻辑关联。例如，如果一个 span 包含了对外部服务的调用，可能会在该 span 中添加链接指向被调用服务的 span，以建立两者之间的关系。</li><li><strong>状态（Status）</strong>：状态用于表示 <strong>span 的执行结果</strong>。例如，一个 span 可能被标记为成功、失败或者取消。状态信息可以帮助了解 span 的执行情况，以及可能存在的问题或异常。</li><li><strong>上下文传递（Context Propagation）</strong>：上下文传递是指在分布式系统中跨越服务边界传递 span 上下文的过程。这包括了在网络请求中传递 span ID 和跨度 ID，以便在服务之间建立关联，并跟踪整个请求的执行流程。</li><li><strong>种类（Span Kind）</strong>：可取值<code>Client</code>, <code>Server</code>, <code>Internal</code>, <code>Producer</code>, 或 <code>Consumer</code>，为跟踪后端提供了一个关于应该如何组装跟踪的提示。</li></ol><h4 id="上下文传播（Context-Propagation）">上下文传播（Context Propagation）</h4><p>上下文传播是实现分布式追踪的核心概念。有了上下文传播，可以将 spans 相互关联并组装成一个追踪，而不管 spans 是在哪里生成的。我们通过两个子概念来定义上下文传播：Context 和 Propagation。</p><ol><li><strong>Context（上下文）</strong> 是一个对象，它包含了发送和接收服务之间关联一个 span 所需的信息，并将其与整个追踪关联起来。例如，如果服务 A 调用服务 B，A创建的span中包含Trace ID和span ID，则B创建下一个span时，沿用该Trace ID，并且将自己的parent ID复制为A的span ID，表示当前创建的span的父级是A创建的span</li><li><strong>Propagation（传播）</strong> 是在服务和进程之间传递上下文的机制。它将上下文对象序列化或反序列化，并提供相关的追踪信息，以将其从一个服务传播到另一个服务中。</li></ol><h3 id="指标（metrics）">指标（metrics）</h3><ol><li><strong>指标</strong>是在运行时捕获的服务的<strong>度量</strong>，即可以用于观测应用程序运行状态的数据集。捕获度量的时刻被称为<strong>指标事件</strong>，它不仅包括度量本身，还包括捕获时的时间和关联的元数据。</li><li>应用程序和请求指标是可用性和性能的重要指标。自定义指标可以提供洞察力，了解可用性指标如何影响用户体验或业务。收集的数据可用于发出故障警报或在需求高峰时自动触发调度决策，以扩展部署规模。</li><li>组件：<br>    - Metric Provider：是<code>Meter</code>的工厂。在大多数应用程序中，Meter Provider只会初始化一次，其生命周期与应用程序的生命周期相匹配。<br>    - Meter创建指标工具<code>Metric Instruments</code><br>    - Metric Instrument用于捕获度量<code>Metric</code>，有多种类别，例如计数器，仪表盘，直方图等<br>    - Metric Exporter将度量数据发送给消费者。这个消费者可以是用于调试和开发时的标准输出，也可以是OpenTelemetry收集器或您选择的任何开源或供应商后端<br>    - 获取metric并发送给消费者的链路可描述如下：<code>Metric Provider---&gt;Meter---&gt;Metric Instruments---&gt;Metric---&gt;Metric Exporter---&gt;Consumer</code></li></ol><h3 id="行李（baggage）">行李（baggage）</h3><ol><li>Baggage 是 Span 之间传递的上下文信息。它是一个键值存储，与 Trace 中的 Span Context 一起驻留，使值可用于在该 Trace 中创建的任何 Span 。</li><li>Baggage区别于SpanContext：<br>    - Baggage允许将键值对数据（例如用户ID、会话ID等）附加到跨越多个服务的请求中，并在请求链中传递，通常用于传递与请求相关的元数据。相当于为其他信号（signals）提供了一个存储额外信息的容器。<br>    - Span Context是跨度（Span）之间传播的元数据的容器，用于将跨度连接起来形成请求链。由跨度创建和管理，一旦创建了 Span，它们就是不可变的。</li><li>Baggage存储在与当前上下文一起的 HTTP 标头中，会有被篡改或者泄露的风险，应该被用于可以公开的数据。</li></ol><h2 id="组件（Components）">组件（Components）</h2><h3 id="规范（Specification）">规范（Specification）</h3><ol><li><strong>API：</strong> 为生成和关联跟踪、度量和日志数据定义了数据类型和操作。</li><li><strong>SDK：</strong> 为 API 的特定语言实现定义了要求。此处还定义了配置、数据处理和导出的概念。</li><li><strong>数据：</strong> 定义了 OpenTelemetry 协议（<strong>OTLP</strong>）和供应商无关的语义约定， OpenTelemetry并不提供可视化和存储服务，规范数据格式约定可以满足数据在各后端存储供应商之间高效低成本的迁移等操作。</li></ol><h3 id="收集器（Collectors）">收集器（Collectors）</h3><ol><li>用于接收和处理来自应用程序的跟踪、度量和日志数据。</li><li>可以用于预处理、聚合、过滤和路由数据，然后将其导出到配置的一个或多个后端系统。</li></ol><h3 id="K8s-运算符">K8s 运算符</h3><p>OpenTelemetry 运算符是 Kubernetes 运算符的一种实现。该运算符管理 OpenTelemetry 收集器，并使用 OpenTelemetry 对工作负载进行自动仪表化。</p><h3 id="函数即服务资产">函数即服务资产</h3><p>OpenTelemetry 支持不同云供应商提供的监控函数即服务的各种方法。OpenTelemetry 社区目前提供了预构建的 Lambda layer，能够自动仪表化您的应用程序，还提供了用于手动或自动仪表化应用程序时可以使用的独立 Collector Lambda layer。</p><h3 id="特定语言的-API-SDK-实现">特定语言的 API &amp; SDK 实现</h3><ol><li><strong>仪表库（Instrumentation Libraries）</strong>：<br>    - 这些库用于在特定编程语言的应用程序中自动或手动地集成分布式追踪、度量和日志记录功能。它们提供了针对特定语言和框架的 API 和工具，使开发人员能够轻松地将追踪和监视功能集成到他们的应用程序中。</li><li><strong>导出器（Exporters）</strong>：<br>    - 针对特定语言的 SDK 实现通常会包括用于将收集的跟踪、度量和日志数据导出到后端存储和分析系统的导出器。这些导出器可以与特定语言的常见后端系统集成，如数据存储、监控系统等。</li><li><strong>自动仪表化（Automatic Instrumentation）</strong>：<br>    - 一些特定语言的 SDK 实现可能会提供自动仪表化功能，这使得开发人员可以轻松地自动检测和仪表化应用程序的组件，无需手动添加代码。</li><li><strong>资源探测器（Resource Detectors）</strong>：<br>    - 这些组件用于自动发现和识别运行应用程序的环境和基础设施，以帮助收集有关应用程序的上下文信息。它们可以帮助开发人员更好地理解和监视他们的应用程序在不同环境中的运行情况。</li><li><strong>跨服务传播器（Cross-Service Propagators）</strong>：<br>    - 特定语言的 SDK 实现可能会包括用于在分布式系统中传播跟踪上下文的传播器，以确保请求链中的所有跨度都与同一跟踪相关联。</li><li><strong>采样器（Samplers）</strong>：<br>    - 一些特定语言的 SDK 实现可能会包括采样器，用于控制跟踪数据的收集率，以确保系统在大规模部署时能够有效地处理和存储跟踪数据。</li></ol><h2 id="资源">资源</h2><ol><li>资源（Resource）是描述应用程序、服务或系统的特性和属性的实体。</li><li>资源提供了有关应用程序运行环境的关键信息，如应用程序的名称、版本、运行环境、部署位置等。</li><li>资源通常是与跟踪、度量和日志记录等监视数据相关联的一部分。</li></ol><h2 id="采样">采样</h2><ol><li>分布式跟踪很多时候并不需要跟踪所有的请求流程，甚至很大一部分的成功请求对分析系统中潜在的问题并没有什么实际作用，因此并不总是需要大量的数据来获得正确的洞察力，而只需要正确的或者说可能有用的数据样本。</li><li>采样的核心思想是控制发送到可观察性后端的跨度，以降低摄取成本。</li><li>常见的采样方法有首部采样和尾部采样。对于某些系统，尾部采样可能与首部采样一起使用，以保护遥测流程免受过载的影响。</li></ol><h3 id="首部采样">首部采样</h3><ol><li>首部采样是一种在请求链的开始阶段进行的采样方法。当请求进入系统时，采样器会决定是否记录该请求的起始跨度。如果采样器决定记录起始跨度，则整个请求链路上的所有跨度都会被记录。如果采样器决定不记录起始跨度，则整个请求链路上的跨度都不会被记录。</li><li>首部采样的优点是简单高效，可以有效地减少跟踪数据的生成量。但是，它可能会导致某些请求的完整跟踪数据丢失，从而降低了跟踪数据的完整性。</li></ol><h3 id="尾部采样">尾部采样</h3><ol><li>尾部采样是一种在请求链的结束阶段进行的采样方法。当请求完成时，采样器会根据请求的特性和其他因素决定是否记录该请求的终止跨度。如果采样器决定记录终止跨度，则整个请求链路上的所有跨度都会被记录。如果采样器决定不记录终止跨度，则整个请求链路上的跨度都不会被记录。</li><li>尾部采样的优点是可以根据请求的实际情况和性能特征进行决策，从而更好地控制跟踪数据的生成率。但是，由于需要等待请求完成，因此尾部采样可能会导致一些延迟，并且在某些情况下可能无法获得完整的跟踪数据。并且，因为系统的复杂性等原因需要频繁调整采样策略，可能很难实现。</li></ol><h2 id="仪表范围">仪表范围</h2><p>仪表范围在 OpenTelemetry 中的作用是定义了遥测数据的上下文和关联。它是应用代码中的逻辑单元，与发出的遥测数据相关联，也就是定义了数据（信号）的来源等相关信息</p><ol><li>在应用程序代码中，可以选择模块、包或类作为仪表范围</li><li>对于库或框架，可以使用唯一的标识符作为仪表范围，例如库或框架的完全限定名称和版本</li><li>从提供者获取跟踪器（Tracer）、计量器（Meter）或记录器（Logger）实例时，通常会为仪表范围定义一个名称和版本对。创建的每个跨度（span）、指标（metric）或日志记录（log record）都会与提供的仪表范围相关联。</li><li>使用仪表范围，可以将遥测数据进行切片和切割，以便在可观测性后端中更好地理解和分析应用程序的行为和性能。例如，可以查看特定库版本的性能指标，或者将问题定位到应用程序的特定模块。</li></ol>]]></content>
    
    
    <summary type="html">基本概念</summary>
    
    
    
    <category term="可观测" scheme="https://xlxq.fun/categories/%E5%8F%AF%E8%A7%82%E6%B5%8B/"/>
    
    
    <category term="可观测" scheme="https://xlxq.fun/tags/%E5%8F%AF%E8%A7%82%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>async-profiler</title>
    <link href="https://xlxq.fun/posts/5afb4600.html"/>
    <id>https://xlxq.fun/posts/5afb4600.html</id>
    <published>2024-03-24T11:18:02.000Z</published>
    <updated>2024-03-24T11:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1>什么是Async-profiler</h1><p>Async-profiler是一个针对Java的低开销采样分析器，它没有受到Safepoint Bias问题（只能在SafePoint处进行采样，可能导致一些代码无法被采样）的影响。该分析器利用了HotSpot特有的一系列API来收集堆栈跟踪信息，并追踪Java堆中的内存分配情况。async-profiler适用于OpenJDK以及其他基于HotSpot JVM的Java运行环境。</p><p>async-profiler能够追踪以下类型的事件：</p><ul><li>CPU周期</li><li>硬件和软件性能计数器，例如缓存未命中、分支未命中、页面错误、上下文切换等</li><li>Java堆中的内存分配</li><li>对于互斥锁的竞争尝试，包括Java对象监视器和ReentrantLocks（可重入锁）</li></ul><p>由于其实现依赖于特定操作系统的底层性能监控接口和技术，目前只支持linux和mac系统。</p><h1>使用方法</h1><p>async-profiler 是基于 JVMTI(JVM tool interface) 开发的 Agent，支持两种启动方式（建议OpenJDK11及以上）：</p><ol><li>跟随 Java 进程启动，自动载入共享库；</li><li>程序运行时通过 attach api 动态载入。</li></ol><h2 id="分析已经在运行的程序">分析已经在运行的程序</h2><ol><li>下载压缩包（如果在caster容器中，应该使用对应的架构版本x64），并解压缩</li><li>启动一个java程序，使用<code>jps -l</code>命令获取pid</li><li>命令+操作+参数+PID，示例./profiler.sh start -d 30 -f profile.html 3456</li><li>有时运行脚本时会遇到权限问题，可以根据提示使用–all-user选项</li></ol><p>操作：</p><ul><li>start：启动性能分析并立即返回(停止后数据会打印在控制台)。</li><li>resume：恢复性能分析而不重置已收集的数据。</li><li>stop：停止性能分析。</li><li>dump：转储已收集的数据，而不停止性能分析会话。</li><li>check：检查目标JVM是否支持指定的性能分析事件。</li><li>status：打印性能分析状态(输出示例：<code>Profiling is running for 2 seconds</code>)。</li><li>meminfo：打印分析器的内存统计信息。</li><li>list：列出目标JVM支持的所有性能分析事件。</li><li>collect：按照指定的时间段（默认60s）收集性能分析数据，之后自动停止（这是默认操作）。<br>参数：</li><li>-e event：指定性能分析事件类型，如：cpu、alloc、lock、cache-misses等。（默认是cpu，如果需要同时分析多种事件类型，需要通过-f指定输出格式为jfr，例：./profiler.sh -e cpu,alloc -f profiler.jfr &lt;pid&gt;)</li><li>-d duration：持续分析指定秒数。</li><li>-f filename：将分析结果输出到指定文件。（推荐html格式，最新版已经不支持svg）</li><li>-i interval：采样间隔，单位为纳秒。</li><li>-j jstackdepth：最大Java堆栈深度。默认值为 2048。</li><li>-L level:- 日志级别：<code>debug</code>、<code>info</code>、<code>warn</code>、<code>error</code>或<code>none</code></li><li>-t：单独分析不同的线程。</li><li>-s：使用简单类名代替全限定类名（FQN）。</li><li>-g：打印方法签名。</li><li>-a：为Java方法添加注释。</li><li>-l：在输出前加上库名称。</li><li>-o fmt： 指定分析结束时要转储的输出格式：flat（扁平化）、traces（踪迹）、collapsed（折叠）、flamegraph（火焰图）、tree（树状图）、jfr（JFR格式）。</li><li>-I include：仅输出包含指定模式的堆栈跟踪。</li><li>-X exclude：排除包含指定模式的堆栈跟踪。</li><li>-v, --version：显示版本信息。<br>其它高级选项：</li><li>–title string：为火焰图设置标题。</li><li>–total: 计算所收集指标的总值而不是样本数量，例如总分配大小。</li><li>–minwidth pct：忽略小于指定百分比宽度的帧。</li><li>–reverse：生成反向堆叠的火焰图或调用树。</li><li>–loop &lt;time&gt;：按指定时间循环运行分析器。示例<code>loop 1h</code>。</li><li>–alloc &lt;bytes&gt;：分配分析间隔，默认单位为字节，可以指定500k，2m等，例如，如果使用<code>--alloc 500k</code>，那么平均而言，每分配500KB的内存，就会采集一次样本数据。</li><li>–live：仅从活动对象构建分配分析。</li><li>–lock &lt;duration&gt;：锁分析阈值，默认单位为纳秒。示例<code>lock 10ms</code>。</li><li>–total：累计总值（如时间、字节数等）。</li><li>–all-user：仅包括用户模式事件。</li><li>–sched：按调度策略分组线程。</li><li>–cstack mode：C栈遍历方式：fp（帧指针）、dwarf（DWARF调试信息）、lbr（分支日志记录）、no（不遍历）。</li><li>–begin function：当指定函数执行时开始性能分析。</li><li>–end function：当指定函数执行时结束性能分析。</li><li>–ttsp：执行至安全点的时间分析。</li><li>–jfrsync config：与JFR录制同步分析器。</li><li>–lib path：容器中libasyncProfiler.so的完整路径。</li><li>–fdtransfer：使用fdtransfer服务来自非特权目标的perf请求。<br>示例：</li><li>./profiler.sh -d 30 -f profile.html 3456</li><li>./profiler.sh start -i 999000 jps</li><li>./profiler.sh stop -o flat jps</li><li>./profiler.sh -d 5 -e alloc MyAppName<br><code>&lt;pid&gt;</code> 表示目标JVM的数字进程ID，也可以是关键字“jps”，用于自动查找正在运行的JVM，或者是指定应用程序的名字，该名字会在<code>jps</code>工具中出现。</li></ul><h2 id="跟随-Java-进程启动">跟随 Java 进程启动</h2><p>如果需要在 JVM 启动后立即分析一些代码，而不是使用 <code>profiler.sh</code> 脚本，可以在命令行加上<code>async-profiler</code>作为代理。例如：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -agentpath:async-<span class="keyword">profiler</span>-2.9/build/libasyncProfiler.<span class="keyword">so</span>=start,event=alloc,<span class="keyword">file</span>=profile.html -jar ...</span><br></pre></td></tr></table></figure><p>参数说明：</p><ol><li><code>agentpath:path-to-library</code>: 这是JVM的一个参数，指定了代理库（Profiler库）的路径</li><li><code>parameters</code>: 传递给async-profiler的参数，多个参数之间用逗号分隔，没有空格<ul><li><code>start</code>: 表示启动async-profiler。</li><li><code>event=alloc</code>: 设置分析事件为内存分配（allocation）。async-profiler支持多种事件，如CPU、锁、线程状态变化、内存分配等。</li><li><code>file=profile.html</code>: 将分析结果输出到指定的HTML文件，这里表示输出到名为<code>profile.html</code>的文件，生成的结果通常是一个交互式的火焰图。</li></ul></li></ol><h2 id="火焰图">火焰图</h2><h3 id="特征">特征</h3><p>火焰图有以下特征（这里以 on-cpu 火焰图为例）：</p><ul><li>每一列代表一个调用栈，每一个格子代表一个函数</li><li>纵轴展示了栈的深度，按照调用关系从下到上排列。最顶上格子代表采样时正在占用 cpu 的函数。</li><li>横轴的意义是指：火焰图将采集的多个调用栈信息，通过按字母横向排序的方式将众多信息聚合在一起，需要关注的不是格子间的相对位置，而是每个格子的宽度，宽度代表其在采样中出现频率，所以一个格子的宽度越大，说明对应函数运行的时间较长，它是瓶颈原因的可能性就越大。</li><li>火焰图格子的颜色是随机的暖色调，方便区分各个调用信息，但颜色本身没有意义。</li><li>其他的采样方式也可以使用火焰图， on-cpu 火焰图横轴是指 cpu 占用时间，off-cpu 火焰图横轴则代表阻塞时间。</li></ul><h3 id="类型">类型</h3><img src="/post-img/Pasted image 20240407152358.png" alt="图片损坏" style="zoom:100%;" /><h1>原理</h1><h2 id="CPU-Profiling的两种实现方式">CPU Profiling的两种实现方式</h2><h3 id="Instrumentation">Instrumentation</h3><p>仪器化是一种主动的性能分析方法，它通过修改应用程序的字节码或插入额外的代码来收集性能数据。在仪器化过程中，开发人员可以向应用程序中插入特定的监控代码或调试代码，用于收集各种性能指标或调试信息。这种方法可以实现更精细的性能分析和调试功能。<br>特点：</p><ul><li>精确度：仪器化可以精确地控制收集性能数据的位置和时机，因此可以捕获更详细和准确的性能信息。</li><li>高定制性：由于可以修改应用程序的字节码或插入自定义的代码，所以仪器化具有很高的定制性，可以根据需要实现各种特定的性能分析和调试功能。</li><li>开销较大：由于需要修改应用程序的代码或字节码（JVM层面的AOP），仪器化的过程会增加应用程序的运行开销，可能会对应用程序的性能产生一定的影响。</li></ul><h3 id="Sampling">Sampling</h3><p>采样是一种被动的性能分析方法，它通过在应用程序运行过程中获取当前执行位置的信息，定期检查程序的状态，并记录下当前的堆栈信息，以了解程序在执行时所处的上下文。这些采样数据可以用于分析应用程序的性能瓶颈和调优。<br>特点：</p><ul><li>低开销：采样过程中对应用程序的执行影响较小，因为采样器只是周期性地对调用栈进行采样，而不会修改程序的执行流程。</li><li>部分覆盖：由于采样是周期性的，所以不能完全覆盖应用程序的所有执行路径，可能会错过某些关键路径或短暂的性能瓶颈。</li><li>实时性：采样数据可以实时地反映应用程序的执行情况，但由于采样间隔的存在，以及JVM固有的只能在安全点（Safe Point）进行采样的“缺陷”，会导致统计结果存在一定的偏差，可能无法捕获瞬时的性能问题，如果把采样周期减小，可能可以缓解该问题，但会造成性能开销骤增。</li></ul><h3 id="两种方式对比">两种方式对比</h3><p>这两种实现技术并没有非常明显的高下之判，只有在分场景讨论下才有意义。Sampling由于低开销的特性，更适合用在CPU密集型的应用中，以及不可接受大量性能开销的线上服务中。而Instrumentation则更适合用在I/O密集的应用中、对性能开销不敏感以及确实需要精确统计的场景中。</p><h2 id="Async-profiler原理">Async-profiler原理</h2><p>Async Profiler 的原理是在目标应用程序的进程中注入一个动态链接库，该库使用 Perf 事件子系统来收集 CPU 活动数据。与传统的基于采样的分析器不同，Async Profiler 通过异步采样来避免对目标应用程序的性能造成过大的影响。</p><h3 id="动态链接">动态链接</h3><p>动态链接是HotSpot提供的一种特殊能力，它允许一个进程向另一个运行中的JVM进程发送一些命令并执行，命令并不限于加载Agent，还包括Dump内存、Dump线程等等。在 Async Profiler 中，动态链接库是指被注入到目标应用程序进程中的二进制文件，这个动态链接库负责收集应用程序的性能数据，包括 CPU 活动、函数调用堆栈等信息，并将这些数据传输给 Profiler，以便进行性能分析。通过注入动态链接库，Async Profiler 可以监控目标应用程序的执行情况，而无需修改或重新编译目标应用程序的源代码。</p><h3 id="Perf事件子系统">Perf事件子系统</h3><p>Perf 事件子系统是 Linux 内核提供的性能事件采集框架，它允许用户空间工具收集各种硬件和软件事件的性能数据，包括 CPU 指令、缓存访问、分支预测等。Async Profiler 利用 Perf 事件子系统来收集 CPU 活动数据，例如指令执行、缓存失效、分支预测等，并将这些数据用于性能分析。通过 Perf 事件子系统，Async Profiler 能够在低开销的情况下捕获目标应用程序的性能数据，而不会对应用程序的执行性能产生显著的影响。</p><h3 id="异步采样">异步采样</h3><p>异步采样是 Async Profiler 的核心特性之一，它与传统的基于采样的分析器不同。</p><ul><li>在传统的基于采样的分析器中，分析器定期中断目标应用程序的执行，然后获取当前执行位置的堆栈信息。这种方式可能会影响应用程序的性能，并导致分析结果不准确。</li><li>在 Async Profiler 中，采样是异步进行的，即采样操作与目标应用程序的执行是独立的（在另一个线程中采集 CPU 活动数据，并将数据存储到内存中）。采样线程的数量可以通过参数进行配置，以便更好地适应不同的 CPU 架构和应用程序负载。当分析结束时，Async Profiler 将采集到的数据导出到一个文件中，并使用 Flame Graph 等可视化工具将数据转换为易于理解的图形化形式。</li><li>java中，异步采样依赖方法AsyncGetCallTrace，它是 Java HotSpot VM 中用于异步获取 Java 线程的调用堆栈信息的技术。它是一种非阻塞的方法，用于在 Java 虚拟机内部获取线程的堆栈跟踪信息，而不会阻塞线程的执行。</li></ul><h1>性能开销</h1><p>async-profiler的设计目标是尽可能降低对被分析程序的影响，尤其是在CPU开销方面。由于async-profiler采用异步采样的方式，并且直接利用HotSpot JVM的内置接口，它的CPU开销通常是非常小的；Latency（延迟），async-profiler通过精准的采样技术，理论上不会直接影响应用程序本身的响应时间或延迟。然而，如果配置的采样频率过高，理论上有可能造成微小的延迟增加，但正常配置下，这种影响也应该是微乎其微的；内存消耗方面，async-profiler在运行过程中会占用一定的内存来存储采样数据和相关结构，具体内存消耗取决于配置的采样类型和持续时间，以及应用程序本身的复杂度（如方法数量）。</p>]]></content>
    
    
    <summary type="html">async-profiler的简介，基本使用和性能开销</summary>
    
    
    
    <category term="可观测" scheme="https://xlxq.fun/categories/%E5%8F%AF%E8%A7%82%E6%B5%8B/"/>
    
    
    <category term="可观测" scheme="https://xlxq.fun/tags/%E5%8F%AF%E8%A7%82%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>Spring核心：IOC和AOP</title>
    <link href="https://xlxq.fun/posts/97c27ed6.html"/>
    <id>https://xlxq.fun/posts/97c27ed6.html</id>
    <published>2024-03-12T10:19:03.000Z</published>
    <updated>2024-03-12T10:19:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1>IOC</h1><h2 id="IOC的概念和原理">IOC的概念和原理</h2><p>IOC（Inversion of Control），即控制反转，把对象的创建、初始化、销毁（即对象的生命周期，称为bean，参考<a href="https://www.xlxq.fun/posts/48c92662.html">Bean的生命周期</a> ）交给 Spring 来管理，而不是由开发者控制，实现控制反转。IOC 思想基于 IOC 容器完成，IOC 容器底层就是对象工厂（BeanFactory 接口）。IOC的原理是基于xml解析、工厂设计模式、反射实现的，通过将控制权从程序内部转移到外部来降低组件之间的耦合度，提高代码的可维护性和可测试性。具体来说，IOC 的原理包括以下几个方面：</p><ol><li><strong>控制反转</strong>：传统的程序中，对象的创建和管理由程序内部控制，而采用IOC 的方式，控制权被反转到外部，由框架或容器来管理对象的创建和生命周期。这样做可以减少组件之间的直接依赖关系，提高灵活性和可扩展性。</li><li><strong>依赖注入</strong>：依赖注入是IOC 的一种实现方式，它通过将对象的依赖关系从对象内部移动到外部容器中，在对象创建时将依赖关系注入到对象中。这样做可以使得对象更加灵活，易于测试和替换。</li><li><strong>解耦</strong>：IOC 的主要目的之一是降低组件之间的耦合度，使得组件之间的依赖关系更加松散。这样做可以提高系统的灵活性和可维护性，降低修改一个组件对其他组件的影响。</li><li><strong>配置化</strong>：采用IOC 的方式可以将程序的配置信息从代码中抽离出来，以配置文件或注解的方式进行管理。这样做可以使得系统的配置更加灵活，方便进行修改和扩展。</li></ol><h2 id="IOC-容器实现的两种方式">IOC 容器实现的两种方式</h2><h3 id="BeanFactory">BeanFactory</h3><ol><li>BeanFactory 是 Spring 框架的核心接口之一，它是一个工厂模式的实现，负责管理和创建 Bean 实例。</li><li>BeanFactory 采用延迟初始化策略，也就是说，在<strong>调用 getBean() 方法获取 Bean 实例时</strong>才会进行实例化。</li><li>BeanFactory 提供了基本的 Bean 容器功能，包括 Bean 的实例化、依赖注入、生命周期管理等，但是它的功能相对较少，主要用于低层次的 Bean 容器功能。</li></ol><h3 id="ApplicationContext">ApplicationContext</h3><ol><li>ApplicationContext 是 BeanFactory 的子接口之一，它在 BeanFactory 的基础上进行了扩展，提供了更多的功能，比如<strong>事件发布、AOP 支持、资源加载</strong>等。</li><li>ApplicationContext 采用预先实例化的策略，也就是说，在<strong>容器启动时</strong>就会预先实例化所有的 Bean，而不是等到调用 getBean() 方法时才进行实例化。</li><li>ApplicationContext 是一个更加高级的容器，通常在实际项目中更为常用。</li></ol><h2 id="IOC-操作-Bean-管理">IOC 操作 Bean 管理</h2><p>IOC操作Bean管理有两种形式，一种是基于xml方式，另一种是基于注解方式。</p><ol><li><strong>基于 XML 配置</strong>：<ul><li>在基于 XML 的方式中，我们通过在 Spring 的配置文件（通常是applicationContext.xml）中使用 <code>&lt;bean&gt;</code>、<code>&lt;property&gt;</code> 等标签来定义和配置 Bean。</li><li>这种方式需要在 XML 文件中显式地配置每一个 Bean 及其属性，较为传统且繁琐，但是在某些情况下更加直观和可控。</li></ul></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserService&quot;</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br></pre></td></tr></table></figure><ol start="2"><li><strong>基于注解方式</strong>：<ul><li>在基于注解的方式中，我们可以使用 <code>@Component</code>、<code>@Service</code>、<code>@Controller</code>、<code>@Repository</code> 等注解来标识一个类为 Bean，并通过 <code>@Autowired</code> 注解来实现依赖注入。</li><li>这种方式使得 Bean 的配置更加简洁和灵活，同时也更加符合现代开发的趋势。Spring 在启动时会自动扫描带有这些注解的类，并将其注册为 Bean。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;     </span><br><span class="line"><span class="meta">@Autowired</span>     </span><br><span class="line"><span class="keyword">private</span> UserDao userDao;     </span><br><span class="line"><span class="comment">// 其他方法 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>AOP</h1><p>AOP（Aspect-Oriented Programming，面向切面编程）是一种编程范式，旨在通过将横切关注点（cross-cutting concerns）与核心业务逻辑分离，来提高代码的模块化和可维护性。<br>在传统的面向对象编程中，我们将功能按照业务逻辑划分为不同的对象和方法，但是有些功能并不属于特定的业务逻辑，而是横跨多个对象和方法的，比如日志、事务管理、安全性控制等。这些横切关注点会使得代码中充斥着重复的代码和混乱的逻辑，导致代码难以理解、维护和测试。AOP 的核心思想是将这些横切关注点抽象成一个单独的模块，称为切面（Aspect），然后通过在特定的切点（Join Point）上织入这些切面，从而将横切关注点与核心业务逻辑分离开来。在 AOP 中，切面可以理解为横跨多个对象和方法的代码片段，而切点则是确定在哪些位置应用这些切面的规则。</p><h2 id="AOP实现方式">AOP实现方式</h2><p>AOP底层是使用动态代理来实现的，这里有两种情况的动态代理：</p><ol><li>有接口的情况，使用 JDK 动态代理，即创建接口实现类代理对象，增强类的方法。</li><li>没有接口的情况，使用 CGLIB 动态代理，即创建子类的代理对象，增强类的方法。</li><li>详细的关于代理模式的分析和介绍，请转  <a href="https://www.xlxq.fun/posts/7b510e10.html">代理模式</a></li></ol><h2 id="AOP相关概念">AOP相关概念</h2><ol><li>连接点：类里面可以被增强的方法，这些方法被称为连接点。</li><li>切入点：实际被真正增强的方法，称为切入点。</li><li>通知（增强）：<ul><li>实际增强的逻辑部分称为通知（增强）</li><li>通知有多种类型：前置通知、后置通知、环绕通知、异常通知、最终通知</li></ul></li><li>切面：把通知应用到切入点的过程，称为切面。</li></ol><h2 id="AOP使用示例">AOP使用示例</h2><p>以下是一个简单的 Spring AOP 示例，演示了如何使用 AOP 实现日志记录功能：<br>假设有一个接口 <code>Calculator</code>，其中包含了两个方法 <code>add()</code> 和 <code>subtract()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Calculator</span> &#123;     </span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;     </span><br><span class="line"><span class="type">int</span> <span class="title function_">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后有一个实现类 <code>CalculatorImpl</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorImpl</span> <span class="keyword">implements</span> <span class="title class_">Calculator</span> &#123;     </span><br><span class="line"><span class="meta">@Override</span>     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;   <span class="keyword">return</span> a + b;   &#125;     </span><br><span class="line"><span class="meta">@Override</span>     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;  <span class="keyword">return</span> a - b;   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要在调用这些方法时记录日志，可以使用 AOP 实现。首先定义一个切面类 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect; </span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before; </span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;  </span><br><span class="line"><span class="meta">@Aspect</span> </span><br><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;      </span><br><span class="line"><span class="meta">@Before(&quot;execution(* com.example.Calculator.*(..))&quot;)</span>     </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logBeforeMethodExecution</span><span class="params">()</span> &#123;  </span><br><span class="line">System.out.println(<span class="string">&quot;LoggingAspect: Method is being executed.&quot;</span>);     </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的切面中，使用了 <code>@Aspect</code> 注解来标识这是一个切面类，然后使用 <code>@Before</code> 注解来定义切点表达式，表示在执行 <code>Calculator</code> 接口中的任何方法之前都会执行 <code>logBeforeMethodExecution()</code> 方法。<br>接下来，我们需要配置 Spring 容器以启用 AOP，可以创建一个配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean; </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan; </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration; </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;  <span class="meta">@Configuration</span> </span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.example&quot;)</span> </span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;      </span><br><span class="line"><span class="meta">@Bean</span>     </span><br><span class="line"><span class="keyword">public</span> Calculator <span class="title function_">calculator</span><span class="params">()</span> &#123;         </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CalculatorImpl</span>();     </span><br><span class="line">&#125;      </span><br><span class="line"><span class="meta">@Bean</span>     </span><br><span class="line"><span class="keyword">public</span> LoggingAspect <span class="title function_">loggingAspect</span><span class="params">()</span> &#123;         </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoggingAspect</span>();     </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的配置类中，使用 <code>@EnableAspectJAutoProxy</code> 注解启用了 Spring 的 AspectJ 自动代理功能，从而使得切面能够生效。</p>]]></content>
    
    
    <summary type="html">IOC和AOP</summary>
    
    
    
    <category term="框架" scheme="https://xlxq.fun/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Spring" scheme="https://xlxq.fun/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Bean的生命周期</title>
    <link href="https://xlxq.fun/posts/48c92662.html"/>
    <id>https://xlxq.fun/posts/48c92662.html</id>
    <published>2024-03-09T10:19:03.000Z</published>
    <updated>2024-03-09T10:19:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Bean的作用域</h1><p>一般来说，普通的java对象的生命周期可以如下描述：</p><ul><li>（类加载）—&gt;实例化</li><li>对象不再被使用时通过垃圾回收机制进行回收<br>而Bean，也不过是spring通过IOC容器管理的一些特殊的对象，Bean的作用域有以下几种（可以用@Scope注解指定）：</li></ul><ol><li>单例（singleton）在整个应用中只创建一个 Bean 实例</li><li>原型（prototype）每次请求时都创建一个新的 Bean 实例</li><li>请求（request）一次 HTTP 请求中，创建一个 Bean 实例</li><li>会话（session）用户会话中创建一个 Bean 实例</li><li>全局会话（Global Session ）类似于 Session 作用域，但用于 Portlet 环境</li><li>应用（application）在整个 Web 应用的生命周期中创建一个 Bean 实例<br>其中，后四个作用域是在 Web 环境下使用的</li></ol><h1>生命周期</h1><p>本文讨论单例模式下的Bean的生命周期，因为它完全被IOC容器控制<br>对于Spring Bean的生命周期来说，可以分为四个阶段，其中初始化完成之后，就代表这个Bean可以使用了：</p><ol><li><strong>实例化（Instantiation）</strong>：在这个阶段，Spring 容器根据配置信息创建 Bean 的实例。根据配置的作用域（singleton、prototype 等），实例化可能发生在容器启动时（单例）或每次请求时（原型）。</li><li><strong>属性赋值（Population）</strong>：在实例化之后，Spring 容器将会通过依赖注入或者其他方式将配置的属性值注入到 Bean 实例中，这个过程也被称为属性赋值。</li><li><strong>初始化前回调（Initialization callback）</strong>：在属性赋值完成之后，Spring 容器会调用 Bean 的初始化方法（如果有配置的话），以便进行一些初始化操作。常见的初始化方法包括 init-method 方法和 @PostConstruct 注解标记的方法。</li><li><strong>初始化后回调（Initialization callback）</strong>：在初始化方法执行完成后，Spring 容器会触发相应的事件，以通知 Bean 实例已经初始化完成。这个时候 Bean 实例已经完全可用。</li><li><strong>销毁前回调（Destruction callback）</strong>：对于 singleton 作用域的 Bean，当容器关闭时或者手动销毁 Bean 时，Spring 容器会调用 Bean 的销毁方法，执行一些清理操作。常见的销毁方法包括 destroy-method 方法和 @PreDestroy 注解标记的方法。</li></ol><h1>额外操作</h1><p>在Bean的生命周期中，还可以有一些额外操作来便于我们进一步控制和管理它们：</p><ol><li><strong>实例化阶段</strong>：<ul><li>在实例化阶段，Spring 容器会根据配置信息创建 Bean 的实例。这通常发生在容器启动时（对于 singleton 作用域的 Bean）或者在每次请求时（对于 prototype 作用域的 Bean）。</li><li>在这个阶段，可以通过自定义 BeanPostProcessor 实现类来进行扩展。BeanPostProcessor 接口提供了两个回调方法：<code>postProcessBeforeInitialization()</code> 和 <code>postProcessAfterInitialization()</code>，分别表示在 Bean 的初始化前和初始化后执行一些操作。</li><li>Bean还可以实现Aware接口，从而获得与容器交互的能力，以便获取一些容器管理的资源或者在特定的时机得到一些回调。当一个 Bean 实现了某个 Aware 接口时，Spring 容器在初始化该 Bean 时会自动调用相应的回调方法，从而将相应的资源或者引用注入到 Bean 中，例如名称，工厂，上下文等。</li></ul></li><li><strong>初始化阶段</strong>：<ul><li>在初始化阶段，Spring 容器会调用 Bean 的初始化方法，这个方法可以是通过配置的 <code>init-method</code> 属性指定的方法，也可以是使用 <code>@PostConstruct</code> 注解标记的方法。</li><li>在这个阶段，可以执行一些初始化操作，如数据初始化、资源加载等。同时，也可以通过自定义的 BeanPostProcessor 实现类在初始化前后执行一些操作。</li></ul></li><li><strong>使用阶段</strong>：<ul><li>在使用阶段，Bean 已经被完全初始化，并且可以被其他组件或者代码调用和使用。</li><li>在这个阶段，Bean 被容器管理，可以被注入到其他 Bean 中，也可以被注入到 AOP 切面中进行增强等操作。</li></ul></li><li><strong>销毁阶段</strong>：<ul><li>在销毁阶段，Spring 容器会关闭时或者手动销毁 Bean 时，会调用 Bean 的销毁方法。这个方法可以是通过配置的 <code>destroy-method</code> 属性指定的方法，也可以是使用 <code>@PreDestroy</code> 注解标记的方法。</li><li>在这个阶段，可以执行一些清理操作，如释放资源、关闭连接等。</li></ul></li></ol><h1>总结</h1><p>Bean的生命周期：</p><ol><li>通过BeanDefinition获取bean的定义信息，这里面就封装了bean的所有信息，比如，类的全路径，是否是延迟加载，是否是单例等等。</li><li>开始创建bean，调用构造函数<strong>实例化</strong>bean，这一步包括：<ul><li>依赖注入，比如一些set方法注入，也就是<strong>属性赋值</strong>，平时开发用的@Autowire都是这一步完成</li><li>处理Aware接口，如果某一个bean实现了Aware接口就会重写对应的Aware中的方法</li><li>bean的后置处理器BeanPostProcessor，这个是前置处理器</li></ul></li><li><strong>初始化</strong>方法，比如实现了接口InitializingBean或者自定义了方法init-method标签或@PostContruct</li><li>执行bean的后置处理器BeanPostProcessor，主要是对bean进行增强，有可能在这里产生代理对象</li><li>销毁bean，在销毁之前，检查是否实现DisposableBean接口或配置自定义destory-method方法，如果有，先执行这些方法然后销毁bean。</li></ol><img src="/post-img/Pasted image 20240421200409.png" alt="图片损坏" style="zoom:100%;" /><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>调用构造方法：开始实例化</span><br><span class="line"><span class="number">2.</span>设置属性：属性赋值</span><br><span class="line"><span class="number">3.</span>调用BeanNameAware<span class="meta">#setBeanName方法: Aware接口处理</span></span><br><span class="line"><span class="number">4.</span>调用BeanFactoryAware<span class="meta">#setBeanFactory方法： Aware接口处理</span></span><br><span class="line"><span class="number">5.B</span>eanPostProcessor<span class="meta">#postProcessBeforeInitialization方法：前置处理器方法</span></span><br><span class="line"><span class="number">6.</span>InitializingBean<span class="meta">#afterPropertiesSet方法：初始化</span></span><br><span class="line"><span class="number">7.</span>自定义<span class="keyword">init</span>方法：初始化</span><br><span class="line"><span class="number">8.B</span>eanPostProcessor<span class="meta">#postProcessAfterInitialization方法：后置处理器方法</span></span><br><span class="line"><span class="number">9.</span>DisposableBean<span class="meta">#destroy方法：销毁</span></span><br><span class="line"><span class="number">10.</span>自定义destroy方法：销毁</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Bean的生命周期</summary>
    
    
    
    <category term="框架" scheme="https://xlxq.fun/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="Spring" scheme="https://xlxq.fun/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>RPC入门</title>
    <link href="https://xlxq.fun/posts/9f6c61b0.html"/>
    <id>https://xlxq.fun/posts/9f6c61b0.html</id>
    <published>2024-03-09T10:19:03.000Z</published>
    <updated>2024-03-09T10:19:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1>简介</h1><p>RPC（Remote Procedure Call，远程过程调用）是一种通信协议，允许一个程序（客户端）调用另一个地址空间（通常是网络上的另一台机器）的过程或函数，而就像本地调用一样，使调用者无需关心底层的网络细节。<br>RPC的基本原理是，客户端调用远程服务器上的函数时，就像调用本地函数一样，但是函数的执行实际上发生在远程服务器上。RPC框架负责将函数调用、参数传递、执行结果等信息在客户端和服务器之间进行传输和协调。</p><h1>核心组成部分</h1><ol><li><strong>通信协议</strong>：定义了客户端和服务器之间通信的规则和格式。常见的RPC通信协议包括HTTP、TCP、UDP等。</li><li><strong>序列化协议</strong>：将函数调用和参数序列化为字节流，以便在网络上传输。常见的序列化协议包括JSON、XML、Protocol Buffers等。</li><li><strong>Stub（存根）</strong>：客户端使用的本地代理，用于代表远程服务器上的函数，并负责将函数调用转换为网络消息发送到服务器。</li><li><strong>Skeleton（骨架）</strong>：服务器端的本地代理，用于接收来自客户端的网络消息，并调用真正的函数执行请求。</li><li><strong>注册中心</strong>：用于注册和发现RPC服务的中心化组件，客户端和服务器可以通过注册中心找到彼此。</li></ol><h1>组件职责</h1><h2 id="服务调用方（Consumer）">服务调用方（Consumer）</h2><p>服务调用方也叫服务消费者，它的职责之一是<strong>提供需要调用的接口相关信息</strong>给调用端的本地存根，比如全限定名和方法以及调用方法的参数等；职责之二是从调用方的本地存根中<strong>接收执行结果</strong>。</p><h2 id="服务提供方（Provider）">服务提供方（Provider）</h2><p>服务提供方就是服务端，它的职责就是提供服务，执行接口实现的方法逻辑，也就是为服务提供方的本地存根<strong>提供方法的具体实现</strong>。</p><h2 id="本地存根（stub）">本地存根（stub）</h2><p>远程调用中，Provider如何精确地确定自己应该执行哪个函数，以及如何处理Consumer发起的函数调用，需要借助于 Stub。Stub的作用是让远程调用看起来像本地调用一样直接进行函数调用，无需关心地址空间隔离、函数不匹配等问题。Stub的职责包括<strong>进行类型和参数转化</strong>，并在服务提供方和服务调用方之间充当桥梁的角色，使得远程调用的过程对于服务调用方和服务提供方来说都像是在本地进行函数调用一样。</p><ol><li><strong>服务调用方的本地存根</strong>（Consumer端）：<ul><li>服务调用方的本地存根存在于服务调用方（Consumer）的机器上。</li><li>它会接收Consumer发起的函数调用，并解析函数名、参数等信息。</li><li>本地存根会将这些信息整理并组装成可传输的消息，按照定义好的协议进行序列化，然后交给RPCRuntime（RPC通信者）。</li><li>当服务调用方收到服务提供方返回的结果后，本地存根会将数据反序列化成服务调用方所需要的数据结果，并传递给服务消费方。</li></ul></li><li><strong>服务提供方的本地存根</strong>（Provider端）：<ul><li>服务提供方的本地存根与服务提供方一起存在于服务提供方（Provider）的机器上。</li><li>当RPCRuntime收到请求包后，会交由服务提供方的本地存根进行参数等数据的转化。</li><li>本地存根会重新转换客户端传递的数据，以便在Provider端的机器上找到对应的函数，并传递正确的参数数据。</li><li>最终，服务提供方的本地存根会将执行结果返回给RPCRuntime。</li></ul></li></ol><h2 id="RPC通信者（RPCRuntime）">RPC通信者（RPCRuntime）</h2><p>RPCRuntime负责<strong>数据包的重传，数据包的确认、数据包路由和加密</strong>等。<br>在Consumer端和Provider端都会有一个RPCRuntime实例，<strong>负责双方之间的通信</strong>，可靠地将存根数据包传输到另一端。</p><h1>调用过程</h1><p>服务暴露、服务发现、服务引用和方法调用这四个阶段组成了整个RPC的执行过程。</p><h2 id="服务暴露">服务暴露</h2><p>服务暴露发生在Provider端。根据服务是否暴露到远程可以分为两种，一种是服务只暴露到本地，另一种则是暴露到远程。</p><ol><li>本地暴露（Local Export）：<ul><li>在本地暴露中，服务只暴露给本地的调用方，不对外提供远程访问能力。</li><li>这种方式适用于在同一台物理机或者同一台虚拟机上的不同进程间通信，通常使用基于进程内通信（IPC）的方式实现，例如通过共享内存、套接字等方式。</li><li>本地暴露的优点是通信效率高、安全性好，但缺点是不能实现跨网络的远程调用。</li></ul></li><li>远程暴露（Remote Export）：<ul><li>在远程暴露中，服务可以被远程调用方访问，提供了跨网络的调用能力。</li><li>这种方式通常涉及网络通信，可以通过各种网络协议（如HTTP、TCP、UDP等）来实现跨网络的调用。</li><li>远程暴露的优点是可以实现分布式系统中不同节点之间的通信和协作，但缺点是通信开销相对较高，可能存在网络延迟和安全风险。</li></ul></li></ol><h2 id="服务发现">服务发现</h2><p>服务发现的方式有两种，分别是直连式和注册中心式，对应的是Provider端的两种服务暴露方式。</p><ol><li>直连式（Direct Connection）服务发现：<ul><li>在直连式服务发现中，服务的消费方（Consumer）直接与服务的提供方（Provider）建立连接，不依赖于任何中间组件。</li><li>Consumer通过配置服务提供方的地址（IP地址和端口号），直接向提供方发送请求。</li><li>这种方式简单直接，适用于小型系统或者对服务调用的可控性要求较高的场景。</li></ul></li><li>注册中心式（Service Registry）服务发现：<ul><li>在注册中心式服务发现中，服务的提供方将自己注册到一个中心化的服务注册中心（Service Registry）中，而服务的消费方通过查询注册中心获取服务提供方的信息，然后再进行调用。</li><li>注册中心负责管理服务的注册、注销和查询等操作，消费方通过与注册中心交互来获取服务提供方的地址信息。</li><li>这种方式通常用于大型分布式系统中，具有良好的扩展性和灵活性，但同时也引入了额外的中间件依赖和网络开销。</li></ul></li></ol><h2 id="服务引用">服务引用</h2><p>服务引用的过程发生在服务发现之后，当Consumer端通过服务发现获取所有服务提供者的地址后，通过负载均衡策略选择其中一个服务提供著的节点进行服务引用。服务引用的过程就是与某一个服务节点建立连接，以及在Consumer端创建接口的代理的过程其中建立连接也就是两端的RPCRuntime 建立连接的过程。</p><h2 id="服务调用">服务调用</h2><ol><li>服务消费者以本地调用方式(即以接口的方式)调用服务，它会将需要调用的方法、参数类型、参数传递给服务消费方的本地存根。</li><li>服务消费方的本地存根收到调用后，负责将方法、参数等数据组装成能够进行网络传输的消息体(将消息体对象序列化为二进制数据)，并将该消息体传输给RPC通信者。</li><li>Consumer 端的RPC通信者通过sockets 将消息发送到Provider端，由Provider端的RPC通信者接收。Provider端将收到的消息传递给服务提供方的本地存根。</li><li>服务提供方的本地存根收到消息后将消息对象反序列化。</li><li>服务提供方的本地存根根据反序列化的结果解析出服务调用的方法、参数类型、参数等信息，并调用服务提供方的服务。</li><li>服务提供方执行对应的方法后，将执行结果返回给服务提供方的本地存根。</li><li>服务提供方的本地存根将返回结果序列化，并且打包成可传输的消息体，传递给Provider端的RPC通信者。</li><li>Provider端的RPC通信者通过sockets将消息发送到Consumer端，由Consumer端的RPC通信者接收。Consumer端将收到的消息传递给服务消费方的本地存根。</li><li>服务消费方的本地存根收到消息后将消息对象反序列化。反序列化出来的是方法执行的结果，并将结果传递给服务消费者。</li><li>服务消费者得到最终执行结果。</li></ol><h1>常见RPC协议</h1><ol><li><strong>gRPC</strong>：gRPC 是由 Google 开发的高性能、开源的 RPC 框架，基于 HTTP/2 标准设计。它使用 Protocol Buffers（protobuf）作为默认的序列化协议，支持多种编程语言。</li><li><strong>Apache Dubbo</strong>：Apache Dubbo 是阿里巴巴开源的分布式服务框架，支持面向接口的远程调用，提供了丰富的功能如负载均衡、服务注册与发现、容错机制等。</li><li><strong>Apache Thrift</strong>：Apache Thrift 是 Facebook 开源的跨语言的服务框架，支持多种编程语言，使用 IDL（接口定义语言）来定义接口和数据类型，可以生成对应语言的客户端和服务器端代码。</li><li><strong>RSocket</strong>：RSocket 是一个跨语言的异步通信协议，支持多种传输模型（如TCP、WebSocket），提供了请求-响应、请求-流、流-响应等多种交互模式，适用于高性能、实时性要求较高的场景。</li><li><strong>XML-RPC</strong>：XML-RPC 是一种使用 XML 格式进行数据交换的远程过程调用协议，它基于 HTTP 协议，简单易用，但相对于其他协议来说性能较低。</li><li><strong>JSON-RPC</strong>：JSON-RPC 是一种使用 JSON 格式进行数据交换的远程过程调用协议，与 XML-RPC 类似，但使用 JSON 格式使得数据更加紧凑，适用于 Web 开发中的前后端交互。</li></ol><h1>protobuf</h1><p>Protocol Buffers（protobuf）是一种轻量级、高效的序列化框架，由 Google 开发并开源。它可以用于结构化数据的序列化和反序列化，支持多种编程语言，并且提供了简单的接口定义语言（IDL）用于定义数据结构和服务接口。<br>protobuf 的主要特点包括：</p><ol><li><strong>高效性</strong>：protobuf 使用二进制编码，相比于文本格式（如 XML、JSON），序列化后的数据更加紧凑，传输效率更高。</li><li><strong>跨语言支持</strong>：protobuf 提供了多种编程语言的支持，包括 Java、C++、Python、Go 等，这使得不同语言之间的数据交换变得更加方便。</li><li><strong>可扩展性</strong>：protobuf 的消息格式是可以扩展的，可以向已有的消息类型中添加新的字段而不会破坏现有的兼容性。</li><li><strong>自描述性</strong>：protobuf 支持自描述，即在序列化后的数据中包含了消息的字段标识和类型信息，使得消息的解析更加容易。</li><li><strong>快速</strong>：相比于其他序列化框架，protobuf 的序列化和反序列化速度更快，适用于对性能要求较高的场景。</li></ol><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; </span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123; </span><br><span class="line"><span class="type">string</span> name = <span class="number">1</span>; </span><br><span class="line"><span class="type">int32</span> age = <span class="number">2</span>; </span><br><span class="line"><span class="keyword">repeated</span> <span class="type">string</span> emails = <span class="number">3</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">RPC入门</summary>
    
    
    
    <category term="框架" scheme="https://xlxq.fun/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="RPC" scheme="https://xlxq.fun/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ入门</title>
    <link href="https://xlxq.fun/posts/badb3e06.html"/>
    <id>https://xlxq.fun/posts/badb3e06.html</id>
    <published>2024-01-13T11:18:02.000Z</published>
    <updated>2024-01-13T11:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1>消息队列</h1><ol><li>消息（Message）是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象。</li><li>消息队列（Message Queue）是一种应用间的通信方式，消息发送后可以立即返回，由消息系统来确保消息的可靠传递。消息发布者只管把消息发布到 MQ 中而不用管谁来取，消息使用者只管从 MQ 中取消息而不管是谁发布的。这样发布者和使用者都不用知道对方的存在，从而实现模块间的解耦合。</li><li>消息队列是一种应用间的异步协作机制，同时消息队列中间件是分布式系统中重要的组件，主要解决<strong>应用耦合，异步消息，流量削锋</strong>等问题。实现高性能，高可用，可伸缩和最终一致性架构。</li></ol><h2 id="消息队列的作用">消息队列的作用</h2><ol><li><strong>解耦：</strong> 消息队列可以将系统内不同模块之间的通信解耦，使得模块之间不直接依赖于彼此的实现。这降低了系统的复杂性，使得各个组件可以独立演化。</li><li><strong>异步通信：</strong> 消息队列支持异步通信，发送方将消息放入队列后即可继续执行其他操作，而不需要等待接收方的处理。这提高了系统的响应性，特别是在处理大量请求或在网络延迟较高的情况下。</li><li><strong>流量削峰：</strong> 消息队列可以用于缓冲和平滑处理系统的流量，防止突发的高峰值请求对系统造成压力。通过控制消息的消费速率，可以有效地削平流量峰值。</li></ol><h2 id="常见消息队列对比">常见消息队列对比</h2><p>常见的消息队列系统包括RocketMQ、RabbitMQ和Kafka，它们在一些方面有一些共同点，但也有一些明显的区别。以下是它们的一些对比：</p><ol><li><strong>消息传递模型：</strong><ul><li><strong>RocketMQ：</strong> 提供点对点和发布/订阅两种消息传递模型。</li><li><strong>RabbitMQ：</strong> 同样支持点对点和发布/订阅模型，非常灵活。</li><li><strong>Kafka：</strong> 主要支持发布/订阅模型。</li></ul></li><li><strong>性能：</strong><ul><li><strong>RocketMQ：</strong> 注重高吞吐量和低延迟，适合实时消息处理。</li><li><strong>RabbitMQ：</strong> 相对较低的延迟，适用于一些对延迟敏感的场景。</li><li><strong>Kafka：</strong> 专注于高吞吐量和持久性，适用于大规模数据处理。</li></ul></li><li><strong>可靠性：</strong><ul><li><strong>RocketMQ：</strong> 提供了较好的消息可靠性，支持同步和异步复制。</li><li><strong>RabbitMQ：</strong> 可以配置为提供高可靠性，但需要在配置上更多的努力。</li><li><strong>Kafka：</strong> 通过分区和副本机制来确保消息的可靠性。</li></ul></li><li><strong>水平扩展性：</strong><ul><li><strong>RocketMQ：</strong> 支持较好的水平扩展性，可以通过添加节点来增加容量。</li><li><strong>RabbitMQ：</strong> 可以通过集群来实现水平扩展，但可能相对复杂。</li><li><strong>Kafka：</strong> 具有出色的水平扩展性，适用于大规模数据流处理。</li></ul></li><li><strong>使用场景：</strong><ul><li><strong>RocketMQ：</strong> 适用于大规模实时消息处理，例如电商交易系统。</li><li><strong>RabbitMQ：</strong> 适用于传统企业应用，也可以用于实时数据处理。</li><li><strong>Kafka：</strong> 适用于大规模数据流处理，如日志收集、事件流处理等。</li></ul></li></ol><h1>RocketMQ</h1><h2 id="架构设计">架构设计</h2><ol><li><strong>生产者（Producer）</strong>：消息的发送者，负责产生消息，生产者向消息服务器发送由业务应用程序系统生成的消息。</li><li><strong>消费者（Consumer）</strong>：消息接收者，负责消费消息，消费者从消息服务器拉取信息并将其输入用户应用程序。</li><li><strong>消息服务器（Broker）</strong>：暂存和传输消息；是消息存储中心，主要作用是接收来自 Producer 的消息并存储， Consumer 从这里取得消息。</li><li><strong>名称服务器（NameServer）</strong>：管理Broker，用来保存 Broker 相关 Topic 等元信息并给 Producer ，提供 Consumer 查找 Broker 信息。</li><li><strong>主题（Topic）</strong>：区分消息的种类；一个发送者可以发送消息给一个或者多个Topic；一个消息的接收者 可以订阅一个或者多个Topic消息</li><li><strong>消息队列（Message Queue）</strong>：相当于是Topic的分区；用于并行发送和接收消息</li><li><strong>标签（Tag）</strong>： 用于对消息进行二级分类。一个 Topic 可以有多个 Tag，用于更细粒度地过滤消息</li></ol><h2 id="启动流程">启动流程</h2><img src="/post-img/Pasted image 20240217160000.png" alt="图片损坏" style="zoom:100%;" /><ol><li><strong>启动 NameServer</strong>，NameServer 启动后监听端口，等待 Broker、Producer、Consumer 连接，相当于一个路由控制中心。</li><li><strong>启动 Broker</strong>，Broker启动后与所有 NameServer 保持长连接，定时发送心跳包。心跳包中包含当前 Broker 信息以及存储所有 Topic 信息。注册成功后，NameServer 集群中就有 Topic 跟 Broker 的映射关系。</li><li><strong>创建 Topic</strong>，创建 Topic 时需要指定该 Topic 要存储在哪些 Broker 上，也可以在发送消息时自动创建 Topic。</li><li><strong>生产者发送消息</strong>，启动时先跟 NameServer 集群中的其中一台建立长连接，并从 NameServer 中获取当前发送的 Topic 存在于哪些 Broker 上，轮询从队列列表中选择一个队列，然后与队列所在的 Broker 建立长连接从而向 Broker发消息。</li><li><strong>消费者接受消息</strong>，跟其中一台 NameServer 建立长连接，获取当前订阅 Topic 存在哪些 Broker 上，然后直接跟 Broker 建立连接通道，然后开始消费消息。</li></ol><h2 id="特点">特点</h2><h3 id="顺序消费">顺序消费</h3><p>顺序消息是 RocketMQ 提供的一种对消息发送和消费顺序有严格要求的消息。对于一个指定的 Topic，消息严格按照先进先出（FIFO）的原则进行消息发布和消费，即先发布的消息先消费，后发布的消息后消费。</p><h4 id="分区顺序消息">分区顺序消息</h4><p>对于指定的一个 Topic，所有消息根据 Sharding Key 进行区块分区，<strong>同一个分区内</strong>的消息按照严格的先进先出（FIFO）原则进行发布和消费。同一分区内的消息保证顺序，不同分区之间的消息顺序不做要求。</p><ol><li>适用场景：适用于性能要求高，以 Sharding Key 作为分区字段，在同一个区块中严格地按照先进先出（FIFO）原则进行消息发布和消费的场景。</li><li>示例：<ul><li>用户注册需要发送验证码，以用户 ID 作为 Sharding Key，那么同一个用户发送的消息都会按照发布的先后顺序来消费。</li><li>电商的订单创建，以订单 ID 作为 Sharding Key，那么同一个订单相关的创建订单消息、订单支付消息、订单退款消息、订单物流消息都会按照发布的先后顺序来消费。</li></ul></li></ol><h4 id="全局顺序消息">全局顺序消息</h4><p>对于指定的一个Topic，<strong>所有消息</strong>按照严格的先入先出（FIFO）的顺序来发布和消费。</p><ol><li>适用场景：适用于性能要求不高，所有的消息严格按照 FIFO 原则来发布和消费的场景。</li><li>示例：</li></ol><ul><li>在证券处理中，以人民币兑换美元为 Topic，在价格相同的情况下，先出价者优先处理，则可以按照 FIFO 的方式发布和消费全局顺序消息。</li></ul><ol start="3"><li>全局顺序消息实际上是<strong>一种特殊的分区顺序消息</strong>，即 Topic 中只有一个分区，因此全局顺序和分区顺序的实现原理相同。因为分区顺序消息有多个分区，所以分区顺序消息比全局顺序消息的并发度和性能更高。</li></ol><h3 id="消息可靠性">消息可靠性</h3><p>保证消息可靠性也就是保证消息一定会被消费，不会丢失，而消息丢失可能会在这三个阶段发生：<strong>生产阶段、存储阶段、消费阶段</strong></p><ol><li>生产阶段：<strong>请求确认机制</strong><ul><li>同步发送的时候，要注意处理响应结果和异常。如果返回响应OK，表示消息成功发送到了Broker，如果响应失败，或者发生其它异常，都应该重试。</li><li>异步发送的时候，应该在回调方法里检查，如果发送失败或者异常，都应该进行重试。</li><li>如果发生超时的情况，也可以通过查询日志的API，来检查是否在Broker存储成功。</li></ul></li><li>存储阶段：<strong>通过配置可靠性优先的 Broker 参数来避免因为宕机丢消息</strong>，也就是进行<strong>数据持久化</strong><ul><li>消息只要持久化到CommitLog（日志文件）中，即使Broker宕机，未消费的消息也能重新恢复再消费。</li><li>Broker的刷盘机制：<strong>同步刷盘和异步刷盘</strong>，不管哪种刷盘都可以保证消息一定存储在pagecache中（内存中），但是同步刷盘更可靠，它是Producer发送消息后等数据持久化到磁盘之后再返回响应给Producer。</li><li>Broker通过<strong>主从模式</strong>来保证高可用，Broker支持Master和Slave同步复制、Master和Slave异步复制模式，生产者的消息都是发送给Master，但是消费既可以从Master消费，也可以从Slave消费。同步复制模式可以保证即使Master宕机，消息肯定在Slave中有备份，保证了消息不会丢失。</li></ul></li><li>消费阶段<ul><li>Consumer保证消息成功消费的关键在于确认的时机，不要在收到消息后就立即发送消费确认，而是应该在执行完所有消费业务逻辑之后，再发送消费确认。</li></ul></li></ol><h3 id="死信队列">死信队列</h3><ol><li>死信队列用于处理无法被正常消费的消息，即死信消息。</li><li>当一条消息初次消费失败，消息队列 RocketMQ 会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，RocketMQ 不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中，该特殊队列称为死信队列。</li><li>死信消息的特点：<ul><li>不会再被消费者正常消费。</li><li>有效期与正常消息相同，均为 3 天，3 天后会被自动删除。因此，需要在死信消息产生后的 3 天内及时处理。</li></ul></li><li>死信队列的特点：<ul><li><strong>一个死信队列对应一个 Group ID</strong>， 而不是对应单个消费者实例。</li><li>如果一个 Group ID 未产生死信消息，消息队列 RocketMQ 不会为其创建相应的死信队列。</li><li>一个死信队列包含了对应 Group ID 产生的所有死信消息，不论该消息属于哪个 Topic。</li><li>RocketMQ 控制台提供对死信消息的<strong>查询、导出和重发</strong>的功能。</li></ul></li></ol><h3 id="延迟队列">延迟队列</h3><p>RocketMQ是支持延时消息的，只需要在生产消息的时候设置消息的延时级别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化一个生产者来产生延时消息</span></span><br><span class="line"><span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;ExampleProducerGroup&quot;</span>);</span><br><span class="line"><span class="comment">// 启动生产者</span></span><br><span class="line">producer.start();</span><br><span class="line"><span class="type">int</span> <span class="variable">totalMessagesToSend</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; totalMessagesToSend; i++) &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TestTopic&quot;</span>, (<span class="string">&quot;message &quot;</span> + i).getBytes());</span><br><span class="line">    <span class="comment">// 设置延时等级3,这个消息将在10s之后发送(现在只支持固定的几个时间)</span></span><br><span class="line">    message.setDelayTimeLevel(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    producer.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是目前RocketMQ支持的延时级别是有限的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">messageDelayLevel</span> <span class="operator">=</span> </span><br><span class="line"><span class="string">&quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;</span>;</span><br></pre></td></tr></table></figure><p>RocketMQ通过<strong>临时存储+定时任务</strong>来实现延时消息<br>Broker收到延时消息了，会先发送到主题（SCHEDULE_TOPIC_XXXX）的相应时间段的Message Queue中，然后通过一个定时任务轮询这些队列，到期后，把消息投递到目标Topic的队列中，然后消费者就可以正常消费这些消息。</p><h2 id="常见问题解决">常见问题解决</h2><h3 id="消息幂等性">消息幂等性</h3><p>对分布式消息队列来说，同时做到确保一定投递和不重复投递是很难的，就是所谓的“有且仅有一次” 。RocketMQ择了确保一定投递，保证消息不丢失，但有可能造成消息重复。<br>处理消息重复问题，主要由业务端保证，主要的方式有两种：<strong>业务幂等和消息去重</strong></p><ol><li>业务幂等：保证消费逻辑的幂等性，也就是多次调用和一次调用的效果是一样的。这样一来，不管消息消费多少次，对业务都没有影响。</li><li>消息去重：业务端对重复的消息就不再消费了。这种方法，需要保证每条消息都有一个唯一的编号，通常是业务相关的，比如订单号，消费的记录需要落库，而且需要保证和消息确认这一步的原子性。<br>基于以下两个方向思考：</li><li>接口只允许调用一次，比如mysql唯一索引，基于redis分布式锁机制</li><li>对数据的影响只会触发一次，比如乐观锁或状态机（数据的状态信息是向前变化的，因此如果数据的当前状态小于记录的状态，就可以忽略这次修改的信息）</li></ol><h3 id="消息积压">消息积压</h3><p>事前处理：上线之前对流量有个预估，压测得出消费者的消费能力上限，再根据实际情况进行部署以支撑整个服务<br>事中处理：先保证服务，进行消费者的临时扩容操作</p><ol><li>消费者扩容：<ul><li>如果当前Topic的Message Queue的数量大于消费者数量，就可以对消费者进行扩容，增加消费者，来提高消费能力，尽快把积压的消息消费玩。</li></ul></li><li>消息迁移Queue扩容：<ul><li>如果当前Topic的Message Queue的数量小于或者等于消费者数量，这种情况，再扩容消费者就没什么用，就得考虑扩容Message Queue。可以新建一个临时的Topic，临时的Topic多设置一些Message Queue，然后先用一些消费者把消费的数据丢到临时的Topic，因为不用业务处理，只是转发一下消息，还是很快的。接下来用扩容的消费者去消费新的Topic里的数据，消费完了之后，恢复原状。<br>事后处理：</li></ul></li><li>提高并行消费度，如：合理设置消费者组；增加队列分区，考虑把消息分散到多个队列中，避免单个队列出现积压</li><li>批量方式消费，提高消费吞吐量</li><li>调整消息处理的优先级：根据消息的重要性和紧急程度，调整消息处理的优先级。优先处理重要的消息，确保关键业务的及时性，而对于非关键的消息可以进行降级处理、跳过、或延后处理。</li><li>优化每条消息的消费过程（业务）<br>5. 合理设置超时机制</li><li>数据清理和重试：定期清理过期或无效信息</li><li>扩容：若MQ出现性能瓶颈，对MQ扩容</li><li>增加消费者数量：增加消费能力</li></ol><h3 id="消息过滤">消息过滤</h3><ol><li>在 Broker 端按照 Consumer 的去重逻辑进行过滤，这样做的好处是避免了无用的消息传输到 Consumer 端，缺点是加重了 Broker 的负担，实现起来相对复杂。</li><li>在 Consumer 端过滤，比如按照消息设置的 tag 去重，这样的好处是实现起来简单，缺点是有大量无用的消息到达了 Consumer 端只能丢弃不处理。</li><li>一般采用Cosumer端过滤，如果希望提高吞吐量，可以采用Broker过滤。</li><li>对消息的过滤有三种方式：<ul><li>根据Tag过滤：高效简单</li><li>SQL 表达式过滤：更加灵活</li><li>Filter Server 方式：最灵活，也是最复杂的一种方式，允许用户自定义函数进行过滤</li></ul></li></ol><h3 id="高可用（消息持久化）">高可用（消息持久化）</h3><ol><li>RocketMQ的高可用主要是在体现在Broker的读和写的高可用，Broker的高可用是通过<strong>主从集群</strong>实现的</li><li>Broker可以配置两种角色：Master和Slave<ul><li>Master角色的Broker支持读和写</li><li>Slave角色的Broker只支持读</li><li>Master会向Slave同步消息。</li><li>Producer只能向Master角色的Broker写入消息，Cosumer可以从Master和Slave角色的Broker读取消息。</li></ul></li><li>读的高可用：<strong>自动切换</strong><ul><li>Consumer 的配置文件中，并不需要设置是从 Master 读还是从 Slave读，当 Master 不可用或者繁忙的时候， Consumer 的读请求会被自动切换到从 Slave。有了自动切换 Consumer 这种机制，当一个 Master 角色的机器出现故障后，Consumer 仍然可以从 Slave 读取消息，不影响 Consumer 读取消息，这就实现了读的高可用。</li></ul></li><li>写的高可用：<strong>多Master</strong><ul><li>在创建 Topic 的时候，把 Topic 的多个Message Queue 创建在多个 Broker 组上（相同 Broker 名称，不同 brokerId机器组成 Broker 组），这样当 Broker 组的 Master 不可用后，其他组Master 仍然可用， Producer 仍然可以发送消息</li><li>RocketMQ 目前还不支持把Slave自动转成 Master ，如果机器资源不足，需要把 Slave 转成 Master ，则要手动停止 Slave 色的 Broker ，更改配置文件，用新的配置文件启动 Broker。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">消息队列RocketMQ简单了解</summary>
    
    
    
    <category term="消息队列" scheme="https://xlxq.fun/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="https://xlxq.fun/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>git</title>
    <link href="https://xlxq.fun/posts/518e617c.html"/>
    <id>https://xlxq.fun/posts/518e617c.html</id>
    <published>2024-01-12T11:18:02.000Z</published>
    <updated>2024-01-12T11:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>Git 是一个分布式版本控制系统，用于跟踪软件开发过程中的代码变更。它允许多个开发者协同工作，同时记录代码的变更历史，管理不同版本的代码库，以及轻松地创建分支和合并代码。</p><h1>基础概念</h1><p>以下是与 Git 相关的一些关键概念和命令：</p><ol><li><strong>仓库（Repository）</strong>：仓库是包含项目及其所有文件的目录，同时还包括了代码变更的历史记录。</li><li><strong>克隆（Clone）</strong>：要开始使用一个 Git 仓库，通常会使用 <code>git clone</code> 命令将远程仓库克隆到本地计算机上</li><li><strong>提交（Commit）</strong>：提交是在特定时间点对你的更改进行快照。你可以使用 <code>git commit</code> 命令将更改保存到本地仓库。</li><li><strong>分支（Branch）</strong>：分支是仓库内的一个独立开发线。它允许你在不影响主要代码库的情况下开发功能或修复问题。可以使用 <code>git branch</code> 创建分支，使用 <code>git checkout</code> 在不同分支之间切换。</li><li><strong>合并（Merge）</strong>：合并将一个分支的更改合并到另一个分支中。使用 <code>git merge</code> 命令将源分支的更改集成到目标分支中。</li><li><strong>拉取（Pull）</strong>：拉取是从远程仓库获取更改并将其整合到本地仓库的过程。这通常用于保持本地仓库与远程仓库同步。你可以使用 <code>git pull</code> 进行拉取操作。</li><li><strong>推送（Push）</strong>：推送将本地的提交发送到远程仓库。这是与他人共享更改的方式。使用 <code>git push</code> 进行推送操作。</li><li><strong>远程（Remote）</strong>：远程是对远程仓库的引用，通常托管在平台如 GitHub、GitLab 或 Bitbucket 上。可以使用 <code>git remote</code> 命令添加、删除或管理远程仓库。</li><li><strong>状态（Status）</strong>：<code>git status</code> 命令显示仓库的当前状态，包括已经进行但尚未提交的更改。</li><li><strong>差异（Diff）</strong>：<code>git diff</code> 命令显示两个版本之间的差异，帮助你理解所做的更改。</li></ol><h1>常用命令</h1><p>以下是一些可能会用到的命令及其简要描述：</p><ol><li><code>git init</code>：在当前目录初始化一个新的 Git 仓库。</li><li><code>git clone &lt;URL&gt;</code>：从远程仓库克隆代码到本地。</li><li><code>git add &lt;file&gt;</code>：将文件的更改添加到暂存区。</li><li><code>git commit -m &quot;message&quot;</code>：将暂存区的更改提交到本地仓库。</li><li><code>git status</code>：查看当前仓库的状态，包括未提交的更改。</li><li><code>git diff</code>：显示当前工作目录中的更改。</li><li><code>git branch</code>：列出所有本地分支，显示当前所在分支。</li><li><code>git checkout &lt;branch&gt;</code>：切换到指定分支。</li><li><code>git merge &lt;branch&gt;</code>：将指定分支的更改合并到当前分支。</li><li><code>git pull</code>：从远程仓库拉取最新更改。</li><li><code>git push</code>：将本地更改推送到远程仓库。</li><li><code>git remote add &lt;name&gt; &lt;URL&gt;</code>：添加一个远程仓库。</li><li><code>git log</code>：查看提交历史记录。</li><li><code>git reset &lt;file&gt;</code>：从暂存区撤销文件的更改。</li><li><code>git revert &lt;commit&gt;</code>：创建一个新提交，撤销指定提交的更改。</li><li><code>git stash</code>：将当前未提交的更改暂存起来，以便在切换分支时使用。</li><li><code>git tag &lt;tagname&gt;</code>：创建一个标签，用于标记某个特定的提交。</li></ol><h1>git的工作原理</h1><h2 id="工作区域">工作区域</h2><p>Git本地有三个工作区域∶工作目录(Working Directory )、暂存区(Stage/ndex)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下∶<br><img src="/post-img/Pasted image 20230822165257.png" alt="图片损坏" style="zoom:100%;" /></p><p>Workspace :工作区，就是平时存放项目代码的地方<br>Index / Stage:暂存区，用于临时存放改动，事实上它只是一个文件，保存即将提交到文件列表信息<br>Repository :仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交的所有版本的数据。其中HEAD指向最新放入仓库的版本</p><h2 id="工作流程">工作流程</h2><ol><li>在工作目录中添加、修改文件;</li><li>将需要进行版本管理的文件放入暂存区域;</li><li>将暂存区域的文件提交到git仓库。<br>因此，git管理的文件有三种状态：已修改，已暂存，已提交</li></ol><h2 id="关于分支">关于分支</h2><p>git是一个帮助多人协同合作的工具，由于个人之间的工作不同，项目代码势必会在同一基础上进行不同的修改，这个同一基础就是master主分支，要对master进行修改，一般要新建一个分支，对master进行不同修改后得到的不同分支进行合并时，一般会由git判断是否存在冲突，这时，Git 不能自动决定应该选择哪个更改，因为它无法确定哪个更改是正确的。在这种情况下，Git 会将冲突标记在文件中，然后需要开发者手动解决冲突，冲突解决后，可以将合并后的这个新的分支设置为新的master<br>解决冲突的一般步骤是：</p><ol><li>执行<code>git pu11</code>以获取远程分支的最新更改。</li><li>Git将会提示存在冲突的文件，需要在这些文件中手动编辑并解决冲突。</li><li>编辑后的文件需要保存，然后使用<code>git add</code>将文件标记为已解决。</li><li>最后，运行<code>git commit</code>来提交解决冲突的更改。</li></ol><h1>关于一些常见问题</h1><ol><li><strong>Git的原理和工作流程</strong>： Git 是一种分布式版本控制系统，它的核心原理是基于快照（snapshot）。每次提交（commit）都会创建一个文件和目录的快照，而不是保存文件之间的差异。Git 的工作流程通常包括以下步骤：<ul><li><strong>克隆（Clone）</strong>：从远程仓库复制项目到本地，创建一个本地仓库。</li><li><strong>工作目录（Working Directory）</strong>：在本地仓库中，你可以在工作目录中修改文件。</li><li><strong>暂存区（Staging Area）</strong>：将工作目录中的修改添加到暂存区，为下一次提交做准备。</li><li><strong>提交（Commit）</strong>：从暂存区中创建一个快照，将其保存到版本历史中。</li><li><strong>分支（Branch）</strong>：可以创建分支来在不同功能上开展并行开发，每个分支都有自己的工作目录、暂存区和提交历史。</li><li><strong>合并（Merge）</strong>：将不同分支上的修改合并到一起，形成一个新的提交。</li><li><strong>推送（Push）</strong>：将本地提交推送到远程仓库，与团队共享。</li><li><strong>拉取（Pull）</strong>：从远程仓库获取最新的变更，包括其他人的提交。</li></ul></li><li><strong>版本控制系统</strong>： 版本控制系统（Version Control System，VCS）是一种用于追踪和管理文件版本和变更历史的工具。它允许多人协同开发、追踪代码变化、回溯历史、分支和合并等。VCS 的主要目的是使开发团队能够更有效地协同工作，减少错误和冲突，并为项目提供详细的版本历史。</li><li><strong>git fetch和git pull命令的区别</strong>：<ul><li><p><code>git fetch</code>：从远程仓库获取最新的提交和分支信息，但不会自动合并或更新你的工作目录。它会将获取的内容存储在本地仓库的远程跟踪分支中。</p></li><li><p><code>git pull</code>：执行两个操作，首先，它会从远程仓库拉取最新的提交并合并到当前分支，然后更新你的工作目录。这相当于执行了 <code>git fetch</code> 后紧接着的 <code>git merge</code>。</p></li></ul></li><li><strong>git rebase和git merge命令的区别</strong>：<ul><li><code>git merge</code>：将一个分支的更改合并到另一个分支。合并会创建一个新的提交节点，记录两个分支的历史交汇点。</li><li><code>git rebase</code>：将一个分支上的更改在另一个分支的基础上重新应用。它将当前分支上的提交逐个应用到目标分支的顶部，创造更线性的提交历史。</li></ul></li><li><strong>Git Flow</strong>： Git Flow 是一种流行的 Git 分支管理工作流，它提供了一套规范的分支命名和管理策略。它包括主分支（master）、开发分支（develop）、功能分支（feature）、发布分支（release）、修复分支（hotfix）等。Git Flow 的好处在于使协同开发更有条理，促进版本控制和发布的流程化，降低冲突和错误。</li><li><strong>暂存区</strong>： 暂存区是 Git 版本控制系统的一个重要概念。在进行提交之前，你可以将工作目录中的修改（包括新增、修改和删除的文件）添加到暂存区。暂存区允许你控制哪些更改应该包含在下一次提交中。这使你能够构建精细的提交，准备提交前进行检查，避免错误和混乱的提交。<br>Git 需要暂存区的存在，因为它提供了更多的控制权和准备提交的灵活性。你可以选择性地将不同文件的修改添加到暂存区，从而创建更清晰、有序的提交历史。</li><li><strong>控制某些文件不被提交</strong>： 你可以使用<code>.gitignore</code>文件来控制哪些文件或目录在提交时被忽略。在项目根目录下创建或编辑<code>.gitignore</code>文件，然后列出你希望忽略的文件、目录、通配符等。这样，这些文件就不会出现在提交中。</li><li><strong>提交冲突的情况和解决方法</strong>： 冲突通常发生在以下情况：<ul><li>多人同时修改同一行或相邻行的代码。</li><li>合并分支时，两个分支有相同文件的不同修改。<br>解决冲突的步骤：</li><li>运行 <code>git status</code> 查看冲突文件。</li><li>打开冲突文件，在文件中可以看到类似于 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>、<code>=======</code> 和 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch_name</code> 的标记，这是冲突的标志。</li><li>手动编辑文件，保留需要的代码部分，删除冲突标记和无关的部分。</li><li>保存文件，然后运行 <code>git add</code> 将冲突文件标记为已解决。</li><li>运行 <code>git commit</code> 提交解决冲突后的修改。</li></ul></li><li><strong>恢复错误的代码或删除的文件</strong>：<ul><li>对于已提交的错误代码，可以通过创建新的提交来修复。你可以修改代码，然后提交一个新的修复提交。</li><li>对于已删除的文件，如果你没有提交删除操作，可以使用 <code>git checkout</code> 命令来还原文件，例如：<code>git checkout filename</code>。</li></ul></li><li><strong>项目代码管理的方法</strong>：<ul><li>使用版本控制系统，如 Git。</li><li>遵循分支管理策略，如 Git Flow，以便有条理地管理功能开发、测试和发布。</li><li>使用代码审查来保证代码质量。</li><li>使用持续集成和持续交付工具，确保代码的集成和交付过程自动化、稳定和可重复。</li><li>鼓励团队成员遵循一致的编码风格和最佳实践。</li></ul></li><li><strong>防止错误的代码提交</strong>：<ul><li>使用代码审查：通过审查他人的代码，可以发现和纠正错误。</li><li>使用自动化测试：编写自动化测试用例来检查代码是否正常工作。</li><li>使用持续集成：集成和自动化测试可以在提交之前自动运行，减少错误的机会。</li><li>使用预提交挂钩（pre-commit hooks）：可以设置钩子，在提交前运行特定的脚本来检查代码是否符合规范。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">git基本使用</summary>
    
    
    
    <category term="开发工具" scheme="https://xlxq.fun/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="git" scheme="https://xlxq.fun/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>idea快捷键</title>
    <link href="https://xlxq.fun/posts/385c30d.html"/>
    <id>https://xlxq.fun/posts/385c30d.html</id>
    <published>2024-01-12T11:18:02.000Z</published>
    <updated>2024-01-12T11:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="https://blog.csdn.net/m0_69057918/article/details/131036872">https://blog.csdn.net/m0_69057918/article/details/131036872</a><br>以下加粗是笔者根据自身使用情况整理的更常用的快捷键<br><strong>Ctrl + F 在当前文件进行文本查找</strong><br><strong>Ctrl + Z 撤销</strong><br><strong>Ctrl + Y 删除光标所在行 或 删除选中的行</strong><br><strong>Ctrl + X 剪切光标所在行 或 剪切选择内容</strong><br><strong>Ctrl + C 复制光标所在行 或 复制选择内容</strong><br><strong>Ctrl + D 复制光标所在行 或 复制选择内容，并把复制内容粘贴</strong><br><strong>Ctrl + P 方法参数提示显示</strong><br><strong>Ctrl + B 进入光标所在的方法/变量的接口或是定义处，等效于 Ctrl + 左键单击</strong><br><strong>Ctrl + K 版本控制提交项目，需要此项目有加入到版本控制才可用</strong><br><strong>Ctrl + T 版本控制更新项目，需要此项目有加入到版本控制才可用</strong><br><strong>Ctrl + H 显示当前类的层次结构（所有父类和子类）</strong><br><strong>Ctrl + / 注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号</strong></p><p><strong>Alt + Enter IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同</strong><br><strong>Alt + Insert 代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等</strong></p><p><strong>Ctrl + Alt + L 格式化代码，可以对当前文件和整个包目录使用</strong><br><strong>Ctrl + Alt + O 优化导入的类，可以对当前文件和整个包目录使用</strong><br><strong>Ctrl + Alt + 左方向键 退回到上一个操作的地方</strong><br><strong>Ctrl + Alt + 右方向键 前进到上一个操作的地方</strong></p><p><strong>Ctrl + Shift + U 对选中的代码进行大 / 小写转换</strong><br><strong>Ctrl + Shift + / 代码块注释</strong></p><p>一. Ctrl相关<br>Ctrl + W 递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围(从词逐渐向左右扩展)<br>Ctrl + R 在当前文件进行文本替换<br>Ctrl + E 显示最近打开的文件记录列表<br>Ctrl + N 根据输入的 类名 查找类文件<br>Ctrl + G 在当前文件跳转到指定行处<br>Ctrl + J 插入自定义动态代码模板<br>Ctrl + Q 光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容<br>Ctrl + U 前往当前光标所在的方法的父类的方法 / 接口定义<br>Ctrl + O 选择可重写的方法<br>Ctrl + I 选择可继承的方法<br>Ctrl + + 展开代码<br>Ctrl + - 折叠代码<br>Ctrl + [ 移动光标到当前所在代码的花括号开始位置<br>Ctrl + ] 移动光标到当前所在代码的花括号结束位置<br>Ctrl + F1 在光标所在的错误代码处显示错误信息<br>Ctrl + F3 调转到所选中的词的下一个引用位置<br>Ctrl + F4 关闭当前编辑文件<br>Ctrl + F8 在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点<br>Ctrl + F9 执行 Make Project 操作<br>Ctrl + F11 选中文件 / 文件夹，使用助记符设定 / 取消书签<br>Ctrl + F12 弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选<br>Ctrl + Tab 编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口<br>Ctrl + Enter 智能分隔行<br>Ctrl + End 跳到文件尾<br>Ctrl + Home 跳到文件头<br>Ctrl + Space 基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 ALT+/（必备）<br>Ctrl + Delete 删除光标后面的单词或是中文句<br>Ctrl + BackSpace 删除光标前面的单词或是中文句<br>Ctrl + 1,2,3…9 定位到对应数值的书签位置<br>Ctrl + 左键单击 在打开的文件标题上，弹出该文件路径<br>Ctrl + 光标定位 按 Ctrl 不要松开，会显示光标所在的类信息摘要<br>Ctrl + 左方向键 光标跳转到当前单词 / 中文句的左侧开头位置<br>Ctrl + 右方向键 光标跳转到当前单词 / 中文句的右侧开头位置</p><p>二. Alt相关<br>Alt + ` 显示版本控制常用操作菜单弹出层<br>Alt + Q 弹出一个提示，显示当前类的声明 / 上下文信息<br>Alt + F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择<br>Alt + F2 对于前面页面，显示各类浏览器打开目标选择弹出层<br>Alt + F3 选中文本，逐个往下查找相同文本，并高亮显示<br>Alt + F7 查找光标所在的方法 / 变量 / 类被调用的地方<br>Alt + F8 在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果<br>Alt + Home 定位 / 显示到当前文件的 Navigation Bar<br>Alt + 左方向键 按左方向切换当前已打开的文件视图<br>Alt + 右方向键 按右方向切换当前已打开的文件视图<br>Alt + 前方向键 当前光标跳转到当前文件的前一个方法名位置<br>Alt + 后方向键 当前光标跳转到当前文件的后一个方法名位置<br>Alt + 1,2,3…9 显示对应数值的选项卡，其中 1 是 Project 用得最多</p><p>三. Shift相关<br>Shift + F1 如果有外部文档可以连接外部文档<br>Shift + F2 跳转到上一个高亮错误 或 警告位置<br>Shift + F3 在查找模式下，查找匹配上一个<br>Shift + F4 对当前打开的文件，使用新Windows窗口打开，旧窗口保留<br>Shift + F6 对文件 / 文件夹 重命名<br>Shift + F7 在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法<br>Shift + F8 在 Debug 模式下，跳出，表现出来的效果跟 F9 一样<br>Shift + F9 等效于点击工具栏的 Debug 按钮<br>Shift + F10 等效于点击工具栏的 Run 按钮<br>Shift + F11 弹出书签显示层<br>Shift + Tab 取消缩进<br>Shift + ESC 隐藏当前 或 最后一个激活的工具窗口<br>Shift + End 选中光标到当前行尾位置<br>Shift + Home 选中光标到当前行头位置<br>Shift + Enter 开始新一行。光标所在行下空出一行，光标定位到新行位置<br>Shift + 左键单击 在打开的文件名上按此快捷键，可以关闭当前打开文件<br>Shift + 滚轮前后滚动 当前文件的横向滚动轴滚动</p><p>四. Ctrl + Alt相关<br>Ctrl + Alt + I 光标所在行 或 选中部分进行自动代码缩进，有点类似格式化<br>Ctrl + Alt + T 对选中的代码弹出环绕选项弹出层<br>Ctrl + Alt + J 弹出模板选择窗口，将选定的代码加入动态模板中<br>Ctrl + Alt + H 调用层次<br>Ctrl + Alt + B 在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口<br>Ctrl + Alt + V 快速引进变量<br>Ctrl + Alt + Y 同步、刷新<br>Ctrl + Alt + S 打开 IntelliJ IDEA 系统设置<br>Ctrl + Alt + F7 显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来<br>Ctrl + Alt + F11 切换全屏模式<br>Ctrl + Alt + Enter 光标所在行上空出一行，光标定位到新行<br>Ctrl + Alt + Home 弹出跟当前文件有关联的文件弹出层<br>Ctrl + Alt + Space 类名自动完成<br>Ctrl + Alt + 前方向键 在查找模式下，跳到上个查找的文件<br>Ctrl + Alt + 后方向键 在查找模式下，跳到下个查找的文件</p><p>五. Ctrl + Shift相关<br>Ctrl + Shift + F 根据输入内容查找整个项目 或 指定目录内文件<br>Ctrl + Shift + R 根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件<br>Ctrl + Shift + J 自动将下一行合并到当前行末尾<br>Ctrl + Shift + Z 取消撤销<br>Ctrl + Shift + W 递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围<br>Ctrl + Shift + N 通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠<br>Ctrl + Shift + T 对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择<br>Ctrl + Shift + C 复制当前文件磁盘路径到剪贴板<br>Ctrl + Shift + V 弹出缓存的最近拷贝的内容管理器弹出层<br>Ctrl + Shift + E 显示最近修改的文件列表的弹出层<br>Ctrl + Shift + H 显示方法层次结构<br>Ctrl + Shift + B 跳转到类型声明处<br>Ctrl + Shift + I 快速查看光标所在的方法 或 类的定义<br>Ctrl + Shift + A 查找动作 / 设置<br>Ctrl + Shift + [ 选中从光标所在位置到它的顶部中括号位置<br>Ctrl + Shift + ] 选中从光标所在位置到它的底部中括号位置<br>Ctrl + Shift + + 展开所有代码<br>Ctrl + Shift + - 折叠所有代码<br>Ctrl + Shift + F7 高亮显示所有该选中文本，按Esc高亮消失<br>Ctrl + Shift + F8 在 Debug 模式下，指定断点进入条件<br>Ctrl + Shift + F9 编译选中的文件 / 包 / Module<br>Ctrl + Shift + F12 编辑器最大化<br>Ctrl + Shift + Space 智能代码提示<br>Ctrl + Shift + Enter 自动结束代码，行末自动添加分号 （必备）<br>Ctrl + Shift + Backspace 退回到上次修改的地方<br>Ctrl + Shift + 1,2,3…9 快速添加指定数值的书签<br>Ctrl + Shift + 左键单击 把光标放在某个类变量上，按此快捷键可以直接定位到该类中 （必备）<br>Ctrl + Shift + 左方向键 在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句<br>Ctrl + Shift + 右方向键 在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句<br>Ctrl + Shift + 左方向键 在光标焦点是在工具选项卡上，缩小选项卡区域<br>Ctrl + Shift + 右方向键 在光标焦点是在工具选项卡上，扩大选项卡区域<br>Ctrl + Shift + 前方向键 光标放在方法名上，将方法移动到上一个方法前面，调整方法排序<br>Ctrl + Shift + 后方向键 光标放在方法名上，将方法移动到下一个方法前面，调整方法排序</p><p>六. Alt + Shift相关<br>Alt + Shift + N 选择 / 添加 task<br>Alt + Shift + F 显示添加到收藏夹弹出层 / 添加到收藏夹<br>Alt + Shift + C 查看最近操作项目的变化情况列表<br>Alt + Shift + I 查看项目当前文件<br>Alt + Shift + F7 在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入<br>Alt + Shift + F9 弹出 Debug 的可选择菜单<br>Alt + Shift + F10 弹出 Run 的可选择菜单<br>Alt + Shift + 左键双击 选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句<br>Alt + Shift + 前方向键 移动光标所在行向上移动<br>Alt + Shift + 后方向键 移动光标所在行向下移动</p><p>七. 其他<br>F2 跳转到下一个高亮错误 或 警告位置 （必备）<br>F3 在查找模式下，定位到下一个匹配处<br>F4 编辑源<br>F7 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中<br>F8 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内<br>F9 在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上<br>F11 添加书签<br>F12 回到前一个工具窗口<br>Tab 缩进<br>ESC 从工具窗口进入代码文件窗口</p><p>Ctrl + Shift + Alt + V 无格式黏贴<br>Ctrl + Shift + Alt + N 前往指定的变量 / 方法<br>Ctrl + Shift + Alt + S 打开当前项目设置<br>Ctrl + Shift + Alt + C 复制参考信息</p>]]></content>
    
    
    <summary type="html">idea快捷键</summary>
    
    
    
    <category term="开发工具" scheme="https://xlxq.fun/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="idea" scheme="https://xlxq.fun/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>maven</title>
    <link href="https://xlxq.fun/posts/c6e613d8.html"/>
    <id>https://xlxq.fun/posts/c6e613d8.html</id>
    <published>2024-01-12T11:18:02.000Z</published>
    <updated>2024-01-12T11:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1>Maven</h1><h2 id="基本概念">基本概念</h2><h3 id="仓库">仓库</h3><p>用于存储资源，包含各种jar包<br>分类：<br><strong>本地仓库</strong>:自己电脑上存储资源的仓库,连接远程仓库获取资源<br><strong>远程仓库</strong>:非本机电脑上的仓库，为本地仓库提供资源，分为中央仓库和私服<br>中央仓库: Maven团队维护，存储所有资源的仓库<br>私服:部门/公司范围内存储资源的仓库，从中央仓库获取资源<br><strong>私服的作用</strong>:<br>保存具有版权的资源,包含购买或自主研发的jar<br>中央仓库中的jar都是开源的，不能存储具有版权的资源<br>一定范围内共享资源，仅对内部开放，不对外共享</p><h3 id="坐标">坐标</h3><p>Maven中的坐标用于描述仓库中资源的位置<br>Maven坐标主要组成：<br>groupld:定义当前Maven项目隶属组织名称(通常是域名反写，例如: org.mybatis)<br>artifactld:定义当前Maven项目名称(通常是模块名称，例如CRM、SMS)<br>version:定义当前项目版本号<br>（packaging:定义该项目的打包方式）<br>Maven坐标的作用：<br>使用唯一标识，唯一性定位资源位置，通过该标识可以将资源的识别与下载工作交由机器完成</p><h3 id="仓库配置">仓库配置</h3><p>在maven的下载路径下有一个setting文件，可以更改一些基础设置，比如本地仓库的存储位置，以及配置阿里镜像仓库，即从阿里的仓库中获取资源而非中央仓库，这样快一点</p><h2 id="Maven的工程目录结构">Maven的工程目录结构</h2><img src="/post-img/Pasted image 20230822152137.png" alt="图片损坏" style="zoom:100%;" /><p>大概了解一下，现在一般是在idea中直接创建maven工程或spring工程</p><h2 id="依赖管理">依赖管理</h2><h3 id="依赖配置">依赖配置</h3><p>依赖是指当前项目运行所需的jar，一个项目可以设置多个依赖，这些依赖一般来自于中心仓库（私服），是前人或同事写好的jar包或工具类<br><img src="/post-img/Pasted image 20230822152553.png" alt="图片损坏" style="zoom:100%;" /></p><h3 id="依赖传递">依赖传递</h3><p>在引入一个新的jar包时，这个jar包可能依赖其它的jar包，在导入这个jar包时，会将它的所有依赖也一起导入，这就是依赖的传递性<br>直接依赖：在当前项目中通过依赖配置建立的依赖关系<br>间接依赖：被依赖的资源如果依赖其它资源，当前项目间接依赖其它资源<br>这有时会导致依赖传递冲突问题，也就是可能不同级的依赖相同但版本号不同，应遵守以下原则：<br>路径优先:当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高<br>声明优先:当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的<br>特殊优先:当同级配置了相同资源的不同版本，后配置的覆盖先配置的</p><h3 id="可选依赖">可选依赖</h3><p>可选依赖指对外隐藏当前所依赖的资源（但仍在使用）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="排除依赖">排除依赖</h3><p>排除依赖指不再使用当前所指的资源</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exalusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hamcrest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hamcrest-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="依赖范围">依赖范围</h3><p>依赖的jar默认情况可以在任何地方使用，可以通过scope标签设定其作用范围<br>作用范围：<br>主程序范围有效(main文件夹范围内)<br>测试程序范围有效(test文件夹范围内)<br>是否参与打包(package指令范围内)<br><img src="/post-img/Pasted image 20230822153502.png" alt="图片损坏" style="zoom:100%;" /></p><h3 id="循环依赖">循环依赖</h3><ol><li><strong>优化模块设计</strong>： 首先，考虑你的模块设计是否合理。循环依赖通常是模块之间划分不清晰所导致的。尽量遵循单一职责原则，将模块按照功能分割，减少模块之间的直接依赖。</li><li><strong>拆分和合并模块</strong>： 如果发现存在循环依赖，考虑将其中一个或多个模块进行拆分或合并，以消除循环依赖。有时，将功能合并到一个模块中，或者将一些共享的功能抽离成一个独立的模块，可以帮助解决循环依赖问题。</li><li><strong>使用接口和抽象</strong>： 如果模块之间需要互相调用，尽量通过接口或抽象类来定义依赖关系，而不是直接依赖具体实现。这可以减少循环依赖的风险。</li><li><strong>Maven 中的 <code>&lt;dependencyManagement&gt;</code></strong>： 如果循环依赖是由于版本问题引起的，可以使用 Maven 的 <code>&lt;dependencyManagement&gt;</code> 部分来集中管理依赖的版本，以确保一致性。</li><li><strong>提取接口模块</strong>： 为了解决循环依赖，你可以创建一个独立的接口模块，其中定义了所有模块之间的接口。然后各个模块可以依赖于这个接口模块，而不会产生循环依赖。</li><li><strong>调整模块依赖关系</strong>： 在 <code>&lt;dependencies&gt;</code> 部分中，可以明确声明模块的依赖关系和作用域，以便更好地控制依赖。</li><li><strong>检查插件和目标</strong>： 有时，循环依赖可能是由于插件的配置或目标的执行引起的。检查是否有插件或目标的配置引发了循环依赖。</li><li><strong>使用模块路径</strong>： 如果使用 Java 9 及更高版本，可以尝试使用模块路径来隔离模块，避免循环依赖。</li><li><strong>重新考虑项目结构</strong>： 如果循环依赖问题无法通过上述方法解决，可能需要重新审视项目结构和模块之间的关系，进行更大范围的重构。</li></ol><h2 id="生命周期与插件">生命周期与插件</h2><h3 id="生命周期">生命周期</h3><p>生命周期指maven对项目的阶段的管理，一般分为三类：<br>clean：清理工作<br>default：核心工作，例如编译，测试，打包，部署等<br>site：产生报告，发布站点等<br>在执行某个生命周期时，会默认将这个生命周期前的所有生命周期全部执行完成，除非指定不执行某个生命周期</p><h3 id="插件">插件</h3><p>插件与生命周期内的阶段绑定，在执行到对应生命周期时执行对应的插件功能<br>内置插件：默认maven在各个生命周期上绑定有预设的功能<br>自定义插件：通过插件可以自定义其他功能，如果内置插件无法满足特定需求，可以创建自定义插件。自定义插件通常使用 Java 编写，通过继承 Maven 插件框架来实现。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> <span class="comment">&lt;!-- 插件的 Group ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-custom-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> <span class="comment">&lt;!-- 插件的 Artifact ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 插件的版本 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>custom-goal<span class="tag">&lt;/<span class="name">goal</span>&gt;</span> <span class="comment">&lt;!-- 自定义插件的目标（Goal） --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>idea中执行的生命周期：</p><ol><li><strong>clean</strong>： 清理项目构建生成的目录和文件，包括 <code>target</code> 目录。</li><li><strong>compile</strong>：编译项目的源代码，生成字节码文件。</li><li><strong>test</strong>： 运行项目的单元测试。</li><li><strong>package</strong>： 将编译后的代码打包成可分发的格式，如 JAR、WAR 或 EAR。</li><li><strong>install</strong>：将项目构建结果安装到本地 Maven 仓库，以供其他项目引用。</li><li><strong>deploy</strong>: 将构建结果部署到远程 Maven 仓库，以便其他项目或团队访问。</li><li><strong>site</strong>: 生成项目的站点文档和报告，如代码覆盖率、测试报告等。</li></ol><h2 id="分模块开发">分模块开发</h2><p>分模块开发思想是将一个大型应用程序分解为更小、更易管理的模块，每个模块负责不同的功能或组件。每个模块都可以独立开发、测试和部署。如在web编程中，将实体类pojo，业务层service，数据层dao，控制层controller都分别设置为一个独立的模块<br>这种方式有许多好处：</p><ol><li><strong>模块化</strong>：将应用程序分为模块使得代码更加模块化和组织有序，容易理解和维护。</li><li><strong>独立开发</strong>：开发人员可以专注于自己负责的模块，而不必关心整个应用程序。</li><li><strong>并行开发</strong>：不同模块可以并行开发，提高了开发效率。</li><li><strong>重用性</strong>：可以更轻松地将模块复用在其他项目中，从而提高了代码的重用性。</li><li><strong>测试</strong>：每个模块都可以独立测试，减少了单一应用程序中的复杂度。</li><li><strong>扩展性</strong>：添加新功能时，可以更容易地将新模块集成到现有应用程序中。</li></ol><h3 id="模块聚合">模块聚合</h3><p>模块聚合是将分开开发的模块汇总在一起，形成一个完整的应用程序。通常情况下，会有一个父级 POM（Project Object Model），其中包含所有模块的定义和依赖关系。父级 POM 也可以定义构建的顺序和版本控制策略。对父级模块进行操作时，所有子模块也会进行相同的操作<br><img src="/post-img/Pasted image 20230822162539.png" alt="图片损坏" style="zoom:100%;" /></p><h3 id="依赖继承">依赖继承</h3><p>在父工程中定义依赖管理，在子工程中定义依赖关系，无需声明依赖版本，版本参照父工程中依赖的版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;! --声明此处进行依赖管理--&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--具体的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--spring环境--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org. springframework&lt;/ groupId&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="继承与聚合对比">继承与聚合对比</h3><p>作用<br>聚合用于快速构建项目<br>继承用于快速配置<br>相同点:<br>聚合与继承的pom.xml文件打包方式均为pom，可以将两种关系制作到同一个pom文件中<br>聚合与继承均属于设计型模块，并无实际的模块内容<br>不同点:<br>聚合是在当前模块中配置关系，聚合可以感知到参与聚合的模块有哪些<br>继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己</p><h3 id="属性">属性</h3><p>在pom文件中可以通过property标签自定义属性，相当于define，之后用到时就可以用#{属性名}直接引用，修改属性中的值就可以同时修改所有引用处的值<br>属性分为自定义属性，内置属性，setting属性，java系统属性，环境变量属性<br><img src="/post-img/Pasted image 20230822163251.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="版本管理">版本管理</h2><p><strong>工程版本</strong><br>SNAPSHOT(快照版本)<br>项目开发过程中，为方便团队成员合作，解决模块间相互依赖和时时更新的问题，开发者对每个模块进行构建的时候，输出的临时性版本叫快照版本（(测试阶段版本)，快照版本会随着开发的进展不断更新<br>RELEASE(发布版本)<br>项目开发到进入阶段里程碑后，向团队外部发布较为稳定的版本，这种版本所对应的构件文件是稳定的，即便进行功能的后续开发，也不会改变当前发布版本内容，这种版本称为发布版本</p><p><strong>工程版本号约定</strong><br>约定规范:</p><ol><li>&lt;主版本&gt;.&lt;次版本&gt;,&lt;增量版本&gt;&lt;里程碑版本&gt;</li><li>主版本:表示项目重大架构的变更，如: spring5相较于spring4的迭代</li><li>次版本:表示有较大的功能增加和变化，或者全面系统地修复漏洞</li><li>增量版本:表示有重大漏洞的修复</li><li>里程碑版本:表明一个版本的里程碑（版本内部）。这样的版本同下一个正式版本相比，相对来说不是很稳定，有待更多的测试<br>范例:  5.1.9.RELEASE</li></ol><h2 id="资源加载属性值">资源加载属性值</h2><p>如果想任意配置文件中加载pom文件中定义的属性，可以在配置文件中使用 ${属性名}来调用，同时，需要在pom文件中配置开启此方式，反则编译时无法获取到属性值</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="comment">&lt;!--配置资源文件对应的信息--&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">resource</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&lt;!-设定配置文件对应的位置目录，支持使用属性动态设定路径--&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">directory</span>&gt;</span>$</span><span class="template-variable">&#123;project.basedir&#125;</span><span class="language-xml">/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!--开启对配置文件的资源加载过滤--&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&lt;/ resource&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="跳过测试">跳过测试</h2><ol><li>使用命令跳过测试(执行的指令生命周期必须包含测试环节)</li></ol><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mvn</span> 某个指令 -D skipTests</span><br></pre></td></tr></table></figure><ol start="2"><li>使用界面操作跳过测试<br><img src="/post-img/Pasted image 20230822164623.png" alt="图片损坏" style="zoom:100%;" /></li><li>使用配置跳过测试（还可以包含或排除某些测试用例）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.22.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span><span class="comment">&lt;!--设置跳过测试--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">includes</span>&gt;</span> <span class="comment">&lt;!--包含指定的测试用例--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">inalude</span>&gt;</span>**/User*Test.java<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludes</span>&gt;</span><span class="comment">&lt;!--排除指定的测试用例--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/User*Testcase.java<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">maven相关知识</summary>
    
    
    
    <category term="开发工具" scheme="https://xlxq.fun/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="maven" scheme="https://xlxq.fun/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>消息队列概述</title>
    <link href="https://xlxq.fun/posts/487a8a3.html"/>
    <id>https://xlxq.fun/posts/487a8a3.html</id>
    <published>2024-01-12T11:18:02.000Z</published>
    <updated>2024-01-12T11:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1>消息队列</h1><p>消息队列源于消费者生产者模式，由生产者（Producer）、消息处理中心（Broker）、和消费者（Consumer）三者构成，一般有点对点和发布订阅两种模式：</p><ol><li>点对点模式：多个生产者向同一个队列发送消息，每个消息只能由一个消费者消费</li><li>发布订阅模式：每个消息都能被多个订阅者获取和处理</li></ol><h1>核心功能</h1><p>消息队列（MQ）提供三个核心功能：解耦、异步处理和削峰。</p><ol><li><strong>业务解耦</strong> 是指在分布式系统中，各组件或服务之间不直接通信，而是通过消息队列进行交互。这种方式使得各组件可以独立地进行更新和扩展，增强了系统的灵活性和可扩展性。例如，在电商平台中，订单服务和支付服务可以通过消息队列进行通信，互不影响，从而减少系统间的直接依赖。</li><li><strong>异步处理</strong> 意味着系统的不同部分可以在不同的时间处理信息，从而提高整体效率和响应速度。在异步模型中，一个服务可以发送消息到队列，而不需要等待接收服务的响应。这种模式在高流量应用中尤其重要，如社交媒体平台中的消息传递。</li><li><strong>流量削峰</strong> 指的是使用消息队列来应对短时间内的高流量。通过消息队列，可以平衡负载，确保系统在面对高峰流量时不会崩溃。例如，在促销或大型销售事件期间，消息队列可以帮助电子商务网站处理突发的大量订单请求。</li></ol><h1>特点</h1><p>作为消息队列中间件，需要具备以下能力：</p><ol><li><strong>消息持久化</strong>：确保在系统故障时消息不会丢失。</li><li><strong>高可用性和容错性</strong>：通过集群和故障转移机制确保系统的稳定运行。</li><li><strong>消息确认和可靠传递</strong>：保证消息被正确接收和处理。</li><li><strong>负载均衡</strong>：在多个生产者和消费者间有效分配消息。</li><li><strong>扩展性</strong>：支持根据负载增加节点以扩展系统。</li></ol><h1>常见消息队列</h1><h2 id="RabbitMQ">RabbitMQ</h2><p>少数几个支持 AMQP 协议的消息队列之一。很容易部署和使用。客户端支持多种编程语言。<br>但有以下缺点：</p><ul><li>对消息堆积的支持不好，当大量消息积压的时候，会导致 RabbitMQ 的性能急剧下降。</li><li>RabbitMQ的性能是这几个消息队列中最差的，大概每秒钟只能处理几万到十几万条消息。如果应用对消息队列的性能要求非常高，那么不要选择 RabbitMQ。</li><li>RabbitMQ使用的编程语言是Erlang，扩展和二次开发成本高。</li></ul><h2 id="Kafka">Kafka</h2><p>Kafka与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域，几乎所有的相关开源软件系统都会优先支持 Kafka。Kafka性能高效、可扩展良好并且可持久化。它的分区特性，可复制和可容错都是不错的。Kafka 使用 Scala 和Java 语言开发，设计上大量使用了批量和异步的思想，使得 Kafka能做到超高的性能。Kafka 的性能，尤其是异步收发的性能，是三者中最好的，但与 RocketMQ 并没有量级上的差异，大约每秒钟可以处理几十万条消息。<br>但有以下缺点：</p><ul><li>同步收发消息的响应时延比较高，因为当客户端发送消息的时候，Kafka 采用的是<strong>批量发送</strong>，在它的 Broker中，很多地方都会使用这种先攒一波再一起处理的设计。当业务场景中每秒钟消息数量没有那么多的时候，Kafka 的时延反而会比较高。所以，Kafka 不太适合在线业务场景。topic达到上百个时，吞吐量会大幅下降。<br>高性能的原因：</li></ul><ol><li>磁盘顺序读写：保证了消息的堆积<ul><li>顺序读写，磁盘会<strong>预读</strong>，预读即在读取的起始地址连续读取多个页面，比随机读写的速度快不少，因为免去了磁盘寻道的时间</li></ul></li><li>使用零拷贝：避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。</li><li>分区分段+索引：Kafka的message消息实际上是分布式存储在一个一个小的segment中的，每次文件操作也是直接操作的segment。为了进一步的查询优化，Kafka又默认为分段后的数据文件建立了索引文件，就是文件系统上的.index文件。这种分区分段+索引的设计，不仅提升了数据读取的效率，同时也提高了数据操作的并行度</li><li>批量压缩/读写：多条消息一起压缩，降低带宽</li><li>直接操作page cache，而不是JVM、避免GC耗时及对象创建耗时，且读写速度更高，进程重启缓存也不会丢</li></ol><h2 id="RocketMQ">RocketMQ</h2><p>RocketMQ 有着不错的性能，<strong>稳定性和可靠性</strong>，具备一个现代的消息队列应该有的几乎全部功能和特性，并且它还在持续的成长中。RocketMQ 有非常<strong>活跃的中文社区</strong>，大多数问题可以找到中文的答案。RocketMQ 使用 Java 语言开发，源代码相对比较容易读懂，容易对RocketMQ 进行扩展或者二次开发。RocketMQ 对<strong>在线业务</strong>的响应时延做了很多的优化，大多数情况下可以做到毫秒级的响应。</p>]]></content>
    
    
    <summary type="html">消息队列</summary>
    
    
    
    <category term="消息队列" scheme="https://xlxq.fun/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
    <category term="消息队列" scheme="https://xlxq.fun/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>CAS</title>
    <link href="https://xlxq.fun/posts/969d9481.html"/>
    <id>https://xlxq.fun/posts/969d9481.html</id>
    <published>2023-11-15T12:18:02.000Z</published>
    <updated>2023-11-15T12:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1>什么是CAS</h1><p>CAS（Compare And Swap）是一种多线程并发控制的技术，是一种原子操作。它用于解决多个线程同时修改同一内存位置时可能发生的竞态条件（Race Condition）问题。它是乐观锁思想的一种实现，尤其是在并发量大的业务场景下保证单个实例的原子性，java类库中java.util.concurrent.atomic包下一些方法，均使用CAS处理。CAS 操作是原子的，即整个过程中不会被中断或切换到其他线程执行。因此，CAS 操作在并发编程中常用于实现无锁算法、线程安全的数据结构以及乐观锁机制。</p><h1>操作流程</h1><p>CAS 操作包含三个参数：<strong>内存位置</strong>（通常是一个变量的内存地址）、<strong>期望值</strong>（即当前内存位置的预期值）和<strong>新值</strong>。CAS 操作执行的逻辑是：在操作提交之前，与原获取到的值先进行比较，如果当前内存位置的值等于期望值，则将该位置的值更新为新值；否则，重新获取内存位置的值，与期望值进行比较。 基本操作流程如下：</p><ol><li>读取内存位置的当前值。</li><li>比较当前值与预期值。</li><li>如果相同，则用新值更新内存位置的值，并返回成功标志。</li><li>如果不同，则不做任何操作，并返回失败标志，（稍后重试）。</li></ol><h1>原理</h1><ul><li><strong>UNSAFE</strong> 类：在早期的 JDK 版本中，<code>sun.misc.Unsafe</code> 类提供了对底层内存的直接操作，可以用于实现 CAS 操作。但是，这种方式使用不当可能会导致不安全的操作，因此在 JDK9 中标记为不推荐使用。</li><li><strong>JNI（Java Native Interface）</strong>：通过 JNI 调用本地方法，利用底层平台的原子性操作指令（如 <code>cmpxchg</code> 指令）来实现 CAS 操作。</li><li><strong>Java 内置的 CAS 支持</strong>：一些 JVM 实现提供了直接支持 CAS 操作的原生实现，通过底层的硬件支持或者 JVM 内部的优化来实现 CAS 操作的效率和性能。</li></ul><p>java.util.concurrent.atomic包中的一些方法使用了CAS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">counter.incrementAndGet();</span><br></pre></td></tr></table></figure><p>跟踪可以发现，最终调用的是一个native方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IntrinsicCandidate</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSetInt</span><span class="params">(Object o, <span class="type">long</span> offset,  </span></span><br><span class="line"><span class="params">                                             <span class="type">int</span> expected,  </span></span><br><span class="line"><span class="params">                                             <span class="type">int</span> x)</span>;</span><br></pre></td></tr></table></figure><p>这个方法的注释说：这个方法的作用是原子性地将 Java 变量更新为指定的值 x，但仅当它当前持有预期的值 expected 时才进行更新。这个操作具有内存语义上的 volatile 读和写，即读取和写入操作具有与 volatile 变量相同的内存语义，保证了对变量的读取和写入操作在内存中的可见性。也就是说，java中使用<strong>CAS+volatile</strong>为我们提供了一种实现并发编程的方法（即Atomic系列类），而CAS的底层调用的是操作系统的一个原子命令。</p><h1>优缺点</h1><h2 id="优点">优点</h2><ul><li><strong>高效性</strong>：CAS 操作是基于硬件支持的原子操作，比传统的锁机制更高效。</li><li><strong>无锁化</strong>：CAS 操作不需要使用锁，避免了锁带来的性能开销和线程阻塞。</li><li><strong>并发安全</strong>：CAS 操作保证了对共享资源的并发访问的安全性，避免了竞态条件和数据不一致的问题。</li></ul><h2 id="可能的问题">可能的问题</h2><ul><li><strong>ABA问题</strong>：CAS 操作可能会忽略中间状态的变化，导致 ABA 问题（即在其他线程修改前后，被比较的值恰好变回了原来的值），这个问题可以通过添加版本号或时间戳的方法来解决（AtomicStampedReference采取的是这种方式）。</li><li><strong>自旋消耗性能</strong>：CAS 操作会引入自旋等待，当多个线程同时尝试更新相同的内存位置时，可能会导致自旋等待过长，影响性能。</li><li><strong>只能修改一个变量</strong>：CAS不能确保代码块的原子性，因为CAS机制确保的是一个变量的原子性操作，并不能保证整个代码块的原子性。如果多个变量共同进行原子性的更新操作，就需要用lock或者synchronized了。</li></ul>]]></content>
    
    
    <summary type="html">CAS的简介和原理</summary>
    
    
    
    <category term="java" scheme="https://xlxq.fun/categories/java/"/>
    
    
    <category term="java" scheme="https://xlxq.fun/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>synchronized详解</title>
    <link href="https://xlxq.fun/posts/f0baa025.html"/>
    <id>https://xlxq.fun/posts/f0baa025.html</id>
    <published>2023-11-15T12:18:02.000Z</published>
    <updated>2023-11-15T12:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1>并发编程中的三大问题</h1><ol><li><strong>原子性问题（Atomicity）：</strong><ul><li><strong>定义：</strong> 保证一个操作是不可中断的，要么全部执行成功，要么全部不执行。</li><li><strong>问题：</strong> 当多个线程同时执行一组操作时，可能出现一部分操作已经执行而另一部分没有执行的情况，导致数据不一致性。</li></ul></li><li><strong>可见性问题（Visibility）：</strong><ul><li><strong>定义：</strong> 一个线程对共享变量的修改能够及时被其他线程看到。</li><li><strong>问题：</strong> 当一个线程修改了共享变量的值，其他线程可能无法立即感知到这个变化，从而导致数据的不一致性。</li></ul></li><li><strong>有序性问题（Ordering）：</strong><ul><li><strong>定义：</strong> 确保程序执行的顺序与代码的书写顺序一致。</li><li><strong>问题：</strong> 由于编译器的优化或硬件的乱序执行，代码的执行顺序可能与预期不一致，导致意外的结果。</li></ul></li></ol><h1>JMM（Java Memory Modle）</h1><p>Java内存模型，是Java虚拟机规范中所定义的一种内存模型，Java内存模型是标准化的，屏蔽掉了底层不同计算机的区别。它是一套规范，描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节。Java内存模型是一套在多线程读写共享数据时，对共享数据的可见性、有序性、和原子性的规则和保障。</p><ol><li>主内存：是所有线程都共享的，都能访问的。所有的共享变量都存储于主内存。</li><li>工作内存：每一个线程有自己的工作内存，工作内存只存储该线程对共享变量的<strong>副本</strong>。线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接访问对方工作内存中的变量。</li><li>JMM是一种抽象的逻辑概念，Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉</li></ol><h2 id="JMM中主内存与工作内存之间的数据交互过程">JMM中主内存与工作内存之间的数据交互过程</h2><p>Java内存模型中定义了以下8种操作来完成，主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的。<br>分别是lock、read、load、use、assign、store、write、unlock<br>1.如果对一个变量执行lock操作，将会清空工作内存中此变量的值<br>2.对一个变量执行unlock操作之前，必须先把此变量同步到主内存中</p><h1>synchronized与三大特性</h1><p>synchronized可以保证原子性、有序性、可见性，其中有序性和可见性是通过JMM规范的八个命令中的lock和unlock命令保证的</p><ol><li><strong>原子性（Atomicity）：</strong><ul><li><code>synchronized</code> 保证了代码块或方法中的所有操作要么全部执行成功，要么全部失败，不会被其他线程中断。当一个线程获得锁时，它将独占锁，其他线程必须等待释放锁后才能继续执行。</li></ul></li><li><strong>可见性（Visibility）：</strong><ul><li>当一个线程获得锁进入 <code>synchronized</code> 代码块时，它会清空工作内存中的共享变量副本，强制从主内存中重新读取共享变量的值。同样，线程在释放锁的时候会将修改后的值刷新回主内存，这样其他线程能够感知到这些变化。这确保了对共享变量的修改对其他线程可见。</li></ul></li><li><strong>有序性（Ordering）：</strong><ul><li>as-if-serial：不管编译器和CPU如何重排序，必须保证在单线程情况下程序的结果是正确的。也就是逻辑上有先后关系的代码不会被重排序，例如a=1,b=2,c=a+b可能被重排序为b=2,a=1,c=a+b，但不可能被重排序为a=1,c=a+b,b=2</li><li><code>synchronized</code> 保证了线程进入和退出临界区的有序性。即，一个线程在释放锁之前，必须把修改过的变量刷新到主内存，而获取锁的线程要求从主内存中读取变量的最新值。这就确保了线程之间的有序性，防止了乱序执行。</li></ul></li></ol><h1>特性</h1><h2 id="可重入锁">可重入锁</h2><p>一个线程在持有锁的情况下，可以再次获取相同的锁，而不会造成死锁。这是通过<strong>为每个锁关联一个持有者线程和一个计数器</strong>来实现的。当一个线程第一次获取锁时，计数器为1，每次递归获取锁，计数器递增。只有当计数器降为零时，锁才会被释放。这确保了线程可以多次进入同一个 <code>synchronized</code> 代码块，而不会发生死锁。可重入锁是一种提高程序灵活性和避免死锁的设计。</p><h2 id="不可中断">不可中断</h2><p>不可中断：一个线程获得锁后，另一个线程想要获得锁，必须处于阻塞或等待状态，如果第一个线程不释放锁，第二个线程会一直阻塞或等待，不可被中断。</p><h1>原理</h1><h2 id="monitorenter">monitorenter</h2><ol><li>每一个对象都会和一个<strong>监视器</strong>monitor关联。监视器被占用时会被锁住，其他线程无法来获取该monitor。当JVM执行某个线程的某个方法内部的monitorenter时，它会尝试去获取当前对象对应的monitor的所有权。其过程如下︰</li><li>获取当前对象对应的monitor的所有权的过程：<ul><li>若monior的进入数为0，线程可以进入monitor，并将monitor的进入数置为1。当前线程成为monitor的owner (所有者）</li><li>若线程已拥有monitor的所有权，允许它重入monitor，则进入monitor的进入数加1</li><li>若其他线程已经占有monitor的所有权，那么当前尝试获取monitor的所有权的线程会被阻塞，直到monitor的进入数变为0，才能重新尝试获取monitor的所有权。</li></ul></li><li>synchronized的锁对象会关联一个monitor,这个monitor不是我们主动创建的,是JVM的线程执行到这个同步代码块,发现锁对象没有monitor就会创建monitor,monitor内部有两个重要的成员变量：<ul><li>owner:拥有这把锁的线程</li><li>recursions会记录线程拥有锁的次数,当一个线程拥有monitor后其他线程只能等待</li></ul></li></ol><h2 id="monitorexit">monitorexit</h2><ol><li>能执行monitorexit指令的线程一定是拥有当前对象的monitor的所有权（owner）的线程。</li><li>执行monitorexit时会将monitor的进入数减1。当monitor的进入数减为0时，当前线程退出monitor，不再拥有monitor的所有权，此时其他被这个monitor阻塞的线程可以尝试去获取这个monitor的所有权monitorexit释放锁。</li><li>monitorexit插入在方法结束处和异常处，JVM保证每个monitorenter必须有对应的monitorexit，因此<strong>synchornized出现异常时会释放锁</strong></li></ol><h2 id="对象头的结构">对象头的结构</h2><p>在 HotSpot JVM 中，对象头包括两部分信息，分别是 Mark Word 和 Klass Pointer</p><ol><li>Mark Word用于存储对象自身的运行时数据，如哈希码(HashCode ) 、GC分代年龄、锁状态标志线程持有的锁、偏向线程ID、偏向时间戳等等，占用内存大小与虚拟机位长一致。</li><li>Klass Pointer用于存储对象的类型指针，该指针指向它的类元数据，JVM通过这个指针确定对象是哪个类的实例。该指针的位长度为JVM的一个字大小，即32位的JVM为32位，64位的JVM为64位。</li></ol><h1>锁升级</h1><ol><li><strong>偏向锁（Biased Locking）：</strong><ul><li>初始时，一个对象的头部信息会包含偏向锁标记。当某个线程访问这个对象并获取锁时，会将该线程的ID记录在对象头中，并将偏向锁标记置为1。之后，如果同一个线程再次访问该对象，无需竞争，直接获取锁。这提高了同一线程多次获取锁的效率。</li></ul></li><li><strong>轻量级锁（Lightweight Locking）：</strong><ul><li>当有多个线程竞争同一把锁时，偏向锁就不再合适。此时，锁会升级为轻量级锁。在轻量级锁的情况下，当前获取到锁的线程将对象的Mark Word复制到栈帧中的Lock Recod中，Mark Word更新为指向Lock Record的指针。其他线程在尝试获取锁时会将对象头的 Mark Word 复制到线程的栈帧中，并进行自旋操作，而不是直接阻塞线程。如果自旋失败（10次以上仍未获取），锁升级为重量级锁。</li></ul></li><li><strong>重量级锁（Heavyweight Locking）：</strong><ul><li>当轻量级锁自旋失败，多个线程竞争同一把锁的时候，锁会升级为重量级锁。在这种情况下，JVM 使用操作系统提供的互斥量来实现锁。此时，如果一个线程获取了锁，其他线程必须阻塞等待。重量级锁是通过对象头关联的monitor（见补充）实现的。</li></ul></li></ol><h1>优化</h1><ol><li>锁消除：在synchronized修饰的代码中，如果不存在操作临界资源的情况，编译时JIT触发锁消除，相当于无锁</li><li>锁膨胀：如果在一个循环中，频繁的获取和释放做资源，这样带来的消耗很大，锁膨胀就是将锁的范围扩大，避免频繁的竞争和获取锁资源带来不必要的消耗</li><li>锁升级：synchronized在JDK1.6之前，获取不到锁，立即挂起当前线程，所synchronized性能比较差，之后做了锁升级的优化，即无锁—&gt;偏向锁—&gt;轻量级锁—&gt;重量级锁；有的观点认为锁只能升级，不能降级，也有说锁降级确实是会发生的，当 JVM 进入安全点（SafePoint）的时候，会检查是否有闲置的 Monitor，然后试图进行降级。</li></ol><h1>补充</h1><h2 id="java中对象的结构">java中对象的结构</h2><p>java对象由三部分组成：对象头，实例数据，对齐填充</p><ol><li>对象头：由 Mark Word 和 Klass Pointer组成</li><li>实例数据：就是类中定义的成员变量</li><li>对齐填充：并不是必然存在的，也没有什么特别的意义，他仅仅起着占位符的作用，由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头正好是8字节的倍数，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</li></ol><h2 id="monitor">monitor</h2><ol><li>每一个Java对象都<code>可以</code>与一个监视器monitor关联，我们可以把它理解成为一把锁，当一个线程想要执行一段被synchronized圈起来的同步方法或者代码块时，该线程得先获取到synchronized修饰的对象对应的monitor。</li><li>monitor并不是随着对象创建而创建的。我们是通过synchronized修饰符告诉VM需要为我们的某个对象创建关联的monitor对象。</li><li>monitor的重要成员变量<ul><li>_owner:初始时为NULL。当有线程占有该monitor时，owner标记为该线程的唯一标识。当线程释放monitor时，owner又恢复为NULL。owner是一个临界资源，JVM是通过CAS操作来保证其线程安全的。</li><li>_CXq∶竞争队列，所有请求锁的线程首先会被放在这个队列中（单向链接）。_cxq是一个临界资源，JVM通过CAS原子指令来修改_cxq队列。修改前_cxq的旧值填入了node的next字段，_cxq指向新值（新线程)。因此_cxq是一个后进先出的stack(栈)。</li><li>_EntryList : _cxq队列中有资格成为候选资源的线程会被移动到该队列中。</li><li>_WaitSet :因为调用wait方法而被阻塞的线程会被放在该队列中。</li></ul></li><li>monitor是重量级锁：<ul><li>ObjectMonitor（hotspot的monitor实现）的函数调用中会涉及到Atomic::cmpxchg_ptr，Atomic:.inc_ptr等内核函数，执行同步代码块，没有竞争到锁的对象会park()被挂起，竞争到锁的线程会unpark()唤醒。这个过程中存在操作系统用户态和内核态的转换，这种切换会消耗大量的系统资源。所以synchronized在Java语言中是一个重量级(Heavyweight)的操作。</li></ul></li></ol><h2 id="安全点（safe-point）">安全点（safe point）</h2><p>安全点是程序执行的一个状态，JVM 在这个状态下，能够确保所有线程都在安全位置，不会出现对对象引用的修改。在安全点上，JVM 可以停止所有线程，进行垃圾回收、线程栈的修改等操作，而不会导致数据不一致或错误的状态。在安全点上，线程不会在执行关键的、可能导致数据不一致的代码。<br>安全点通常发生在一些特定的位置，包括：</p><ol><li><strong>方法调用：</strong><ul><li>在方法调用的地方，JVM 可以方便地确保所有线程都在一个安全的状态。这可以是方法的入口或返回点。</li></ul></li><li><strong>循环跳跃：</strong><ul><li>在循环的迭代点，例如 for 循环的迭代点，也是安全点。这是因为在循环迭代点，线程通常都在相对较安全的位置。</li></ul></li><li><strong>异常抛出：</strong><ul><li>在抛出异常的地方，例如在 <code>throw</code> 语句附近，也是一个潜在的安全点。</li></ul></li><li><strong>代码生成器插入的安全点：</strong><ul><li>代码生成器在生成机器码时，会在适当的位置插入安全点，以确保在执行这些机器码时，所有线程都在一个安全的状态。。在某些情况下，为了减少安全点的频率，JVM 可能会选择较少的插入安全点，从而提高程序的运行效率。</li></ul></li></ol><h2 id="synchronized与Lock的区别">synchronized与Lock的区别</h2><ol><li>synchronized是关键字，而Lock是一个接口。</li><li>synchronized会自动释放锁，而Lock必须手动释放锁。</li><li>synchronized是不可中断的，Lock可以中断也可以不中断。</li><li>通过Lock可以知道线程有没有拿到锁，而synchronized不能。</li><li>synchronized能锁住方法和代码块，而Lock只能锁住代码块。</li><li>Lock可以使用读锁提高多线程读效率。</li><li>synchronized是非公平锁，ReentrantLock可以控制是否是公平锁。</li></ol><h1>总结</h1><ol><li>synchornized是可重入锁，不可中断锁</li><li>可以保证原子性，有序性和可见性（JMM中定义的8种原子操作）</li><li>原理是java对象头（偏向锁、轻量级锁）以及monitor（重量级锁）</li><li>jdk6后提供了锁优化：锁消除、锁膨胀、锁升级</li></ol>]]></content>
    
    
    <summary type="html">java基础知识</summary>
    
    
    
    <category term="源码解析" scheme="https://xlxq.fun/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
    
    <category term="java" scheme="https://xlxq.fun/tags/java/"/>
    
  </entry>
  
</feed>

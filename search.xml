<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JFR(java flight recoder)</title>
      <link href="/posts/faf12a24.html"/>
      <url>/posts/faf12a24.html</url>
      
        <content type="html"><![CDATA[<h1>什么是JFR</h1><p>Java Flight Recorder (JFR) 是 Java 虚拟机 (JVM) 中的一个事件记录器，它能够记录运行时的各种信息，如方法调用、垃圾回收、线程活动等，用于监控和调优 Java 应用程序的性能。使用 Java Flight Recorder，可以轻松地收集和分析应用程序在生产环境中的运行时信息，以便更好地理解应用程序的行为、性能瓶颈和潜在问题。它提供了丰富的事件类型，可以捕获各种级别的信息，从 JVM 内部的细节到应用程序级别的指标都可以覆盖。这些事件可以导出为 JFR 文件，然后可以使用 JMC 或其他工具对其进行分析。</p><h1>关键概念</h1><h2 id="事件">事件</h2><p>JFR 收集 Java 应用程序运行时 JVM 中发生的事件。这些事件与JVM本身的状态或者程序的状态有关。事件具有名称、时间戳和附加信息（如线程信息、执行堆栈和堆状态）。</p><p>JFR收集<strong>三种类型的事件</strong>：</p><ul><li><strong>即时事件</strong>一旦发生就会立即记录</li><li>如果持续时间超过指定阈值，则记录<strong>持续时间事件</strong></li><li><strong>样本事件</strong>用于对系统活动进行采样</li></ul><h2 id="数据流">数据流</h2><p>JFR 收集的事件包含大量数据。因此，JFR 的数据导出被设计为异步执行，不会妨碍程序。<br>JFR 将有关事件的数据保存在单个输出文件<code>Flight.jfr</code> 中。<br>众所周知，磁盘 I/O 操作的开销相当大。因此，JFR 在将数据块刷新到磁盘之前使用<strong>各种缓冲区</strong>来存储收集到的数据。由于在同一时刻，一个程序可能有多个具有不同选项的注册进程。因此，我们可能会在输出文件中发现比请求的数据更多的数据，或者可能不按时间顺序排列。但如果我们使用 JMC，我们甚至可能不会注意到这一事实，因为它按时间顺序可视化事件。<br><strong>在极少数情况下，JFR 可能无法刷新数据</strong>（例如，事件太多或停电时）。如果发生这种情况，JFR 会尝试通知我们输出文件可能缺少一段数据。</p><h1>特性</h1><p>JFR具有以下关键特性：</p><ol><li><strong>低开销的持续性能监控</strong>: JFR 可以在生产环境中以低开销的方式持续地监控 JVM 的性能，旨在<strong>尽可能少地影响正在运行的应用程序的性能</strong>。它通过轻量级的事件采集机制来收集数据，几乎不会对应用程序的性能产生影响。</li><li><strong>丰富的事件数据</strong>: JFR 可以收集丰富的事件数据，包括 CPU 使用情况、内存分配情况、线程活动、垃圾收集情况、锁竞争、I/O 操作等。基于事件采集可以分析非常底层的信息，例如对象分配，方法采样与热点方法定位与调用堆栈，安全点分析与锁占用时长与堆栈分析，GC 相关分析以及 JIT 编译器相关分析</li><li><strong>低延迟的数据记录</strong>: JFR 使用异步方式记录事件数据，因此几乎不会对应用程序的性能产生明显的影响。它能够以很低的延迟记录事件，即使在高负载的情况下也能保持高效率。</li><li><strong>动态配置</strong>: JFR 允许用户在运行时动态地配置数据采集和记录行为。可以通过 JFR 控制台或者命令行工具来启动、停止、配置和导出录制会话。</li><li><strong>完善的API定义</strong>：用户可以自定义事件生产与消费。</li></ol><h1>使用</h1><p>为了使用JFR，我们可以通过两种方式来激活它：</p><ol><li>当启动 Java 应用程序时，通过命令行传递参数启动</li><li>当 Java 应用程序已在运行时，传递jcmd工具的诊断命令<br>JFR停止收集后，可以获得本次收集的jfr文件，将该文件提供给可视化工具（例如JMC，<strong>Java Mission Control</strong>），就可以以直观的方式可视化有关事件的数据，从而准确分析程序的性能瓶颈</li></ol><h2 id="命令行启动">命令行启动</h2><p>使用javac将.java文件编译为.class文件后，可以使用以下命令启动JFR：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//<span class="type">path</span>-<span class="keyword">to</span>-<span class="keyword">class</span>-file 是应用程序的入口点_*.class_文件。</span><br><span class="line">java -XX:+UnlockCommercialFeatures -XX:+FlightRecorder </span><br><span class="line">  -XX:StartFlightRecording=duration=<span class="number">200</span>s,filename=flight.jfr <span class="type">path</span>-<span class="keyword">to</span>-<span class="keyword">class</span>-file</span><br></pre></td></tr></table></figure><p>此命令启动应用程序并激活JFR，记录立即开始，持续时间不超过 200 秒。收集的数据保存在输出文件 Flight.jfr 中。</p><h2 id="jcmd工具">jcmd工具</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jcmd &lt;pid|MainClass&gt; &lt;command&gt; [parameters]</span><br><span class="line">eg:  jcmd 1234 JFR.start <span class="attribute">duration</span>=100s <span class="attribute">filename</span>=flight.jfr</span><br></pre></td></tr></table></figure><p>&lt;command&gt;包括:</p><ul><li><strong>JFR.start</strong>  – 开始新的 JFR 录制</li><li><strong>JFR.check</strong>  – 检查正在运行的 JFR 记录</li><li><strong>JFR.stop</strong>  – 停止特定的 JFR 录制</li><li><strong>JFR.dump</strong>  – 将 JFR 记录的内容复制到文件<br>每个命令都有一系列参数,具体可参考<a href="https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/comline.htm#JFRUH190">Java Flight Recorded 官方文档</a>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 可观测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 可观测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenTelemetry</title>
      <link href="/posts/381cfacc.html"/>
      <url>/posts/381cfacc.html</url>
      
        <content type="html"><![CDATA[<h1>为什么需要OpenTelemetry</h1><ol><li><strong>分布式系统复杂性增加</strong>：随着云计算和微服务架构的普及，现代软件系统变得越来越复杂。在这样的系统中，一个请求可能会涉及多个服务和组件，跨越多个服务器和数据中心。因此，跟踪请求在系统中的路径和性能变得至关重要，以便定位和解决潜在的问题。</li><li><strong>缺乏标准化的跟踪和监控解决方案</strong>：过去，每个厂商或项目可能会使用自己的监控工具和方法，导致了监控数据的碎片化和不一致性。OpenTelemetry的出现（OpenTracing和OpenCensus合并而来）为开发人员提供了一个<strong>统一的标准</strong>，使得跨不同系统和语言的监控数据能够更加一致和可比较。</li><li><strong>提高系统的可观察性</strong>：可观察性是指<strong>对系统内部状态和行为的理解和监控程度</strong>。通过使用OpenTelemetry，开发人员可以更好地了解他们的系统在运行时的状态和行为，从而及时发现和解决潜在的问题，提高系统的可靠性和稳定性。</li></ol><h1>基本概念</h1><h2 id="可观测性">可观测性</h2><p>可观测性使我们能够通过提出关于某个系统的问题从外部了解该系统，而无需了解其内部工作方式，这需要应用程序能够发出<code>跟踪</code>，<code>日志</code>，<code>指标</code>等<code>信号</code>,以便我们能提出相关的问题</p><h3 id="日志（logs）">日志（logs）</h3><ol><li><strong>日志</strong>是由服务或其他组件发出的<strong>带时间戳的消息</strong>。</li><li>日志不一定与任何特定的用户请求或事务相关联，区别于跟踪。</li><li>它们几乎存在于软件的各个地方，并且过去被开发人员和操作员广泛依赖，以帮助他们理解系统行为。在 OpenTelemetry 中，任何不属于分布式追踪或度量的数据都被视为日志。例如，事件（Events）是一种特定类型的日志。日志通常包含详细的调试/诊断信息，例如操作的输入、操作的结果以及与该操作有关的任何支持性元数据。</li><li>通常缺乏上下文信息，需要作为span的一部分或与跟踪和跨度相关联时，才更好发挥作用。</li></ol><h3 id="跟踪（Distributed-Traces）">跟踪（Distributed Traces）</h3><ol><li>也称<strong>分布式跟踪</strong>，记录了请求（由应用程序或最终用户发起）在多服务架构中传播时所经过的路径，比如微服务和无服务器应用程序。</li><li>提高了我们应用程序或系统的健康状况的可见性，可以在分布式系统中确定性能问题的原因，或者调试在本地难以重现的行为</li><li>跟踪通过 <strong>分解请求在分布式系统中的传递过程</strong> 来便于调试和理解分布式系统</li><li>一个跟踪由一个或多个<strong>跨度</strong>组成。第一个跨度表示根跨度，每个根跨度表示从开始到结束的请求，更低层级的跨度提供了有关请求期间发生的更详细的上下文（或组成请求的步骤）的信息。</li></ol><h4 id="跨度（spans）">跨度（spans）</h4><p><strong>跨度</strong>跟踪请求所进行的具体操作，描绘了该操作执行期间发生了什么事情。包含名称、与时间相关的数据、结构化日志消息和其他元数据（即属性），以提供有关所跟踪操作的信息。如：</p><ol><li><strong>上下文（Context）</strong>：span 的上下文包括了<strong>唯一标识</strong>该 span 的 ID，以及与其他 span 之间<strong>建立关联所需的信息</strong>，比如父 span 的 ID、当前跟踪（trace）的 ID 等。</li><li><strong>属性（Attributes）</strong>：属性是键值对，用于描述 span 的<strong>特征和元数据信息</strong>。例如，可以记录 span 的名称、开始时间、持续时间、所属服务的名称、请求的 URL 等。属性通常用于标识和分类 span，以及提供有关 span 执行上下文的其他信息。</li><li><strong>事件（Events）</strong>：事件是与 span 相关的<strong>时间戳和描述性消息</strong>的组合。它们用于记录 span 执行期间发生的重要事件，比如函数调用、数据库查询、网络请求等。通过记录事件，可以了解 span 的执行流程，以及在执行过程中发生的具体操作。</li><li><strong>链接（Links）</strong>：链接用于<strong>建立 span 之间的关系</strong>，通常用于描述跨越服务边界的操作。一个 span 可能会链接到其他 span，以表示它们之间的逻辑关联。例如，如果一个 span 包含了对外部服务的调用，可能会在该 span 中添加链接指向被调用服务的 span，以建立两者之间的关系。</li><li><strong>状态（Status）</strong>：状态用于表示 <strong>span 的执行结果</strong>。例如，一个 span 可能被标记为成功、失败或者取消。状态信息可以帮助了解 span 的执行情况，以及可能存在的问题或异常。</li><li><strong>上下文传递（Context Propagation）</strong>：上下文传递是指在分布式系统中跨越服务边界传递 span 上下文的过程。这包括了在网络请求中传递 span ID 和跨度 ID，以便在服务之间建立关联，并跟踪整个请求的执行流程。</li><li><strong>种类（Span Kind）</strong>：可取值<code>Client</code>, <code>Server</code>, <code>Internal</code>, <code>Producer</code>, 或 <code>Consumer</code>，为跟踪后端提供了一个关于应该如何组装跟踪的提示。</li></ol><h4 id="上下文传播（Context-Propagation）">上下文传播（Context Propagation）</h4><p>上下文传播是实现分布式追踪的核心概念。有了上下文传播，可以将 spans 相互关联并组装成一个追踪，而不管 spans 是在哪里生成的。我们通过两个子概念来定义上下文传播：Context 和 Propagation。</p><ol><li><strong>Context（上下文）</strong> 是一个对象，它包含了发送和接收服务之间关联一个 span 所需的信息，并将其与整个追踪关联起来。例如，如果服务 A 调用服务 B，A创建的span中包含Trace ID和span ID，则B创建下一个span时，沿用该Trace ID，并且将自己的parent ID复制为A的span ID，表示当前创建的span的父级是A创建的span</li><li><strong>Propagation（传播）</strong> 是在服务和进程之间传递上下文的机制。它将上下文对象序列化或反序列化，并提供相关的追踪信息，以将其从一个服务传播到另一个服务中。</li></ol><h3 id="指标（metrics）">指标（metrics）</h3><ol><li><strong>指标</strong>是在运行时捕获的服务的<strong>度量</strong>，即可以用于观测应用程序运行状态的数据集。捕获度量的时刻被称为<strong>指标事件</strong>，它不仅包括度量本身，还包括捕获时的时间和关联的元数据。</li><li>应用程序和请求指标是可用性和性能的重要指标。自定义指标可以提供洞察力，了解可用性指标如何影响用户体验或业务。收集的数据可用于发出故障警报或在需求高峰时自动触发调度决策，以扩展部署规模。</li><li>组件：<br>    - Metric Provider：是<code>Meter</code>的工厂。在大多数应用程序中，Meter Provider只会初始化一次，其生命周期与应用程序的生命周期相匹配。<br>    - Meter创建指标工具<code>Metric Instruments</code><br>    - Metric Instrument用于捕获度量<code>Metric</code>，有多种类别，例如计数器，仪表盘，直方图等<br>    - Metric Exporter将度量数据发送给消费者。这个消费者可以是用于调试和开发时的标准输出，也可以是OpenTelemetry收集器或您选择的任何开源或供应商后端<br>    - 获取metric并发送给消费者的链路可描述如下：<code>Metric Provider---&gt;Meter---&gt;Metric Instruments---&gt;Metric---&gt;Metric Exporter---&gt;Consumer</code></li></ol><h3 id="行李（baggage）">行李（baggage）</h3><ol><li>Baggage 是 Span 之间传递的上下文信息。它是一个键值存储，与 Trace 中的 Span Context 一起驻留，使值可用于在该 Trace 中创建的任何 Span 。</li><li>Baggage区别于SpanContext：<br>    - Baggage允许将键值对数据（例如用户ID、会话ID等）附加到跨越多个服务的请求中，并在请求链中传递，通常用于传递与请求相关的元数据。相当于为其他信号（signals）提供了一个存储额外信息的容器。<br>    - Span Context是跨度（Span）之间传播的元数据的容器，用于将跨度连接起来形成请求链。由跨度创建和管理，一旦创建了 Span，它们就是不可变的。</li><li>Baggage存储在与当前上下文一起的 HTTP 标头中，会有被篡改或者泄露的风险，应该被用于可以公开的数据。</li></ol><h2 id="组件（Components）">组件（Components）</h2><h3 id="规范（Specification）">规范（Specification）</h3><ol><li><strong>API：</strong> 为生成和关联跟踪、度量和日志数据定义了数据类型和操作。</li><li><strong>SDK：</strong> 为 API 的特定语言实现定义了要求。此处还定义了配置、数据处理和导出的概念。</li><li><strong>数据：</strong> 定义了 OpenTelemetry 协议（<strong>OTLP</strong>）和供应商无关的语义约定， OpenTelemetry并不提供可视化和存储服务，规范数据格式约定可以满足数据在各后端存储供应商之间高效低成本的迁移等操作。</li></ol><h3 id="收集器（Collectors）">收集器（Collectors）</h3><ol><li>用于接收和处理来自应用程序的跟踪、度量和日志数据。</li><li>可以用于预处理、聚合、过滤和路由数据，然后将其导出到配置的一个或多个后端系统。</li></ol><h3 id="K8s-运算符">K8s 运算符</h3><p>OpenTelemetry 运算符是 Kubernetes 运算符的一种实现。该运算符管理 OpenTelemetry 收集器，并使用 OpenTelemetry 对工作负载进行自动仪表化。</p><h3 id="函数即服务资产">函数即服务资产</h3><p>OpenTelemetry 支持不同云供应商提供的监控函数即服务的各种方法。OpenTelemetry 社区目前提供了预构建的 Lambda layer，能够自动仪表化您的应用程序，还提供了用于手动或自动仪表化应用程序时可以使用的独立 Collector Lambda layer。</p><h3 id="特定语言的-API-SDK-实现">特定语言的 API &amp; SDK 实现</h3><ol><li><strong>仪表库（Instrumentation Libraries）</strong>：<br>    - 这些库用于在特定编程语言的应用程序中自动或手动地集成分布式追踪、度量和日志记录功能。它们提供了针对特定语言和框架的 API 和工具，使开发人员能够轻松地将追踪和监视功能集成到他们的应用程序中。</li><li><strong>导出器（Exporters）</strong>：<br>    - 针对特定语言的 SDK 实现通常会包括用于将收集的跟踪、度量和日志数据导出到后端存储和分析系统的导出器。这些导出器可以与特定语言的常见后端系统集成，如数据存储、监控系统等。</li><li><strong>自动仪表化（Automatic Instrumentation）</strong>：<br>    - 一些特定语言的 SDK 实现可能会提供自动仪表化功能，这使得开发人员可以轻松地自动检测和仪表化应用程序的组件，无需手动添加代码。</li><li><strong>资源探测器（Resource Detectors）</strong>：<br>    - 这些组件用于自动发现和识别运行应用程序的环境和基础设施，以帮助收集有关应用程序的上下文信息。它们可以帮助开发人员更好地理解和监视他们的应用程序在不同环境中的运行情况。</li><li><strong>跨服务传播器（Cross-Service Propagators）</strong>：<br>    - 特定语言的 SDK 实现可能会包括用于在分布式系统中传播跟踪上下文的传播器，以确保请求链中的所有跨度都与同一跟踪相关联。</li><li><strong>采样器（Samplers）</strong>：<br>    - 一些特定语言的 SDK 实现可能会包括采样器，用于控制跟踪数据的收集率，以确保系统在大规模部署时能够有效地处理和存储跟踪数据。</li></ol><h2 id="资源">资源</h2><ol><li>资源（Resource）是描述应用程序、服务或系统的特性和属性的实体。</li><li>资源提供了有关应用程序运行环境的关键信息，如应用程序的名称、版本、运行环境、部署位置等。</li><li>资源通常是与跟踪、度量和日志记录等监视数据相关联的一部分。</li></ol><h2 id="采样">采样</h2><ol><li>分布式跟踪很多时候并不需要跟踪所有的请求流程，甚至很大一部分的成功请求对分析系统中潜在的问题并没有什么实际作用，因此并不总是需要大量的数据来获得正确的洞察力，而只需要正确的或者说可能有用的数据样本。</li><li>采样的核心思想是控制发送到可观察性后端的跨度，以降低摄取成本。</li><li>常见的采样方法有首部采样和尾部采样。对于某些系统，尾部采样可能与首部采样一起使用，以保护遥测流程免受过载的影响。</li></ol><h3 id="首部采样">首部采样</h3><ol><li>首部采样是一种在请求链的开始阶段进行的采样方法。当请求进入系统时，采样器会决定是否记录该请求的起始跨度。如果采样器决定记录起始跨度，则整个请求链路上的所有跨度都会被记录。如果采样器决定不记录起始跨度，则整个请求链路上的跨度都不会被记录。</li><li>首部采样的优点是简单高效，可以有效地减少跟踪数据的生成量。但是，它可能会导致某些请求的完整跟踪数据丢失，从而降低了跟踪数据的完整性。</li></ol><h3 id="尾部采样">尾部采样</h3><ol><li>尾部采样是一种在请求链的结束阶段进行的采样方法。当请求完成时，采样器会根据请求的特性和其他因素决定是否记录该请求的终止跨度。如果采样器决定记录终止跨度，则整个请求链路上的所有跨度都会被记录。如果采样器决定不记录终止跨度，则整个请求链路上的跨度都不会被记录。</li><li>尾部采样的优点是可以根据请求的实际情况和性能特征进行决策，从而更好地控制跟踪数据的生成率。但是，由于需要等待请求完成，因此尾部采样可能会导致一些延迟，并且在某些情况下可能无法获得完整的跟踪数据。并且，因为系统的复杂性等原因需要频繁调整采样策略，可能很难实现。</li></ol><h2 id="仪表范围">仪表范围</h2><p>仪表范围在 OpenTelemetry 中的作用是定义了遥测数据的上下文和关联。它是应用代码中的逻辑单元，与发出的遥测数据相关联，也就是定义了数据（信号）的来源等相关信息</p><ol><li>在应用程序代码中，可以选择模块、包或类作为仪表范围</li><li>对于库或框架，可以使用唯一的标识符作为仪表范围，例如库或框架的完全限定名称和版本</li><li>从提供者获取跟踪器（Tracer）、计量器（Meter）或记录器（Logger）实例时，通常会为仪表范围定义一个名称和版本对。创建的每个跨度（span）、指标（metric）或日志记录（log record）都会与提供的仪表范围相关联。</li><li>使用仪表范围，可以将遥测数据进行切片和切割，以便在可观测性后端中更好地理解和分析应用程序的行为和性能。例如，可以查看特定库版本的性能指标，或者将问题定位到应用程序的特定模块。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 可观测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 可观测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>async-profiler</title>
      <link href="/posts/5afb4600.html"/>
      <url>/posts/5afb4600.html</url>
      
        <content type="html"><![CDATA[<h1>什么是Async-profiler</h1><p>Async-profiler是一个针对Java的低开销采样分析器，它没有受到Safepoint Bias问题（只能在SafePoint处进行采样，可能导致一些代码无法被采样）的影响。该分析器利用了HotSpot特有的一系列API来收集堆栈跟踪信息，并追踪Java堆中的内存分配情况。async-profiler适用于OpenJDK以及其他基于HotSpot JVM的Java运行环境。</p><p>async-profiler能够追踪以下类型的事件：</p><ul><li>CPU周期</li><li>硬件和软件性能计数器，例如缓存未命中、分支未命中、页面错误、上下文切换等</li><li>Java堆中的内存分配</li><li>对于互斥锁的竞争尝试，包括Java对象监视器和ReentrantLocks（可重入锁）</li></ul><p>由于其实现依赖于特定操作系统的底层性能监控接口和技术，目前只支持linux和mac系统。</p><h1>使用方法</h1><p>async-profiler 是基于 JVMTI(JVM tool interface) 开发的 Agent，支持两种启动方式（建议OpenJDK11及以上）：</p><ol><li>跟随 Java 进程启动，自动载入共享库；</li><li>程序运行时通过 attach api 动态载入。</li></ol><h2 id="分析已经在运行的程序">分析已经在运行的程序</h2><ol><li>下载压缩包（如果在caster容器中，应该使用对应的架构版本x64），并解压缩</li><li>启动一个java程序，使用<code>jps -l</code>命令获取pid</li><li>命令+操作+参数+PID，示例./profiler.sh start -d 30 -f profile.html 3456</li><li>有时运行脚本时会遇到权限问题，可以根据提示使用–all-user选项</li></ol><p>操作：</p><ul><li>start：启动性能分析并立即返回(停止后数据会打印在控制台)。</li><li>resume：恢复性能分析而不重置已收集的数据。</li><li>stop：停止性能分析。</li><li>dump：转储已收集的数据，而不停止性能分析会话。</li><li>check：检查目标JVM是否支持指定的性能分析事件。</li><li>status：打印性能分析状态(输出示例：<code>Profiling is running for 2 seconds</code>)。</li><li>meminfo：打印分析器的内存统计信息。</li><li>list：列出目标JVM支持的所有性能分析事件。</li><li>collect：按照指定的时间段（默认60s）收集性能分析数据，之后自动停止（这是默认操作）。<br>参数：</li><li>-e event：指定性能分析事件类型，如：cpu、alloc、lock、cache-misses等。（默认是cpu，如果需要同时分析多种事件类型，需要通过-f指定输出格式为jfr，例：./profiler.sh -e cpu,alloc -f profiler.jfr &lt;pid&gt;)</li><li>-d duration：持续分析指定秒数。</li><li>-f filename：将分析结果输出到指定文件。（推荐html格式，最新版已经不支持svg）</li><li>-i interval：采样间隔，单位为纳秒。</li><li>-j jstackdepth：最大Java堆栈深度。默认值为 2048。</li><li>-L level:- 日志级别：<code>debug</code>、<code>info</code>、<code>warn</code>、<code>error</code>或<code>none</code></li><li>-t：单独分析不同的线程。</li><li>-s：使用简单类名代替全限定类名（FQN）。</li><li>-g：打印方法签名。</li><li>-a：为Java方法添加注释。</li><li>-l：在输出前加上库名称。</li><li>-o fmt： 指定分析结束时要转储的输出格式：flat（扁平化）、traces（踪迹）、collapsed（折叠）、flamegraph（火焰图）、tree（树状图）、jfr（JFR格式）。</li><li>-I include：仅输出包含指定模式的堆栈跟踪。</li><li>-X exclude：排除包含指定模式的堆栈跟踪。</li><li>-v, --version：显示版本信息。<br>其它高级选项：</li><li>–title string：为火焰图设置标题。</li><li>–total: 计算所收集指标的总值而不是样本数量，例如总分配大小。</li><li>–minwidth pct：忽略小于指定百分比宽度的帧。</li><li>–reverse：生成反向堆叠的火焰图或调用树。</li><li>–loop &lt;time&gt;：按指定时间循环运行分析器。示例<code>loop 1h</code>。</li><li>–alloc &lt;bytes&gt;：分配分析间隔，默认单位为字节，可以指定500k，2m等，例如，如果使用<code>--alloc 500k</code>，那么平均而言，每分配500KB的内存，就会采集一次样本数据。</li><li>–live：仅从活动对象构建分配分析。</li><li>–lock &lt;duration&gt;：锁分析阈值，默认单位为纳秒。示例<code>lock 10ms</code>。</li><li>–total：累计总值（如时间、字节数等）。</li><li>–all-user：仅包括用户模式事件。</li><li>–sched：按调度策略分组线程。</li><li>–cstack mode：C栈遍历方式：fp（帧指针）、dwarf（DWARF调试信息）、lbr（分支日志记录）、no（不遍历）。</li><li>–begin function：当指定函数执行时开始性能分析。</li><li>–end function：当指定函数执行时结束性能分析。</li><li>–ttsp：执行至安全点的时间分析。</li><li>–jfrsync config：与JFR录制同步分析器。</li><li>–lib path：容器中libasyncProfiler.so的完整路径。</li><li>–fdtransfer：使用fdtransfer服务来自非特权目标的perf请求。<br>示例：</li><li>./profiler.sh -d 30 -f profile.html 3456</li><li>./profiler.sh start -i 999000 jps</li><li>./profiler.sh stop -o flat jps</li><li>./profiler.sh -d 5 -e alloc MyAppName<br><code>&lt;pid&gt;</code> 表示目标JVM的数字进程ID，也可以是关键字“jps”，用于自动查找正在运行的JVM，或者是指定应用程序的名字，该名字会在<code>jps</code>工具中出现。</li></ul><h2 id="跟随-Java-进程启动">跟随 Java 进程启动</h2><p>如果需要在 JVM 启动后立即分析一些代码，而不是使用 <code>profiler.sh</code> 脚本，可以在命令行加上<code>async-profiler</code>作为代理。例如：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -agentpath:async-<span class="keyword">profiler</span>-2.9/build/libasyncProfiler.<span class="keyword">so</span>=start,event=alloc,<span class="keyword">file</span>=profile.html -jar ...</span><br></pre></td></tr></table></figure><p>参数说明：</p><ol><li><code>agentpath:path-to-library</code>: 这是JVM的一个参数，指定了代理库（Profiler库）的路径</li><li><code>parameters</code>: 传递给async-profiler的参数，多个参数之间用逗号分隔，没有空格<ul><li><code>start</code>: 表示启动async-profiler。</li><li><code>event=alloc</code>: 设置分析事件为内存分配（allocation）。async-profiler支持多种事件，如CPU、锁、线程状态变化、内存分配等。</li><li><code>file=profile.html</code>: 将分析结果输出到指定的HTML文件，这里表示输出到名为<code>profile.html</code>的文件，生成的结果通常是一个交互式的火焰图。</li></ul></li></ol><h2 id="火焰图">火焰图</h2><h3 id="特征">特征</h3><p>火焰图有以下特征（这里以 on-cpu 火焰图为例）：</p><ul><li>每一列代表一个调用栈，每一个格子代表一个函数</li><li>纵轴展示了栈的深度，按照调用关系从下到上排列。最顶上格子代表采样时正在占用 cpu 的函数。</li><li>横轴的意义是指：火焰图将采集的多个调用栈信息，通过按字母横向排序的方式将众多信息聚合在一起，需要关注的不是格子间的相对位置，而是每个格子的宽度，宽度代表其在采样中出现频率，所以一个格子的宽度越大，说明对应函数运行的时间较长，它是瓶颈原因的可能性就越大。</li><li>火焰图格子的颜色是随机的暖色调，方便区分各个调用信息，但颜色本身没有意义。</li><li>其他的采样方式也可以使用火焰图， on-cpu 火焰图横轴是指 cpu 占用时间，off-cpu 火焰图横轴则代表阻塞时间。</li></ul><h3 id="类型">类型</h3><img src="/post-img/Pasted image 20240407152358.png" alt="图片损坏" style="zoom:100%;" /><h1>原理</h1><h2 id="CPU-Profiling的两种实现方式">CPU Profiling的两种实现方式</h2><h3 id="Instrumentation">Instrumentation</h3><p>仪器化是一种主动的性能分析方法，它通过修改应用程序的字节码或插入额外的代码来收集性能数据。在仪器化过程中，开发人员可以向应用程序中插入特定的监控代码或调试代码，用于收集各种性能指标或调试信息。这种方法可以实现更精细的性能分析和调试功能。<br>特点：</p><ul><li>精确度：仪器化可以精确地控制收集性能数据的位置和时机，因此可以捕获更详细和准确的性能信息。</li><li>高定制性：由于可以修改应用程序的字节码或插入自定义的代码，所以仪器化具有很高的定制性，可以根据需要实现各种特定的性能分析和调试功能。</li><li>开销较大：由于需要修改应用程序的代码或字节码（JVM层面的AOP），仪器化的过程会增加应用程序的运行开销，可能会对应用程序的性能产生一定的影响。</li></ul><h3 id="Sampling">Sampling</h3><p>采样是一种被动的性能分析方法，它通过在应用程序运行过程中获取当前执行位置的信息，定期检查程序的状态，并记录下当前的堆栈信息，以了解程序在执行时所处的上下文。这些采样数据可以用于分析应用程序的性能瓶颈和调优。<br>特点：</p><ul><li>低开销：采样过程中对应用程序的执行影响较小，因为采样器只是周期性地对调用栈进行采样，而不会修改程序的执行流程。</li><li>部分覆盖：由于采样是周期性的，所以不能完全覆盖应用程序的所有执行路径，可能会错过某些关键路径或短暂的性能瓶颈。</li><li>实时性：采样数据可以实时地反映应用程序的执行情况，但由于采样间隔的存在，以及JVM固有的只能在安全点（Safe Point）进行采样的“缺陷”，会导致统计结果存在一定的偏差，可能无法捕获瞬时的性能问题，如果把采样周期减小，可能可以缓解该问题，但会造成性能开销骤增。</li></ul><h3 id="两种方式对比">两种方式对比</h3><p>这两种实现技术并没有非常明显的高下之判，只有在分场景讨论下才有意义。Sampling由于低开销的特性，更适合用在CPU密集型的应用中，以及不可接受大量性能开销的线上服务中。而Instrumentation则更适合用在I/O密集的应用中、对性能开销不敏感以及确实需要精确统计的场景中。</p><h2 id="Async-profiler原理">Async-profiler原理</h2><p>Async Profiler 的原理是在目标应用程序的进程中注入一个动态链接库，该库使用 Perf 事件子系统来收集 CPU 活动数据。与传统的基于采样的分析器不同，Async Profiler 通过异步采样来避免对目标应用程序的性能造成过大的影响。</p><h3 id="动态链接">动态链接</h3><p>动态链接是HotSpot提供的一种特殊能力，它允许一个进程向另一个运行中的JVM进程发送一些命令并执行，命令并不限于加载Agent，还包括Dump内存、Dump线程等等。在 Async Profiler 中，动态链接库是指被注入到目标应用程序进程中的二进制文件，这个动态链接库负责收集应用程序的性能数据，包括 CPU 活动、函数调用堆栈等信息，并将这些数据传输给 Profiler，以便进行性能分析。通过注入动态链接库，Async Profiler 可以监控目标应用程序的执行情况，而无需修改或重新编译目标应用程序的源代码。</p><h3 id="Perf事件子系统">Perf事件子系统</h3><p>Perf 事件子系统是 Linux 内核提供的性能事件采集框架，它允许用户空间工具收集各种硬件和软件事件的性能数据，包括 CPU 指令、缓存访问、分支预测等。Async Profiler 利用 Perf 事件子系统来收集 CPU 活动数据，例如指令执行、缓存失效、分支预测等，并将这些数据用于性能分析。通过 Perf 事件子系统，Async Profiler 能够在低开销的情况下捕获目标应用程序的性能数据，而不会对应用程序的执行性能产生显著的影响。</p><h3 id="异步采样">异步采样</h3><p>异步采样是 Async Profiler 的核心特性之一，它与传统的基于采样的分析器不同。</p><ul><li>在传统的基于采样的分析器中，分析器定期中断目标应用程序的执行，然后获取当前执行位置的堆栈信息。这种方式可能会影响应用程序的性能，并导致分析结果不准确。</li><li>在 Async Profiler 中，采样是异步进行的，即采样操作与目标应用程序的执行是独立的（在另一个线程中采集 CPU 活动数据，并将数据存储到内存中）。采样线程的数量可以通过参数进行配置，以便更好地适应不同的 CPU 架构和应用程序负载。当分析结束时，Async Profiler 将采集到的数据导出到一个文件中，并使用 Flame Graph 等可视化工具将数据转换为易于理解的图形化形式。</li><li>java中，异步采样依赖方法AsyncGetCallTrace，它是 Java HotSpot VM 中用于异步获取 Java 线程的调用堆栈信息的技术。它是一种非阻塞的方法，用于在 Java 虚拟机内部获取线程的堆栈跟踪信息，而不会阻塞线程的执行。</li></ul><h1>性能开销</h1><p>async-profiler的设计目标是尽可能降低对被分析程序的影响，尤其是在CPU开销方面。由于async-profiler采用异步采样的方式，并且直接利用HotSpot JVM的内置接口，它的CPU开销通常是非常小的；Latency（延迟），async-profiler通过精准的采样技术，理论上不会直接影响应用程序本身的响应时间或延迟。然而，如果配置的采样频率过高，理论上有可能造成微小的延迟增加，但正常配置下，这种影响也应该是微乎其微的；内存消耗方面，async-profiler在运行过程中会占用一定的内存来存储采样数据和相关结构，具体内存消耗取决于配置的采样类型和持续时间，以及应用程序本身的复杂度（如方法数量）。</p>]]></content>
      
      
      <categories>
          
          <category> 可观测 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 可观测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring核心：IOC和AOP</title>
      <link href="/posts/97c27ed6.html"/>
      <url>/posts/97c27ed6.html</url>
      
        <content type="html"><![CDATA[<h1>IOC</h1><h2 id="IOC的概念和原理">IOC的概念和原理</h2><p>IOC（Inversion of Control），即控制反转，把对象的创建、初始化、销毁（即对象的生命周期，称为bean，参考<a href="https://www.xlxq.fun/posts/48c92662.html">Bean的生命周期</a> ）交给 Spring 来管理，而不是由开发者控制，实现控制反转。IOC 思想基于 IOC 容器完成，IOC 容器底层就是对象工厂（BeanFactory 接口）。IOC的原理是基于xml解析、工厂设计模式、反射实现的，通过将控制权从程序内部转移到外部来降低组件之间的耦合度，提高代码的可维护性和可测试性。具体来说，IOC 的原理包括以下几个方面：</p><ol><li><strong>控制反转</strong>：传统的程序中，对象的创建和管理由程序内部控制，而采用IOC 的方式，控制权被反转到外部，由框架或容器来管理对象的创建和生命周期。这样做可以减少组件之间的直接依赖关系，提高灵活性和可扩展性。</li><li><strong>依赖注入</strong>：依赖注入是IOC 的一种实现方式，它通过将对象的依赖关系从对象内部移动到外部容器中，在对象创建时将依赖关系注入到对象中。这样做可以使得对象更加灵活，易于测试和替换。</li><li><strong>解耦</strong>：IOC 的主要目的之一是降低组件之间的耦合度，使得组件之间的依赖关系更加松散。这样做可以提高系统的灵活性和可维护性，降低修改一个组件对其他组件的影响。</li><li><strong>配置化</strong>：采用IOC 的方式可以将程序的配置信息从代码中抽离出来，以配置文件或注解的方式进行管理。这样做可以使得系统的配置更加灵活，方便进行修改和扩展。</li></ol><h2 id="IOC-容器实现的两种方式">IOC 容器实现的两种方式</h2><h3 id="BeanFactory">BeanFactory</h3><ol><li>BeanFactory 是 Spring 框架的核心接口之一，它是一个工厂模式的实现，负责管理和创建 Bean 实例。</li><li>BeanFactory 采用延迟初始化策略，也就是说，在<strong>调用 getBean() 方法获取 Bean 实例时</strong>才会进行实例化。</li><li>BeanFactory 提供了基本的 Bean 容器功能，包括 Bean 的实例化、依赖注入、生命周期管理等，但是它的功能相对较少，主要用于低层次的 Bean 容器功能。</li></ol><h3 id="ApplicationContext">ApplicationContext</h3><ol><li>ApplicationContext 是 BeanFactory 的子接口之一，它在 BeanFactory 的基础上进行了扩展，提供了更多的功能，比如<strong>事件发布、AOP 支持、资源加载</strong>等。</li><li>ApplicationContext 采用预先实例化的策略，也就是说，在<strong>容器启动时</strong>就会预先实例化所有的 Bean，而不是等到调用 getBean() 方法时才进行实例化。</li><li>ApplicationContext 是一个更加高级的容器，通常在实际项目中更为常用。</li></ol><h2 id="IOC-操作-Bean-管理">IOC 操作 Bean 管理</h2><p>IOC操作Bean管理有两种形式，一种是基于xml方式，另一种是基于注解方式。</p><ol><li><strong>基于 XML 配置</strong>：<ul><li>在基于 XML 的方式中，我们通过在 Spring 的配置文件（通常是applicationContext.xml）中使用 <code>&lt;bean&gt;</code>、<code>&lt;property&gt;</code> 等标签来定义和配置 Bean。</li><li>这种方式需要在 XML 文件中显式地配置每一个 Bean 及其属性，较为传统且繁琐，但是在某些情况下更加直观和可控。</li></ul></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserService&quot;</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br></pre></td></tr></table></figure><ol start="2"><li><strong>基于注解方式</strong>：<ul><li>在基于注解的方式中，我们可以使用 <code>@Component</code>、<code>@Service</code>、<code>@Controller</code>、<code>@Repository</code> 等注解来标识一个类为 Bean，并通过 <code>@Autowired</code> 注解来实现依赖注入。</li><li>这种方式使得 Bean 的配置更加简洁和灵活，同时也更加符合现代开发的趋势。Spring 在启动时会自动扫描带有这些注解的类，并将其注册为 Bean。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;     </span><br><span class="line"><span class="meta">@Autowired</span>     </span><br><span class="line"><span class="keyword">private</span> UserDao userDao;     </span><br><span class="line"><span class="comment">// 其他方法 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>AOP</h1><p>AOP（Aspect-Oriented Programming，面向切面编程）是一种编程范式，旨在通过将横切关注点（cross-cutting concerns）与核心业务逻辑分离，来提高代码的模块化和可维护性。<br>在传统的面向对象编程中，我们将功能按照业务逻辑划分为不同的对象和方法，但是有些功能并不属于特定的业务逻辑，而是横跨多个对象和方法的，比如日志、事务管理、安全性控制等。这些横切关注点会使得代码中充斥着重复的代码和混乱的逻辑，导致代码难以理解、维护和测试。AOP 的核心思想是将这些横切关注点抽象成一个单独的模块，称为切面（Aspect），然后通过在特定的切点（Join Point）上织入这些切面，从而将横切关注点与核心业务逻辑分离开来。在 AOP 中，切面可以理解为横跨多个对象和方法的代码片段，而切点则是确定在哪些位置应用这些切面的规则。</p><h2 id="AOP实现方式">AOP实现方式</h2><p>AOP底层是使用动态代理来实现的，这里有两种情况的动态代理：</p><ol><li>有接口的情况，使用 JDK 动态代理，即创建接口实现类代理对象，增强类的方法。</li><li>没有接口的情况，使用 CGLIB 动态代理，即创建子类的代理对象，增强类的方法。</li><li>详细的关于代理模式的分析和介绍，请转  <a href="https://www.xlxq.fun/posts/7b510e10.html">代理模式</a></li></ol><h2 id="AOP相关概念">AOP相关概念</h2><ol><li>连接点：类里面可以被增强的方法，这些方法被称为连接点。</li><li>切入点：实际被真正增强的方法，称为切入点。</li><li>通知（增强）：<ul><li>实际增强的逻辑部分称为通知（增强）</li><li>通知有多种类型：前置通知、后置通知、环绕通知、异常通知、最终通知</li></ul></li><li>切面：把通知应用到切入点的过程，称为切面。</li></ol><h2 id="AOP使用示例">AOP使用示例</h2><p>以下是一个简单的 Spring AOP 示例，演示了如何使用 AOP 实现日志记录功能：<br>假设有一个接口 <code>Calculator</code>，其中包含了两个方法 <code>add()</code> 和 <code>subtract()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Calculator</span> &#123;     </span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;     </span><br><span class="line"><span class="type">int</span> <span class="title function_">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后有一个实现类 <code>CalculatorImpl</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorImpl</span> <span class="keyword">implements</span> <span class="title class_">Calculator</span> &#123;     </span><br><span class="line"><span class="meta">@Override</span>     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;   <span class="keyword">return</span> a + b;   &#125;     </span><br><span class="line"><span class="meta">@Override</span>     <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subtract</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;  <span class="keyword">return</span> a - b;   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要在调用这些方法时记录日志，可以使用 AOP 实现。首先定义一个切面类 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect; </span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before; </span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;  </span><br><span class="line"><span class="meta">@Aspect</span> </span><br><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;      </span><br><span class="line"><span class="meta">@Before(&quot;execution(* com.example.Calculator.*(..))&quot;)</span>     </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logBeforeMethodExecution</span><span class="params">()</span> &#123;  </span><br><span class="line">System.out.println(<span class="string">&quot;LoggingAspect: Method is being executed.&quot;</span>);     </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的切面中，使用了 <code>@Aspect</code> 注解来标识这是一个切面类，然后使用 <code>@Before</code> 注解来定义切点表达式，表示在执行 <code>Calculator</code> 接口中的任何方法之前都会执行 <code>logBeforeMethodExecution()</code> 方法。<br>接下来，我们需要配置 Spring 容器以启用 AOP，可以创建一个配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean; </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan; </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration; </span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;  <span class="meta">@Configuration</span> </span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.example&quot;)</span> </span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;      </span><br><span class="line"><span class="meta">@Bean</span>     </span><br><span class="line"><span class="keyword">public</span> Calculator <span class="title function_">calculator</span><span class="params">()</span> &#123;         </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CalculatorImpl</span>();     </span><br><span class="line">&#125;      </span><br><span class="line"><span class="meta">@Bean</span>     </span><br><span class="line"><span class="keyword">public</span> LoggingAspect <span class="title function_">loggingAspect</span><span class="params">()</span> &#123;         </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LoggingAspect</span>();     </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的配置类中，使用 <code>@EnableAspectJAutoProxy</code> 注解启用了 Spring 的 AspectJ 自动代理功能，从而使得切面能够生效。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bean的生命周期</title>
      <link href="/posts/48c92662.html"/>
      <url>/posts/48c92662.html</url>
      
        <content type="html"><![CDATA[<h1>Bean的作用域</h1><p>一般来说，普通的java对象的生命周期可以如下描述：</p><ul><li>（类加载）—&gt;实例化</li><li>对象不再被使用时通过垃圾回收机制进行回收<br>而Bean，也不过是spring通过IOC容器管理的一些特殊的对象，Bean的作用域有以下几种（可以用@Scope注解指定）：</li></ul><ol><li>单例（singleton）在整个应用中只创建一个 Bean 实例</li><li>原型（prototype）每次请求时都创建一个新的 Bean 实例</li><li>请求（request）一次 HTTP 请求中，创建一个 Bean 实例</li><li>会话（session）用户会话中创建一个 Bean 实例</li><li>全局会话（Global Session ）类似于 Session 作用域，但用于 Portlet 环境</li><li>应用（application）在整个 Web 应用的生命周期中创建一个 Bean 实例<br>其中，后四个作用域是在 Web 环境下使用的</li></ol><h1>生命周期</h1><p>本文讨论单例模式下的Bean的生命周期，因为它完全被IOC容器控制<br>对于Spring Bean的生命周期来说，可以分为四个阶段，其中初始化完成之后，就代表这个Bean可以使用了：</p><ol><li><strong>实例化（Instantiation）</strong>：在这个阶段，Spring 容器根据配置信息创建 Bean 的实例。根据配置的作用域（singleton、prototype 等），实例化可能发生在容器启动时（单例）或每次请求时（原型）。</li><li><strong>属性赋值（Population）</strong>：在实例化之后，Spring 容器将会通过依赖注入或者其他方式将配置的属性值注入到 Bean 实例中，这个过程也被称为属性赋值。</li><li><strong>初始化前回调（Initialization callback）</strong>：在属性赋值完成之后，Spring 容器会调用 Bean 的初始化方法（如果有配置的话），以便进行一些初始化操作。常见的初始化方法包括 init-method 方法和 @PostConstruct 注解标记的方法。</li><li><strong>初始化后回调（Initialization callback）</strong>：在初始化方法执行完成后，Spring 容器会触发相应的事件，以通知 Bean 实例已经初始化完成。这个时候 Bean 实例已经完全可用。</li><li><strong>销毁前回调（Destruction callback）</strong>：对于 singleton 作用域的 Bean，当容器关闭时或者手动销毁 Bean 时，Spring 容器会调用 Bean 的销毁方法，执行一些清理操作。常见的销毁方法包括 destroy-method 方法和 @PreDestroy 注解标记的方法。</li></ol><h1>额外操作</h1><p>在Bean的生命周期中，还可以有一些额外操作来便于我们进一步控制和管理它们：</p><ol><li><strong>实例化阶段</strong>：<ul><li>在实例化阶段，Spring 容器会根据配置信息创建 Bean 的实例。这通常发生在容器启动时（对于 singleton 作用域的 Bean）或者在每次请求时（对于 prototype 作用域的 Bean）。</li><li>在这个阶段，可以通过自定义 BeanPostProcessor 实现类来进行扩展。BeanPostProcessor 接口提供了两个回调方法：<code>postProcessBeforeInitialization()</code> 和 <code>postProcessAfterInitialization()</code>，分别表示在 Bean 的初始化前和初始化后执行一些操作。</li><li>Bean还可以实现Aware接口，从而获得与容器交互的能力，以便获取一些容器管理的资源或者在特定的时机得到一些回调。当一个 Bean 实现了某个 Aware 接口时，Spring 容器在初始化该 Bean 时会自动调用相应的回调方法，从而将相应的资源或者引用注入到 Bean 中，例如名称，工厂，上下文等。</li></ul></li><li><strong>初始化阶段</strong>：<ul><li>在初始化阶段，Spring 容器会调用 Bean 的初始化方法，这个方法可以是通过配置的 <code>init-method</code> 属性指定的方法，也可以是使用 <code>@PostConstruct</code> 注解标记的方法。</li><li>在这个阶段，可以执行一些初始化操作，如数据初始化、资源加载等。同时，也可以通过自定义的 BeanPostProcessor 实现类在初始化前后执行一些操作。</li></ul></li><li><strong>使用阶段</strong>：<ul><li>在使用阶段，Bean 已经被完全初始化，并且可以被其他组件或者代码调用和使用。</li><li>在这个阶段，Bean 被容器管理，可以被注入到其他 Bean 中，也可以被注入到 AOP 切面中进行增强等操作。</li></ul></li><li><strong>销毁阶段</strong>：<ul><li>在销毁阶段，Spring 容器会关闭时或者手动销毁 Bean 时，会调用 Bean 的销毁方法。这个方法可以是通过配置的 <code>destroy-method</code> 属性指定的方法，也可以是使用 <code>@PreDestroy</code> 注解标记的方法。</li><li>在这个阶段，可以执行一些清理操作，如释放资源、关闭连接等。</li></ul></li></ol><h1>总结</h1><p>Bean的生命周期：</p><ol><li>通过BeanDefinition获取bean的定义信息，这里面就封装了bean的所有信息，比如，类的全路径，是否是延迟加载，是否是单例等等。</li><li>开始创建bean，调用构造函数<strong>实例化</strong>bean，这一步包括：<ul><li>依赖注入，比如一些set方法注入，也就是<strong>属性赋值</strong>，平时开发用的@Autowire都是这一步完成</li><li>处理Aware接口，如果某一个bean实现了Aware接口就会重写对应的Aware中的方法</li><li>bean的后置处理器BeanPostProcessor，这个是前置处理器</li></ul></li><li><strong>初始化</strong>方法，比如实现了接口InitializingBean或者自定义了方法init-method标签或@PostContruct</li><li>执行bean的后置处理器BeanPostProcessor，主要是对bean进行增强，有可能在这里产生代理对象</li><li>销毁bean，在销毁之前，检查是否实现DisposableBean接口或配置自定义destory-method方法，如果有，先执行这些方法然后销毁bean。</li></ol><img src="/post-img/Pasted image 20240421200409.png" alt="图片损坏" style="zoom:100%;" /><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>调用构造方法：开始实例化</span><br><span class="line"><span class="number">2.</span>设置属性：属性赋值</span><br><span class="line"><span class="number">3.</span>调用BeanNameAware<span class="meta">#setBeanName方法: Aware接口处理</span></span><br><span class="line"><span class="number">4.</span>调用BeanFactoryAware<span class="meta">#setBeanFactory方法： Aware接口处理</span></span><br><span class="line"><span class="number">5.B</span>eanPostProcessor<span class="meta">#postProcessBeforeInitialization方法：前置处理器方法</span></span><br><span class="line"><span class="number">6.</span>InitializingBean<span class="meta">#afterPropertiesSet方法：初始化</span></span><br><span class="line"><span class="number">7.</span>自定义<span class="keyword">init</span>方法：初始化</span><br><span class="line"><span class="number">8.B</span>eanPostProcessor<span class="meta">#postProcessAfterInitialization方法：后置处理器方法</span></span><br><span class="line"><span class="number">9.</span>DisposableBean<span class="meta">#destroy方法：销毁</span></span><br><span class="line"><span class="number">10.</span>自定义destroy方法：销毁</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC入门</title>
      <link href="/posts/9f6c61b0.html"/>
      <url>/posts/9f6c61b0.html</url>
      
        <content type="html"><![CDATA[<h1>简介</h1><p>RPC（Remote Procedure Call，远程过程调用）是一种通信协议，允许一个程序（客户端）调用另一个地址空间（通常是网络上的另一台机器）的过程或函数，而就像本地调用一样，使调用者无需关心底层的网络细节。<br>RPC的基本原理是，客户端调用远程服务器上的函数时，就像调用本地函数一样，但是函数的执行实际上发生在远程服务器上。RPC框架负责将函数调用、参数传递、执行结果等信息在客户端和服务器之间进行传输和协调。</p><h1>核心组成部分</h1><ol><li><strong>通信协议</strong>：定义了客户端和服务器之间通信的规则和格式。常见的RPC通信协议包括HTTP、TCP、UDP等。</li><li><strong>序列化协议</strong>：将函数调用和参数序列化为字节流，以便在网络上传输。常见的序列化协议包括JSON、XML、Protocol Buffers等。</li><li><strong>Stub（存根）</strong>：客户端使用的本地代理，用于代表远程服务器上的函数，并负责将函数调用转换为网络消息发送到服务器。</li><li><strong>Skeleton（骨架）</strong>：服务器端的本地代理，用于接收来自客户端的网络消息，并调用真正的函数执行请求。</li><li><strong>注册中心</strong>：用于注册和发现RPC服务的中心化组件，客户端和服务器可以通过注册中心找到彼此。</li></ol><h1>组件职责</h1><h2 id="服务调用方（Consumer）">服务调用方（Consumer）</h2><p>服务调用方也叫服务消费者，它的职责之一是<strong>提供需要调用的接口相关信息</strong>给调用端的本地存根，比如全限定名和方法以及调用方法的参数等；职责之二是从调用方的本地存根中<strong>接收执行结果</strong>。</p><h2 id="服务提供方（Provider）">服务提供方（Provider）</h2><p>服务提供方就是服务端，它的职责就是提供服务，执行接口实现的方法逻辑，也就是为服务提供方的本地存根<strong>提供方法的具体实现</strong>。</p><h2 id="本地存根（stub）">本地存根（stub）</h2><p>远程调用中，Provider如何精确地确定自己应该执行哪个函数，以及如何处理Consumer发起的函数调用，需要借助于 Stub。Stub的作用是让远程调用看起来像本地调用一样直接进行函数调用，无需关心地址空间隔离、函数不匹配等问题。Stub的职责包括<strong>进行类型和参数转化</strong>，并在服务提供方和服务调用方之间充当桥梁的角色，使得远程调用的过程对于服务调用方和服务提供方来说都像是在本地进行函数调用一样。</p><ol><li><strong>服务调用方的本地存根</strong>（Consumer端）：<ul><li>服务调用方的本地存根存在于服务调用方（Consumer）的机器上。</li><li>它会接收Consumer发起的函数调用，并解析函数名、参数等信息。</li><li>本地存根会将这些信息整理并组装成可传输的消息，按照定义好的协议进行序列化，然后交给RPCRuntime（RPC通信者）。</li><li>当服务调用方收到服务提供方返回的结果后，本地存根会将数据反序列化成服务调用方所需要的数据结果，并传递给服务消费方。</li></ul></li><li><strong>服务提供方的本地存根</strong>（Provider端）：<ul><li>服务提供方的本地存根与服务提供方一起存在于服务提供方（Provider）的机器上。</li><li>当RPCRuntime收到请求包后，会交由服务提供方的本地存根进行参数等数据的转化。</li><li>本地存根会重新转换客户端传递的数据，以便在Provider端的机器上找到对应的函数，并传递正确的参数数据。</li><li>最终，服务提供方的本地存根会将执行结果返回给RPCRuntime。</li></ul></li></ol><h2 id="RPC通信者（RPCRuntime）">RPC通信者（RPCRuntime）</h2><p>RPCRuntime负责<strong>数据包的重传，数据包的确认、数据包路由和加密</strong>等。<br>在Consumer端和Provider端都会有一个RPCRuntime实例，<strong>负责双方之间的通信</strong>，可靠地将存根数据包传输到另一端。</p><h1>调用过程</h1><p>服务暴露、服务发现、服务引用和方法调用这四个阶段组成了整个RPC的执行过程。</p><h2 id="服务暴露">服务暴露</h2><p>服务暴露发生在Provider端。根据服务是否暴露到远程可以分为两种，一种是服务只暴露到本地，另一种则是暴露到远程。</p><ol><li>本地暴露（Local Export）：<ul><li>在本地暴露中，服务只暴露给本地的调用方，不对外提供远程访问能力。</li><li>这种方式适用于在同一台物理机或者同一台虚拟机上的不同进程间通信，通常使用基于进程内通信（IPC）的方式实现，例如通过共享内存、套接字等方式。</li><li>本地暴露的优点是通信效率高、安全性好，但缺点是不能实现跨网络的远程调用。</li></ul></li><li>远程暴露（Remote Export）：<ul><li>在远程暴露中，服务可以被远程调用方访问，提供了跨网络的调用能力。</li><li>这种方式通常涉及网络通信，可以通过各种网络协议（如HTTP、TCP、UDP等）来实现跨网络的调用。</li><li>远程暴露的优点是可以实现分布式系统中不同节点之间的通信和协作，但缺点是通信开销相对较高，可能存在网络延迟和安全风险。</li></ul></li></ol><h2 id="服务发现">服务发现</h2><p>服务发现的方式有两种，分别是直连式和注册中心式，对应的是Provider端的两种服务暴露方式。</p><ol><li>直连式（Direct Connection）服务发现：<ul><li>在直连式服务发现中，服务的消费方（Consumer）直接与服务的提供方（Provider）建立连接，不依赖于任何中间组件。</li><li>Consumer通过配置服务提供方的地址（IP地址和端口号），直接向提供方发送请求。</li><li>这种方式简单直接，适用于小型系统或者对服务调用的可控性要求较高的场景。</li></ul></li><li>注册中心式（Service Registry）服务发现：<ul><li>在注册中心式服务发现中，服务的提供方将自己注册到一个中心化的服务注册中心（Service Registry）中，而服务的消费方通过查询注册中心获取服务提供方的信息，然后再进行调用。</li><li>注册中心负责管理服务的注册、注销和查询等操作，消费方通过与注册中心交互来获取服务提供方的地址信息。</li><li>这种方式通常用于大型分布式系统中，具有良好的扩展性和灵活性，但同时也引入了额外的中间件依赖和网络开销。</li></ul></li></ol><h2 id="服务引用">服务引用</h2><p>服务引用的过程发生在服务发现之后，当Consumer端通过服务发现获取所有服务提供者的地址后，通过负载均衡策略选择其中一个服务提供著的节点进行服务引用。服务引用的过程就是与某一个服务节点建立连接，以及在Consumer端创建接口的代理的过程其中建立连接也就是两端的RPCRuntime 建立连接的过程。</p><h2 id="服务调用">服务调用</h2><ol><li>服务消费者以本地调用方式(即以接口的方式)调用服务，它会将需要调用的方法、参数类型、参数传递给服务消费方的本地存根。</li><li>服务消费方的本地存根收到调用后，负责将方法、参数等数据组装成能够进行网络传输的消息体(将消息体对象序列化为二进制数据)，并将该消息体传输给RPC通信者。</li><li>Consumer 端的RPC通信者通过sockets 将消息发送到Provider端，由Provider端的RPC通信者接收。Provider端将收到的消息传递给服务提供方的本地存根。</li><li>服务提供方的本地存根收到消息后将消息对象反序列化。</li><li>服务提供方的本地存根根据反序列化的结果解析出服务调用的方法、参数类型、参数等信息，并调用服务提供方的服务。</li><li>服务提供方执行对应的方法后，将执行结果返回给服务提供方的本地存根。</li><li>服务提供方的本地存根将返回结果序列化，并且打包成可传输的消息体，传递给Provider端的RPC通信者。</li><li>Provider端的RPC通信者通过sockets将消息发送到Consumer端，由Consumer端的RPC通信者接收。Consumer端将收到的消息传递给服务消费方的本地存根。</li><li>服务消费方的本地存根收到消息后将消息对象反序列化。反序列化出来的是方法执行的结果，并将结果传递给服务消费者。</li><li>服务消费者得到最终执行结果。</li></ol><h1>常见RPC协议</h1><ol><li><strong>gRPC</strong>：gRPC 是由 Google 开发的高性能、开源的 RPC 框架，基于 HTTP/2 标准设计。它使用 Protocol Buffers（protobuf）作为默认的序列化协议，支持多种编程语言。</li><li><strong>Apache Dubbo</strong>：Apache Dubbo 是阿里巴巴开源的分布式服务框架，支持面向接口的远程调用，提供了丰富的功能如负载均衡、服务注册与发现、容错机制等。</li><li><strong>Apache Thrift</strong>：Apache Thrift 是 Facebook 开源的跨语言的服务框架，支持多种编程语言，使用 IDL（接口定义语言）来定义接口和数据类型，可以生成对应语言的客户端和服务器端代码。</li><li><strong>RSocket</strong>：RSocket 是一个跨语言的异步通信协议，支持多种传输模型（如TCP、WebSocket），提供了请求-响应、请求-流、流-响应等多种交互模式，适用于高性能、实时性要求较高的场景。</li><li><strong>XML-RPC</strong>：XML-RPC 是一种使用 XML 格式进行数据交换的远程过程调用协议，它基于 HTTP 协议，简单易用，但相对于其他协议来说性能较低。</li><li><strong>JSON-RPC</strong>：JSON-RPC 是一种使用 JSON 格式进行数据交换的远程过程调用协议，与 XML-RPC 类似，但使用 JSON 格式使得数据更加紧凑，适用于 Web 开发中的前后端交互。</li></ol><h1>protobuf</h1><p>Protocol Buffers（protobuf）是一种轻量级、高效的序列化框架，由 Google 开发并开源。它可以用于结构化数据的序列化和反序列化，支持多种编程语言，并且提供了简单的接口定义语言（IDL）用于定义数据结构和服务接口。<br>protobuf 的主要特点包括：</p><ol><li><strong>高效性</strong>：protobuf 使用二进制编码，相比于文本格式（如 XML、JSON），序列化后的数据更加紧凑，传输效率更高。</li><li><strong>跨语言支持</strong>：protobuf 提供了多种编程语言的支持，包括 Java、C++、Python、Go 等，这使得不同语言之间的数据交换变得更加方便。</li><li><strong>可扩展性</strong>：protobuf 的消息格式是可以扩展的，可以向已有的消息类型中添加新的字段而不会破坏现有的兼容性。</li><li><strong>自描述性</strong>：protobuf 支持自描述，即在序列化后的数据中包含了消息的字段标识和类型信息，使得消息的解析更加容易。</li><li><strong>快速</strong>：相比于其他序列化框架，protobuf 的序列化和反序列化速度更快，适用于对性能要求较高的场景。</li></ol><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; </span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123; </span><br><span class="line"><span class="type">string</span> name = <span class="number">1</span>; </span><br><span class="line"><span class="type">int32</span> age = <span class="number">2</span>; </span><br><span class="line"><span class="keyword">repeated</span> <span class="type">string</span> emails = <span class="number">3</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ入门</title>
      <link href="/posts/badb3e06.html"/>
      <url>/posts/badb3e06.html</url>
      
        <content type="html"><![CDATA[<h1>消息队列</h1><ol><li>消息（Message）是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象。</li><li>消息队列（Message Queue）是一种应用间的通信方式，消息发送后可以立即返回，由消息系统来确保消息的可靠传递。消息发布者只管把消息发布到 MQ 中而不用管谁来取，消息使用者只管从 MQ 中取消息而不管是谁发布的。这样发布者和使用者都不用知道对方的存在，从而实现模块间的解耦合。</li><li>消息队列是一种应用间的异步协作机制，同时消息队列中间件是分布式系统中重要的组件，主要解决<strong>应用耦合，异步消息，流量削锋</strong>等问题。实现高性能，高可用，可伸缩和最终一致性架构。</li></ol><h2 id="消息队列的作用">消息队列的作用</h2><ol><li><strong>解耦：</strong> 消息队列可以将系统内不同模块之间的通信解耦，使得模块之间不直接依赖于彼此的实现。这降低了系统的复杂性，使得各个组件可以独立演化。</li><li><strong>异步通信：</strong> 消息队列支持异步通信，发送方将消息放入队列后即可继续执行其他操作，而不需要等待接收方的处理。这提高了系统的响应性，特别是在处理大量请求或在网络延迟较高的情况下。</li><li><strong>流量削峰：</strong> 消息队列可以用于缓冲和平滑处理系统的流量，防止突发的高峰值请求对系统造成压力。通过控制消息的消费速率，可以有效地削平流量峰值。</li></ol><h2 id="常见消息队列对比">常见消息队列对比</h2><p>常见的消息队列系统包括RocketMQ、RabbitMQ和Kafka，它们在一些方面有一些共同点，但也有一些明显的区别。以下是它们的一些对比：</p><ol><li><strong>消息传递模型：</strong><ul><li><strong>RocketMQ：</strong> 提供点对点和发布/订阅两种消息传递模型。</li><li><strong>RabbitMQ：</strong> 同样支持点对点和发布/订阅模型，非常灵活。</li><li><strong>Kafka：</strong> 主要支持发布/订阅模型。</li></ul></li><li><strong>性能：</strong><ul><li><strong>RocketMQ：</strong> 注重高吞吐量和低延迟，适合实时消息处理。</li><li><strong>RabbitMQ：</strong> 相对较低的延迟，适用于一些对延迟敏感的场景。</li><li><strong>Kafka：</strong> 专注于高吞吐量和持久性，适用于大规模数据处理。</li></ul></li><li><strong>可靠性：</strong><ul><li><strong>RocketMQ：</strong> 提供了较好的消息可靠性，支持同步和异步复制。</li><li><strong>RabbitMQ：</strong> 可以配置为提供高可靠性，但需要在配置上更多的努力。</li><li><strong>Kafka：</strong> 通过分区和副本机制来确保消息的可靠性。</li></ul></li><li><strong>水平扩展性：</strong><ul><li><strong>RocketMQ：</strong> 支持较好的水平扩展性，可以通过添加节点来增加容量。</li><li><strong>RabbitMQ：</strong> 可以通过集群来实现水平扩展，但可能相对复杂。</li><li><strong>Kafka：</strong> 具有出色的水平扩展性，适用于大规模数据流处理。</li></ul></li><li><strong>使用场景：</strong><ul><li><strong>RocketMQ：</strong> 适用于大规模实时消息处理，例如电商交易系统。</li><li><strong>RabbitMQ：</strong> 适用于传统企业应用，也可以用于实时数据处理。</li><li><strong>Kafka：</strong> 适用于大规模数据流处理，如日志收集、事件流处理等。</li></ul></li></ol><h1>RocketMQ</h1><h2 id="架构设计">架构设计</h2><ol><li><strong>生产者（Producer）</strong>：消息的发送者，负责产生消息，生产者向消息服务器发送由业务应用程序系统生成的消息。</li><li><strong>消费者（Consumer）</strong>：消息接收者，负责消费消息，消费者从消息服务器拉取信息并将其输入用户应用程序。</li><li><strong>消息服务器（Broker）</strong>：暂存和传输消息；是消息存储中心，主要作用是接收来自 Producer 的消息并存储， Consumer 从这里取得消息。</li><li><strong>名称服务器（NameServer）</strong>：管理Broker，用来保存 Broker 相关 Topic 等元信息并给 Producer ，提供 Consumer 查找 Broker 信息。</li><li><strong>主题（Topic）</strong>：区分消息的种类；一个发送者可以发送消息给一个或者多个Topic；一个消息的接收者 可以订阅一个或者多个Topic消息</li><li><strong>消息队列（Message Queue）</strong>：相当于是Topic的分区；用于并行发送和接收消息</li><li><strong>标签（Tag）</strong>： 用于对消息进行二级分类。一个 Topic 可以有多个 Tag，用于更细粒度地过滤消息</li></ol><h2 id="启动流程">启动流程</h2><img src="/post-img/Pasted image 20240217160000.png" alt="图片损坏" style="zoom:100%;" /><ol><li><strong>启动 NameServer</strong>，NameServer 启动后监听端口，等待 Broker、Producer、Consumer 连接，相当于一个路由控制中心。</li><li><strong>启动 Broker</strong>，Broker启动后与所有 NameServer 保持长连接，定时发送心跳包。心跳包中包含当前 Broker 信息以及存储所有 Topic 信息。注册成功后，NameServer 集群中就有 Topic 跟 Broker 的映射关系。</li><li><strong>创建 Topic</strong>，创建 Topic 时需要指定该 Topic 要存储在哪些 Broker 上，也可以在发送消息时自动创建 Topic。</li><li><strong>生产者发送消息</strong>，启动时先跟 NameServer 集群中的其中一台建立长连接，并从 NameServer 中获取当前发送的 Topic 存在于哪些 Broker 上，轮询从队列列表中选择一个队列，然后与队列所在的 Broker 建立长连接从而向 Broker发消息。</li><li><strong>消费者接受消息</strong>，跟其中一台 NameServer 建立长连接，获取当前订阅 Topic 存在哪些 Broker 上，然后直接跟 Broker 建立连接通道，然后开始消费消息。</li></ol><h2 id="特点">特点</h2><h3 id="顺序消费">顺序消费</h3><p>顺序消息是 RocketMQ 提供的一种对消息发送和消费顺序有严格要求的消息。对于一个指定的 Topic，消息严格按照先进先出（FIFO）的原则进行消息发布和消费，即先发布的消息先消费，后发布的消息后消费。</p><h4 id="分区顺序消息">分区顺序消息</h4><p>对于指定的一个 Topic，所有消息根据 Sharding Key 进行区块分区，<strong>同一个分区内</strong>的消息按照严格的先进先出（FIFO）原则进行发布和消费。同一分区内的消息保证顺序，不同分区之间的消息顺序不做要求。</p><ol><li>适用场景：适用于性能要求高，以 Sharding Key 作为分区字段，在同一个区块中严格地按照先进先出（FIFO）原则进行消息发布和消费的场景。</li><li>示例：<ul><li>用户注册需要发送验证码，以用户 ID 作为 Sharding Key，那么同一个用户发送的消息都会按照发布的先后顺序来消费。</li><li>电商的订单创建，以订单 ID 作为 Sharding Key，那么同一个订单相关的创建订单消息、订单支付消息、订单退款消息、订单物流消息都会按照发布的先后顺序来消费。</li></ul></li></ol><h4 id="全局顺序消息">全局顺序消息</h4><p>对于指定的一个Topic，<strong>所有消息</strong>按照严格的先入先出（FIFO）的顺序来发布和消费。</p><ol><li>适用场景：适用于性能要求不高，所有的消息严格按照 FIFO 原则来发布和消费的场景。</li><li>示例：</li></ol><ul><li>在证券处理中，以人民币兑换美元为 Topic，在价格相同的情况下，先出价者优先处理，则可以按照 FIFO 的方式发布和消费全局顺序消息。</li></ul><ol start="3"><li>全局顺序消息实际上是<strong>一种特殊的分区顺序消息</strong>，即 Topic 中只有一个分区，因此全局顺序和分区顺序的实现原理相同。因为分区顺序消息有多个分区，所以分区顺序消息比全局顺序消息的并发度和性能更高。</li></ol><h3 id="消息可靠性">消息可靠性</h3><p>保证消息可靠性也就是保证消息一定会被消费，不会丢失，而消息丢失可能会在这三个阶段发生：<strong>生产阶段、存储阶段、消费阶段</strong></p><ol><li>生产阶段：<strong>请求确认机制</strong><ul><li>同步发送的时候，要注意处理响应结果和异常。如果返回响应OK，表示消息成功发送到了Broker，如果响应失败，或者发生其它异常，都应该重试。</li><li>异步发送的时候，应该在回调方法里检查，如果发送失败或者异常，都应该进行重试。</li><li>如果发生超时的情况，也可以通过查询日志的API，来检查是否在Broker存储成功。</li></ul></li><li>存储阶段：<strong>通过配置可靠性优先的 Broker 参数来避免因为宕机丢消息</strong>，也就是进行<strong>数据持久化</strong><ul><li>消息只要持久化到CommitLog（日志文件）中，即使Broker宕机，未消费的消息也能重新恢复再消费。</li><li>Broker的刷盘机制：<strong>同步刷盘和异步刷盘</strong>，不管哪种刷盘都可以保证消息一定存储在pagecache中（内存中），但是同步刷盘更可靠，它是Producer发送消息后等数据持久化到磁盘之后再返回响应给Producer。</li><li>Broker通过<strong>主从模式</strong>来保证高可用，Broker支持Master和Slave同步复制、Master和Slave异步复制模式，生产者的消息都是发送给Master，但是消费既可以从Master消费，也可以从Slave消费。同步复制模式可以保证即使Master宕机，消息肯定在Slave中有备份，保证了消息不会丢失。</li></ul></li><li>消费阶段<ul><li>Consumer保证消息成功消费的关键在于确认的时机，不要在收到消息后就立即发送消费确认，而是应该在执行完所有消费业务逻辑之后，再发送消费确认。</li></ul></li></ol><h3 id="死信队列">死信队列</h3><ol><li>死信队列用于处理无法被正常消费的消息，即死信消息。</li><li>当一条消息初次消费失败，消息队列 RocketMQ 会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，RocketMQ 不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中，该特殊队列称为死信队列。</li><li>死信消息的特点：<ul><li>不会再被消费者正常消费。</li><li>有效期与正常消息相同，均为 3 天，3 天后会被自动删除。因此，需要在死信消息产生后的 3 天内及时处理。</li></ul></li><li>死信队列的特点：<ul><li><strong>一个死信队列对应一个 Group ID</strong>， 而不是对应单个消费者实例。</li><li>如果一个 Group ID 未产生死信消息，消息队列 RocketMQ 不会为其创建相应的死信队列。</li><li>一个死信队列包含了对应 Group ID 产生的所有死信消息，不论该消息属于哪个 Topic。</li><li>RocketMQ 控制台提供对死信消息的<strong>查询、导出和重发</strong>的功能。</li></ul></li></ol><h3 id="延迟队列">延迟队列</h3><p>RocketMQ是支持延时消息的，只需要在生产消息的时候设置消息的延时级别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化一个生产者来产生延时消息</span></span><br><span class="line"><span class="type">DefaultMQProducer</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultMQProducer</span>(<span class="string">&quot;ExampleProducerGroup&quot;</span>);</span><br><span class="line"><span class="comment">// 启动生产者</span></span><br><span class="line">producer.start();</span><br><span class="line"><span class="type">int</span> <span class="variable">totalMessagesToSend</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; totalMessagesToSend; i++) &#123;</span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(<span class="string">&quot;TestTopic&quot;</span>, (<span class="string">&quot;message &quot;</span> + i).getBytes());</span><br><span class="line">    <span class="comment">// 设置延时等级3,这个消息将在10s之后发送(现在只支持固定的几个时间)</span></span><br><span class="line">    message.setDelayTimeLevel(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 发送消息</span></span><br><span class="line">    producer.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是目前RocketMQ支持的延时级别是有限的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">messageDelayLevel</span> <span class="operator">=</span> </span><br><span class="line"><span class="string">&quot;1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h&quot;</span>;</span><br></pre></td></tr></table></figure><p>RocketMQ通过<strong>临时存储+定时任务</strong>来实现延时消息<br>Broker收到延时消息了，会先发送到主题（SCHEDULE_TOPIC_XXXX）的相应时间段的Message Queue中，然后通过一个定时任务轮询这些队列，到期后，把消息投递到目标Topic的队列中，然后消费者就可以正常消费这些消息。</p><h2 id="常见问题解决">常见问题解决</h2><h3 id="消息幂等性">消息幂等性</h3><p>对分布式消息队列来说，同时做到确保一定投递和不重复投递是很难的，就是所谓的“有且仅有一次” 。RocketMQ择了确保一定投递，保证消息不丢失，但有可能造成消息重复。<br>处理消息重复问题，主要由业务端保证，主要的方式有两种：<strong>业务幂等和消息去重</strong></p><ol><li>业务幂等：保证消费逻辑的幂等性，也就是多次调用和一次调用的效果是一样的。这样一来，不管消息消费多少次，对业务都没有影响。</li><li>消息去重：业务端对重复的消息就不再消费了。这种方法，需要保证每条消息都有一个唯一的编号，通常是业务相关的，比如订单号，消费的记录需要落库，而且需要保证和消息确认这一步的原子性。<br>基于以下两个方向思考：</li><li>接口只允许调用一次，比如mysql唯一索引，基于redis分布式锁机制</li><li>对数据的影响只会触发一次，比如乐观锁或状态机（数据的状态信息是向前变化的，因此如果数据的当前状态小于记录的状态，就可以忽略这次修改的信息）</li></ol><h3 id="消息积压">消息积压</h3><p>事前处理：上线之前对流量有个预估，压测得出消费者的消费能力上限，再根据实际情况进行部署以支撑整个服务<br>事中处理：先保证服务，进行消费者的临时扩容操作</p><ol><li>消费者扩容：<ul><li>如果当前Topic的Message Queue的数量大于消费者数量，就可以对消费者进行扩容，增加消费者，来提高消费能力，尽快把积压的消息消费玩。</li></ul></li><li>消息迁移Queue扩容：<ul><li>如果当前Topic的Message Queue的数量小于或者等于消费者数量，这种情况，再扩容消费者就没什么用，就得考虑扩容Message Queue。可以新建一个临时的Topic，临时的Topic多设置一些Message Queue，然后先用一些消费者把消费的数据丢到临时的Topic，因为不用业务处理，只是转发一下消息，还是很快的。接下来用扩容的消费者去消费新的Topic里的数据，消费完了之后，恢复原状。<br>事后处理：</li></ul></li><li>提高并行消费度，如：合理设置消费者组；增加队列分区，考虑把消息分散到多个队列中，避免单个队列出现积压</li><li>批量方式消费，提高消费吞吐量</li><li>调整消息处理的优先级：根据消息的重要性和紧急程度，调整消息处理的优先级。优先处理重要的消息，确保关键业务的及时性，而对于非关键的消息可以进行降级处理、跳过、或延后处理。</li><li>优化每条消息的消费过程（业务）<br>5. 合理设置超时机制</li><li>数据清理和重试：定期清理过期或无效信息</li><li>扩容：若MQ出现性能瓶颈，对MQ扩容</li><li>增加消费者数量：增加消费能力</li></ol><h3 id="消息过滤">消息过滤</h3><ol><li>在 Broker 端按照 Consumer 的去重逻辑进行过滤，这样做的好处是避免了无用的消息传输到 Consumer 端，缺点是加重了 Broker 的负担，实现起来相对复杂。</li><li>在 Consumer 端过滤，比如按照消息设置的 tag 去重，这样的好处是实现起来简单，缺点是有大量无用的消息到达了 Consumer 端只能丢弃不处理。</li><li>一般采用Cosumer端过滤，如果希望提高吞吐量，可以采用Broker过滤。</li><li>对消息的过滤有三种方式：<ul><li>根据Tag过滤：高效简单</li><li>SQL 表达式过滤：更加灵活</li><li>Filter Server 方式：最灵活，也是最复杂的一种方式，允许用户自定义函数进行过滤</li></ul></li></ol><h3 id="高可用（消息持久化）">高可用（消息持久化）</h3><ol><li>RocketMQ的高可用主要是在体现在Broker的读和写的高可用，Broker的高可用是通过<strong>主从集群</strong>实现的</li><li>Broker可以配置两种角色：Master和Slave<ul><li>Master角色的Broker支持读和写</li><li>Slave角色的Broker只支持读</li><li>Master会向Slave同步消息。</li><li>Producer只能向Master角色的Broker写入消息，Cosumer可以从Master和Slave角色的Broker读取消息。</li></ul></li><li>读的高可用：<strong>自动切换</strong><ul><li>Consumer 的配置文件中，并不需要设置是从 Master 读还是从 Slave读，当 Master 不可用或者繁忙的时候， Consumer 的读请求会被自动切换到从 Slave。有了自动切换 Consumer 这种机制，当一个 Master 角色的机器出现故障后，Consumer 仍然可以从 Slave 读取消息，不影响 Consumer 读取消息，这就实现了读的高可用。</li></ul></li><li>写的高可用：<strong>多Master</strong><ul><li>在创建 Topic 的时候，把 Topic 的多个Message Queue 创建在多个 Broker 组上（相同 Broker 名称，不同 brokerId机器组成 Broker 组），这样当 Broker 组的 Master 不可用后，其他组Master 仍然可用， Producer 仍然可以发送消息</li><li>RocketMQ 目前还不支持把Slave自动转成 Master ，如果机器资源不足，需要把 Slave 转成 Master ，则要手动停止 Slave 色的 Broker ，更改配置文件，用新的配置文件启动 Broker。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/posts/518e617c.html"/>
      <url>/posts/518e617c.html</url>
      
        <content type="html"><![CDATA[<p>Git 是一个分布式版本控制系统，用于跟踪软件开发过程中的代码变更。它允许多个开发者协同工作，同时记录代码的变更历史，管理不同版本的代码库，以及轻松地创建分支和合并代码。</p><h1>基础概念</h1><p>以下是与 Git 相关的一些关键概念和命令：</p><ol><li><strong>仓库（Repository）</strong>：仓库是包含项目及其所有文件的目录，同时还包括了代码变更的历史记录。</li><li><strong>克隆（Clone）</strong>：要开始使用一个 Git 仓库，通常会使用 <code>git clone</code> 命令将远程仓库克隆到本地计算机上</li><li><strong>提交（Commit）</strong>：提交是在特定时间点对你的更改进行快照。你可以使用 <code>git commit</code> 命令将更改保存到本地仓库。</li><li><strong>分支（Branch）</strong>：分支是仓库内的一个独立开发线。它允许你在不影响主要代码库的情况下开发功能或修复问题。可以使用 <code>git branch</code> 创建分支，使用 <code>git checkout</code> 在不同分支之间切换。</li><li><strong>合并（Merge）</strong>：合并将一个分支的更改合并到另一个分支中。使用 <code>git merge</code> 命令将源分支的更改集成到目标分支中。</li><li><strong>拉取（Pull）</strong>：拉取是从远程仓库获取更改并将其整合到本地仓库的过程。这通常用于保持本地仓库与远程仓库同步。你可以使用 <code>git pull</code> 进行拉取操作。</li><li><strong>推送（Push）</strong>：推送将本地的提交发送到远程仓库。这是与他人共享更改的方式。使用 <code>git push</code> 进行推送操作。</li><li><strong>远程（Remote）</strong>：远程是对远程仓库的引用，通常托管在平台如 GitHub、GitLab 或 Bitbucket 上。可以使用 <code>git remote</code> 命令添加、删除或管理远程仓库。</li><li><strong>状态（Status）</strong>：<code>git status</code> 命令显示仓库的当前状态，包括已经进行但尚未提交的更改。</li><li><strong>差异（Diff）</strong>：<code>git diff</code> 命令显示两个版本之间的差异，帮助你理解所做的更改。</li></ol><h1>常用命令</h1><p>以下是一些可能会用到的命令及其简要描述：</p><ol><li><code>git init</code>：在当前目录初始化一个新的 Git 仓库。</li><li><code>git clone &lt;URL&gt;</code>：从远程仓库克隆代码到本地。</li><li><code>git add &lt;file&gt;</code>：将文件的更改添加到暂存区。</li><li><code>git commit -m &quot;message&quot;</code>：将暂存区的更改提交到本地仓库。</li><li><code>git status</code>：查看当前仓库的状态，包括未提交的更改。</li><li><code>git diff</code>：显示当前工作目录中的更改。</li><li><code>git branch</code>：列出所有本地分支，显示当前所在分支。</li><li><code>git checkout &lt;branch&gt;</code>：切换到指定分支。</li><li><code>git merge &lt;branch&gt;</code>：将指定分支的更改合并到当前分支。</li><li><code>git pull</code>：从远程仓库拉取最新更改。</li><li><code>git push</code>：将本地更改推送到远程仓库。</li><li><code>git remote add &lt;name&gt; &lt;URL&gt;</code>：添加一个远程仓库。</li><li><code>git log</code>：查看提交历史记录。</li><li><code>git reset &lt;file&gt;</code>：从暂存区撤销文件的更改。</li><li><code>git revert &lt;commit&gt;</code>：创建一个新提交，撤销指定提交的更改。</li><li><code>git stash</code>：将当前未提交的更改暂存起来，以便在切换分支时使用。</li><li><code>git tag &lt;tagname&gt;</code>：创建一个标签，用于标记某个特定的提交。</li></ol><h1>git的工作原理</h1><h2 id="工作区域">工作区域</h2><p>Git本地有三个工作区域∶工作目录(Working Directory )、暂存区(Stage/ndex)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下∶<br><img src="/post-img/Pasted image 20230822165257.png" alt="图片损坏" style="zoom:100%;" /></p><p>Workspace :工作区，就是平时存放项目代码的地方<br>Index / Stage:暂存区，用于临时存放改动，事实上它只是一个文件，保存即将提交到文件列表信息<br>Repository :仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交的所有版本的数据。其中HEAD指向最新放入仓库的版本</p><h2 id="工作流程">工作流程</h2><ol><li>在工作目录中添加、修改文件;</li><li>将需要进行版本管理的文件放入暂存区域;</li><li>将暂存区域的文件提交到git仓库。<br>因此，git管理的文件有三种状态：已修改，已暂存，已提交</li></ol><h2 id="关于分支">关于分支</h2><p>git是一个帮助多人协同合作的工具，由于个人之间的工作不同，项目代码势必会在同一基础上进行不同的修改，这个同一基础就是master主分支，要对master进行修改，一般要新建一个分支，对master进行不同修改后得到的不同分支进行合并时，一般会由git判断是否存在冲突，这时，Git 不能自动决定应该选择哪个更改，因为它无法确定哪个更改是正确的。在这种情况下，Git 会将冲突标记在文件中，然后需要开发者手动解决冲突，冲突解决后，可以将合并后的这个新的分支设置为新的master<br>解决冲突的一般步骤是：</p><ol><li>执行<code>git pu11</code>以获取远程分支的最新更改。</li><li>Git将会提示存在冲突的文件，需要在这些文件中手动编辑并解决冲突。</li><li>编辑后的文件需要保存，然后使用<code>git add</code>将文件标记为已解决。</li><li>最后，运行<code>git commit</code>来提交解决冲突的更改。</li></ol><h1>关于一些常见问题</h1><ol><li><strong>Git的原理和工作流程</strong>： Git 是一种分布式版本控制系统，它的核心原理是基于快照（snapshot）。每次提交（commit）都会创建一个文件和目录的快照，而不是保存文件之间的差异。Git 的工作流程通常包括以下步骤：<ul><li><strong>克隆（Clone）</strong>：从远程仓库复制项目到本地，创建一个本地仓库。</li><li><strong>工作目录（Working Directory）</strong>：在本地仓库中，你可以在工作目录中修改文件。</li><li><strong>暂存区（Staging Area）</strong>：将工作目录中的修改添加到暂存区，为下一次提交做准备。</li><li><strong>提交（Commit）</strong>：从暂存区中创建一个快照，将其保存到版本历史中。</li><li><strong>分支（Branch）</strong>：可以创建分支来在不同功能上开展并行开发，每个分支都有自己的工作目录、暂存区和提交历史。</li><li><strong>合并（Merge）</strong>：将不同分支上的修改合并到一起，形成一个新的提交。</li><li><strong>推送（Push）</strong>：将本地提交推送到远程仓库，与团队共享。</li><li><strong>拉取（Pull）</strong>：从远程仓库获取最新的变更，包括其他人的提交。</li></ul></li><li><strong>版本控制系统</strong>： 版本控制系统（Version Control System，VCS）是一种用于追踪和管理文件版本和变更历史的工具。它允许多人协同开发、追踪代码变化、回溯历史、分支和合并等。VCS 的主要目的是使开发团队能够更有效地协同工作，减少错误和冲突，并为项目提供详细的版本历史。</li><li><strong>git fetch和git pull命令的区别</strong>：<ul><li><p><code>git fetch</code>：从远程仓库获取最新的提交和分支信息，但不会自动合并或更新你的工作目录。它会将获取的内容存储在本地仓库的远程跟踪分支中。</p></li><li><p><code>git pull</code>：执行两个操作，首先，它会从远程仓库拉取最新的提交并合并到当前分支，然后更新你的工作目录。这相当于执行了 <code>git fetch</code> 后紧接着的 <code>git merge</code>。</p></li></ul></li><li><strong>git rebase和git merge命令的区别</strong>：<ul><li><code>git merge</code>：将一个分支的更改合并到另一个分支。合并会创建一个新的提交节点，记录两个分支的历史交汇点。</li><li><code>git rebase</code>：将一个分支上的更改在另一个分支的基础上重新应用。它将当前分支上的提交逐个应用到目标分支的顶部，创造更线性的提交历史。</li></ul></li><li><strong>Git Flow</strong>： Git Flow 是一种流行的 Git 分支管理工作流，它提供了一套规范的分支命名和管理策略。它包括主分支（master）、开发分支（develop）、功能分支（feature）、发布分支（release）、修复分支（hotfix）等。Git Flow 的好处在于使协同开发更有条理，促进版本控制和发布的流程化，降低冲突和错误。</li><li><strong>暂存区</strong>： 暂存区是 Git 版本控制系统的一个重要概念。在进行提交之前，你可以将工作目录中的修改（包括新增、修改和删除的文件）添加到暂存区。暂存区允许你控制哪些更改应该包含在下一次提交中。这使你能够构建精细的提交，准备提交前进行检查，避免错误和混乱的提交。<br>Git 需要暂存区的存在，因为它提供了更多的控制权和准备提交的灵活性。你可以选择性地将不同文件的修改添加到暂存区，从而创建更清晰、有序的提交历史。</li><li><strong>控制某些文件不被提交</strong>： 你可以使用<code>.gitignore</code>文件来控制哪些文件或目录在提交时被忽略。在项目根目录下创建或编辑<code>.gitignore</code>文件，然后列出你希望忽略的文件、目录、通配符等。这样，这些文件就不会出现在提交中。</li><li><strong>提交冲突的情况和解决方法</strong>： 冲突通常发生在以下情况：<ul><li>多人同时修改同一行或相邻行的代码。</li><li>合并分支时，两个分支有相同文件的不同修改。<br>解决冲突的步骤：</li><li>运行 <code>git status</code> 查看冲突文件。</li><li>打开冲突文件，在文件中可以看到类似于 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>、<code>=======</code> 和 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch_name</code> 的标记，这是冲突的标志。</li><li>手动编辑文件，保留需要的代码部分，删除冲突标记和无关的部分。</li><li>保存文件，然后运行 <code>git add</code> 将冲突文件标记为已解决。</li><li>运行 <code>git commit</code> 提交解决冲突后的修改。</li></ul></li><li><strong>恢复错误的代码或删除的文件</strong>：<ul><li>对于已提交的错误代码，可以通过创建新的提交来修复。你可以修改代码，然后提交一个新的修复提交。</li><li>对于已删除的文件，如果你没有提交删除操作，可以使用 <code>git checkout</code> 命令来还原文件，例如：<code>git checkout filename</code>。</li></ul></li><li><strong>项目代码管理的方法</strong>：<ul><li>使用版本控制系统，如 Git。</li><li>遵循分支管理策略，如 Git Flow，以便有条理地管理功能开发、测试和发布。</li><li>使用代码审查来保证代码质量。</li><li>使用持续集成和持续交付工具，确保代码的集成和交付过程自动化、稳定和可重复。</li><li>鼓励团队成员遵循一致的编码风格和最佳实践。</li></ul></li><li><strong>防止错误的代码提交</strong>：<ul><li>使用代码审查：通过审查他人的代码，可以发现和纠正错误。</li><li>使用自动化测试：编写自动化测试用例来检查代码是否正常工作。</li><li>使用持续集成：集成和自动化测试可以在提交之前自动运行，减少错误的机会。</li><li>使用预提交挂钩（pre-commit hooks）：可以设置钩子，在提交前运行特定的脚本来检查代码是否符合规范。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea快捷键</title>
      <link href="/posts/385c30d.html"/>
      <url>/posts/385c30d.html</url>
      
        <content type="html"><![CDATA[<p>原文链接：<a href="https://blog.csdn.net/m0_69057918/article/details/131036872">https://blog.csdn.net/m0_69057918/article/details/131036872</a><br>以下加粗是笔者根据自身使用情况整理的更常用的快捷键<br><strong>Ctrl + F 在当前文件进行文本查找</strong><br><strong>Ctrl + Z 撤销</strong><br><strong>Ctrl + Y 删除光标所在行 或 删除选中的行</strong><br><strong>Ctrl + X 剪切光标所在行 或 剪切选择内容</strong><br><strong>Ctrl + C 复制光标所在行 或 复制选择内容</strong><br><strong>Ctrl + D 复制光标所在行 或 复制选择内容，并把复制内容粘贴</strong><br><strong>Ctrl + P 方法参数提示显示</strong><br><strong>Ctrl + B 进入光标所在的方法/变量的接口或是定义处，等效于 Ctrl + 左键单击</strong><br><strong>Ctrl + K 版本控制提交项目，需要此项目有加入到版本控制才可用</strong><br><strong>Ctrl + T 版本控制更新项目，需要此项目有加入到版本控制才可用</strong><br><strong>Ctrl + H 显示当前类的层次结构（所有父类和子类）</strong><br><strong>Ctrl + / 注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号</strong></p><p><strong>Alt + Enter IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同</strong><br><strong>Alt + Insert 代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等</strong></p><p><strong>Ctrl + Alt + L 格式化代码，可以对当前文件和整个包目录使用</strong><br><strong>Ctrl + Alt + O 优化导入的类，可以对当前文件和整个包目录使用</strong><br><strong>Ctrl + Alt + 左方向键 退回到上一个操作的地方</strong><br><strong>Ctrl + Alt + 右方向键 前进到上一个操作的地方</strong></p><p><strong>Ctrl + Shift + U 对选中的代码进行大 / 小写转换</strong><br><strong>Ctrl + Shift + / 代码块注释</strong></p><p>一. Ctrl相关<br>Ctrl + W 递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围(从词逐渐向左右扩展)<br>Ctrl + R 在当前文件进行文本替换<br>Ctrl + E 显示最近打开的文件记录列表<br>Ctrl + N 根据输入的 类名 查找类文件<br>Ctrl + G 在当前文件跳转到指定行处<br>Ctrl + J 插入自定义动态代码模板<br>Ctrl + Q 光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容<br>Ctrl + U 前往当前光标所在的方法的父类的方法 / 接口定义<br>Ctrl + O 选择可重写的方法<br>Ctrl + I 选择可继承的方法<br>Ctrl + + 展开代码<br>Ctrl + - 折叠代码<br>Ctrl + [ 移动光标到当前所在代码的花括号开始位置<br>Ctrl + ] 移动光标到当前所在代码的花括号结束位置<br>Ctrl + F1 在光标所在的错误代码处显示错误信息<br>Ctrl + F3 调转到所选中的词的下一个引用位置<br>Ctrl + F4 关闭当前编辑文件<br>Ctrl + F8 在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点<br>Ctrl + F9 执行 Make Project 操作<br>Ctrl + F11 选中文件 / 文件夹，使用助记符设定 / 取消书签<br>Ctrl + F12 弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选<br>Ctrl + Tab 编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口<br>Ctrl + Enter 智能分隔行<br>Ctrl + End 跳到文件尾<br>Ctrl + Home 跳到文件头<br>Ctrl + Space 基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 ALT+/（必备）<br>Ctrl + Delete 删除光标后面的单词或是中文句<br>Ctrl + BackSpace 删除光标前面的单词或是中文句<br>Ctrl + 1,2,3…9 定位到对应数值的书签位置<br>Ctrl + 左键单击 在打开的文件标题上，弹出该文件路径<br>Ctrl + 光标定位 按 Ctrl 不要松开，会显示光标所在的类信息摘要<br>Ctrl + 左方向键 光标跳转到当前单词 / 中文句的左侧开头位置<br>Ctrl + 右方向键 光标跳转到当前单词 / 中文句的右侧开头位置</p><p>二. Alt相关<br>Alt + ` 显示版本控制常用操作菜单弹出层<br>Alt + Q 弹出一个提示，显示当前类的声明 / 上下文信息<br>Alt + F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择<br>Alt + F2 对于前面页面，显示各类浏览器打开目标选择弹出层<br>Alt + F3 选中文本，逐个往下查找相同文本，并高亮显示<br>Alt + F7 查找光标所在的方法 / 变量 / 类被调用的地方<br>Alt + F8 在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果<br>Alt + Home 定位 / 显示到当前文件的 Navigation Bar<br>Alt + 左方向键 按左方向切换当前已打开的文件视图<br>Alt + 右方向键 按右方向切换当前已打开的文件视图<br>Alt + 前方向键 当前光标跳转到当前文件的前一个方法名位置<br>Alt + 后方向键 当前光标跳转到当前文件的后一个方法名位置<br>Alt + 1,2,3…9 显示对应数值的选项卡，其中 1 是 Project 用得最多</p><p>三. Shift相关<br>Shift + F1 如果有外部文档可以连接外部文档<br>Shift + F2 跳转到上一个高亮错误 或 警告位置<br>Shift + F3 在查找模式下，查找匹配上一个<br>Shift + F4 对当前打开的文件，使用新Windows窗口打开，旧窗口保留<br>Shift + F6 对文件 / 文件夹 重命名<br>Shift + F7 在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法<br>Shift + F8 在 Debug 模式下，跳出，表现出来的效果跟 F9 一样<br>Shift + F9 等效于点击工具栏的 Debug 按钮<br>Shift + F10 等效于点击工具栏的 Run 按钮<br>Shift + F11 弹出书签显示层<br>Shift + Tab 取消缩进<br>Shift + ESC 隐藏当前 或 最后一个激活的工具窗口<br>Shift + End 选中光标到当前行尾位置<br>Shift + Home 选中光标到当前行头位置<br>Shift + Enter 开始新一行。光标所在行下空出一行，光标定位到新行位置<br>Shift + 左键单击 在打开的文件名上按此快捷键，可以关闭当前打开文件<br>Shift + 滚轮前后滚动 当前文件的横向滚动轴滚动</p><p>四. Ctrl + Alt相关<br>Ctrl + Alt + I 光标所在行 或 选中部分进行自动代码缩进，有点类似格式化<br>Ctrl + Alt + T 对选中的代码弹出环绕选项弹出层<br>Ctrl + Alt + J 弹出模板选择窗口，将选定的代码加入动态模板中<br>Ctrl + Alt + H 调用层次<br>Ctrl + Alt + B 在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口<br>Ctrl + Alt + V 快速引进变量<br>Ctrl + Alt + Y 同步、刷新<br>Ctrl + Alt + S 打开 IntelliJ IDEA 系统设置<br>Ctrl + Alt + F7 显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来<br>Ctrl + Alt + F11 切换全屏模式<br>Ctrl + Alt + Enter 光标所在行上空出一行，光标定位到新行<br>Ctrl + Alt + Home 弹出跟当前文件有关联的文件弹出层<br>Ctrl + Alt + Space 类名自动完成<br>Ctrl + Alt + 前方向键 在查找模式下，跳到上个查找的文件<br>Ctrl + Alt + 后方向键 在查找模式下，跳到下个查找的文件</p><p>五. Ctrl + Shift相关<br>Ctrl + Shift + F 根据输入内容查找整个项目 或 指定目录内文件<br>Ctrl + Shift + R 根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件<br>Ctrl + Shift + J 自动将下一行合并到当前行末尾<br>Ctrl + Shift + Z 取消撤销<br>Ctrl + Shift + W 递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围<br>Ctrl + Shift + N 通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠<br>Ctrl + Shift + T 对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择<br>Ctrl + Shift + C 复制当前文件磁盘路径到剪贴板<br>Ctrl + Shift + V 弹出缓存的最近拷贝的内容管理器弹出层<br>Ctrl + Shift + E 显示最近修改的文件列表的弹出层<br>Ctrl + Shift + H 显示方法层次结构<br>Ctrl + Shift + B 跳转到类型声明处<br>Ctrl + Shift + I 快速查看光标所在的方法 或 类的定义<br>Ctrl + Shift + A 查找动作 / 设置<br>Ctrl + Shift + [ 选中从光标所在位置到它的顶部中括号位置<br>Ctrl + Shift + ] 选中从光标所在位置到它的底部中括号位置<br>Ctrl + Shift + + 展开所有代码<br>Ctrl + Shift + - 折叠所有代码<br>Ctrl + Shift + F7 高亮显示所有该选中文本，按Esc高亮消失<br>Ctrl + Shift + F8 在 Debug 模式下，指定断点进入条件<br>Ctrl + Shift + F9 编译选中的文件 / 包 / Module<br>Ctrl + Shift + F12 编辑器最大化<br>Ctrl + Shift + Space 智能代码提示<br>Ctrl + Shift + Enter 自动结束代码，行末自动添加分号 （必备）<br>Ctrl + Shift + Backspace 退回到上次修改的地方<br>Ctrl + Shift + 1,2,3…9 快速添加指定数值的书签<br>Ctrl + Shift + 左键单击 把光标放在某个类变量上，按此快捷键可以直接定位到该类中 （必备）<br>Ctrl + Shift + 左方向键 在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句<br>Ctrl + Shift + 右方向键 在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句<br>Ctrl + Shift + 左方向键 在光标焦点是在工具选项卡上，缩小选项卡区域<br>Ctrl + Shift + 右方向键 在光标焦点是在工具选项卡上，扩大选项卡区域<br>Ctrl + Shift + 前方向键 光标放在方法名上，将方法移动到上一个方法前面，调整方法排序<br>Ctrl + Shift + 后方向键 光标放在方法名上，将方法移动到下一个方法前面，调整方法排序</p><p>六. Alt + Shift相关<br>Alt + Shift + N 选择 / 添加 task<br>Alt + Shift + F 显示添加到收藏夹弹出层 / 添加到收藏夹<br>Alt + Shift + C 查看最近操作项目的变化情况列表<br>Alt + Shift + I 查看项目当前文件<br>Alt + Shift + F7 在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入<br>Alt + Shift + F9 弹出 Debug 的可选择菜单<br>Alt + Shift + F10 弹出 Run 的可选择菜单<br>Alt + Shift + 左键双击 选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句<br>Alt + Shift + 前方向键 移动光标所在行向上移动<br>Alt + Shift + 后方向键 移动光标所在行向下移动</p><p>七. 其他<br>F2 跳转到下一个高亮错误 或 警告位置 （必备）<br>F3 在查找模式下，定位到下一个匹配处<br>F4 编辑源<br>F7 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中<br>F8 在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内<br>F9 在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上<br>F11 添加书签<br>F12 回到前一个工具窗口<br>Tab 缩进<br>ESC 从工具窗口进入代码文件窗口</p><p>Ctrl + Shift + Alt + V 无格式黏贴<br>Ctrl + Shift + Alt + N 前往指定的变量 / 方法<br>Ctrl + Shift + Alt + S 打开当前项目设置<br>Ctrl + Shift + Alt + C 复制参考信息</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven</title>
      <link href="/posts/c6e613d8.html"/>
      <url>/posts/c6e613d8.html</url>
      
        <content type="html"><![CDATA[<h1>Maven</h1><h2 id="基本概念">基本概念</h2><h3 id="仓库">仓库</h3><p>用于存储资源，包含各种jar包<br>分类：<br><strong>本地仓库</strong>:自己电脑上存储资源的仓库,连接远程仓库获取资源<br><strong>远程仓库</strong>:非本机电脑上的仓库，为本地仓库提供资源，分为中央仓库和私服<br>中央仓库: Maven团队维护，存储所有资源的仓库<br>私服:部门/公司范围内存储资源的仓库，从中央仓库获取资源<br><strong>私服的作用</strong>:<br>保存具有版权的资源,包含购买或自主研发的jar<br>中央仓库中的jar都是开源的，不能存储具有版权的资源<br>一定范围内共享资源，仅对内部开放，不对外共享</p><h3 id="坐标">坐标</h3><p>Maven中的坐标用于描述仓库中资源的位置<br>Maven坐标主要组成：<br>groupld:定义当前Maven项目隶属组织名称(通常是域名反写，例如: org.mybatis)<br>artifactld:定义当前Maven项目名称(通常是模块名称，例如CRM、SMS)<br>version:定义当前项目版本号<br>（packaging:定义该项目的打包方式）<br>Maven坐标的作用：<br>使用唯一标识，唯一性定位资源位置，通过该标识可以将资源的识别与下载工作交由机器完成</p><h3 id="仓库配置">仓库配置</h3><p>在maven的下载路径下有一个setting文件，可以更改一些基础设置，比如本地仓库的存储位置，以及配置阿里镜像仓库，即从阿里的仓库中获取资源而非中央仓库，这样快一点</p><h2 id="Maven的工程目录结构">Maven的工程目录结构</h2><img src="/post-img/Pasted image 20230822152137.png" alt="图片损坏" style="zoom:100%;" /><p>大概了解一下，现在一般是在idea中直接创建maven工程或spring工程</p><h2 id="依赖管理">依赖管理</h2><h3 id="依赖配置">依赖配置</h3><p>依赖是指当前项目运行所需的jar，一个项目可以设置多个依赖，这些依赖一般来自于中心仓库（私服），是前人或同事写好的jar包或工具类<br><img src="/post-img/Pasted image 20230822152553.png" alt="图片损坏" style="zoom:100%;" /></p><h3 id="依赖传递">依赖传递</h3><p>在引入一个新的jar包时，这个jar包可能依赖其它的jar包，在导入这个jar包时，会将它的所有依赖也一起导入，这就是依赖的传递性<br>直接依赖：在当前项目中通过依赖配置建立的依赖关系<br>间接依赖：被依赖的资源如果依赖其它资源，当前项目间接依赖其它资源<br>这有时会导致依赖传递冲突问题，也就是可能不同级的依赖相同但版本号不同，应遵守以下原则：<br>路径优先:当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高<br>声明优先:当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的<br>特殊优先:当同级配置了相同资源的不同版本，后配置的覆盖先配置的</p><h3 id="可选依赖">可选依赖</h3><p>可选依赖指对外隐藏当前所依赖的资源（但仍在使用）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="排除依赖">排除依赖</h3><p>排除依赖指不再使用当前所指的资源</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exalusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hamcrest<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hamcrest-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="依赖范围">依赖范围</h3><p>依赖的jar默认情况可以在任何地方使用，可以通过scope标签设定其作用范围<br>作用范围：<br>主程序范围有效(main文件夹范围内)<br>测试程序范围有效(test文件夹范围内)<br>是否参与打包(package指令范围内)<br><img src="/post-img/Pasted image 20230822153502.png" alt="图片损坏" style="zoom:100%;" /></p><h3 id="循环依赖">循环依赖</h3><ol><li><strong>优化模块设计</strong>： 首先，考虑你的模块设计是否合理。循环依赖通常是模块之间划分不清晰所导致的。尽量遵循单一职责原则，将模块按照功能分割，减少模块之间的直接依赖。</li><li><strong>拆分和合并模块</strong>： 如果发现存在循环依赖，考虑将其中一个或多个模块进行拆分或合并，以消除循环依赖。有时，将功能合并到一个模块中，或者将一些共享的功能抽离成一个独立的模块，可以帮助解决循环依赖问题。</li><li><strong>使用接口和抽象</strong>： 如果模块之间需要互相调用，尽量通过接口或抽象类来定义依赖关系，而不是直接依赖具体实现。这可以减少循环依赖的风险。</li><li><strong>Maven 中的 <code>&lt;dependencyManagement&gt;</code></strong>： 如果循环依赖是由于版本问题引起的，可以使用 Maven 的 <code>&lt;dependencyManagement&gt;</code> 部分来集中管理依赖的版本，以确保一致性。</li><li><strong>提取接口模块</strong>： 为了解决循环依赖，你可以创建一个独立的接口模块，其中定义了所有模块之间的接口。然后各个模块可以依赖于这个接口模块，而不会产生循环依赖。</li><li><strong>调整模块依赖关系</strong>： 在 <code>&lt;dependencies&gt;</code> 部分中，可以明确声明模块的依赖关系和作用域，以便更好地控制依赖。</li><li><strong>检查插件和目标</strong>： 有时，循环依赖可能是由于插件的配置或目标的执行引起的。检查是否有插件或目标的配置引发了循环依赖。</li><li><strong>使用模块路径</strong>： 如果使用 Java 9 及更高版本，可以尝试使用模块路径来隔离模块，避免循环依赖。</li><li><strong>重新考虑项目结构</strong>： 如果循环依赖问题无法通过上述方法解决，可能需要重新审视项目结构和模块之间的关系，进行更大范围的重构。</li></ol><h2 id="生命周期与插件">生命周期与插件</h2><h3 id="生命周期">生命周期</h3><p>生命周期指maven对项目的阶段的管理，一般分为三类：<br>clean：清理工作<br>default：核心工作，例如编译，测试，打包，部署等<br>site：产生报告，发布站点等<br>在执行某个生命周期时，会默认将这个生命周期前的所有生命周期全部执行完成，除非指定不执行某个生命周期</p><h3 id="插件">插件</h3><p>插件与生命周期内的阶段绑定，在执行到对应生命周期时执行对应的插件功能<br>内置插件：默认maven在各个生命周期上绑定有预设的功能<br>自定义插件：通过插件可以自定义其他功能，如果内置插件无法满足特定需求，可以创建自定义插件。自定义插件通常使用 Java 编写，通过继承 Maven 插件框架来实现。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> <span class="comment">&lt;!-- 插件的 Group ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-custom-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> <span class="comment">&lt;!-- 插件的 Artifact ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 插件的版本 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>custom-goal<span class="tag">&lt;/<span class="name">goal</span>&gt;</span> <span class="comment">&lt;!-- 自定义插件的目标（Goal） --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>idea中执行的生命周期：</p><ol><li><strong>clean</strong>： 清理项目构建生成的目录和文件，包括 <code>target</code> 目录。</li><li><strong>compile</strong>：编译项目的源代码，生成字节码文件。</li><li><strong>test</strong>： 运行项目的单元测试。</li><li><strong>package</strong>： 将编译后的代码打包成可分发的格式，如 JAR、WAR 或 EAR。</li><li><strong>install</strong>：将项目构建结果安装到本地 Maven 仓库，以供其他项目引用。</li><li><strong>deploy</strong>: 将构建结果部署到远程 Maven 仓库，以便其他项目或团队访问。</li><li><strong>site</strong>: 生成项目的站点文档和报告，如代码覆盖率、测试报告等。</li></ol><h2 id="分模块开发">分模块开发</h2><p>分模块开发思想是将一个大型应用程序分解为更小、更易管理的模块，每个模块负责不同的功能或组件。每个模块都可以独立开发、测试和部署。如在web编程中，将实体类pojo，业务层service，数据层dao，控制层controller都分别设置为一个独立的模块<br>这种方式有许多好处：</p><ol><li><strong>模块化</strong>：将应用程序分为模块使得代码更加模块化和组织有序，容易理解和维护。</li><li><strong>独立开发</strong>：开发人员可以专注于自己负责的模块，而不必关心整个应用程序。</li><li><strong>并行开发</strong>：不同模块可以并行开发，提高了开发效率。</li><li><strong>重用性</strong>：可以更轻松地将模块复用在其他项目中，从而提高了代码的重用性。</li><li><strong>测试</strong>：每个模块都可以独立测试，减少了单一应用程序中的复杂度。</li><li><strong>扩展性</strong>：添加新功能时，可以更容易地将新模块集成到现有应用程序中。</li></ol><h3 id="模块聚合">模块聚合</h3><p>模块聚合是将分开开发的模块汇总在一起，形成一个完整的应用程序。通常情况下，会有一个父级 POM（Project Object Model），其中包含所有模块的定义和依赖关系。父级 POM 也可以定义构建的顺序和版本控制策略。对父级模块进行操作时，所有子模块也会进行相同的操作<br><img src="/post-img/Pasted image 20230822162539.png" alt="图片损坏" style="zoom:100%;" /></p><h3 id="依赖继承">依赖继承</h3><p>在父工程中定义依赖管理，在子工程中定义依赖关系，无需声明依赖版本，版本参照父工程中依赖的版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;! --声明此处进行依赖管理--&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--具体的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--spring环境--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org. springframework&lt;/ groupId&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="继承与聚合对比">继承与聚合对比</h3><p>作用<br>聚合用于快速构建项目<br>继承用于快速配置<br>相同点:<br>聚合与继承的pom.xml文件打包方式均为pom，可以将两种关系制作到同一个pom文件中<br>聚合与继承均属于设计型模块，并无实际的模块内容<br>不同点:<br>聚合是在当前模块中配置关系，聚合可以感知到参与聚合的模块有哪些<br>继承是在子模块中配置关系，父模块无法感知哪些子模块继承了自己</p><h3 id="属性">属性</h3><p>在pom文件中可以通过property标签自定义属性，相当于define，之后用到时就可以用#{属性名}直接引用，修改属性中的值就可以同时修改所有引用处的值<br>属性分为自定义属性，内置属性，setting属性，java系统属性，环境变量属性<br><img src="/post-img/Pasted image 20230822163251.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="版本管理">版本管理</h2><p><strong>工程版本</strong><br>SNAPSHOT(快照版本)<br>项目开发过程中，为方便团队成员合作，解决模块间相互依赖和时时更新的问题，开发者对每个模块进行构建的时候，输出的临时性版本叫快照版本（(测试阶段版本)，快照版本会随着开发的进展不断更新<br>RELEASE(发布版本)<br>项目开发到进入阶段里程碑后，向团队外部发布较为稳定的版本，这种版本所对应的构件文件是稳定的，即便进行功能的后续开发，也不会改变当前发布版本内容，这种版本称为发布版本</p><p><strong>工程版本号约定</strong><br>约定规范:</p><ol><li>&lt;主版本&gt;.&lt;次版本&gt;,&lt;增量版本&gt;&lt;里程碑版本&gt;</li><li>主版本:表示项目重大架构的变更，如: spring5相较于spring4的迭代</li><li>次版本:表示有较大的功能增加和变化，或者全面系统地修复漏洞</li><li>增量版本:表示有重大漏洞的修复</li><li>里程碑版本:表明一个版本的里程碑（版本内部）。这样的版本同下一个正式版本相比，相对来说不是很稳定，有待更多的测试<br>范例:  5.1.9.RELEASE</li></ol><h2 id="资源加载属性值">资源加载属性值</h2><p>如果想任意配置文件中加载pom文件中定义的属性，可以在配置文件中使用 ${属性名}来调用，同时，需要在pom文件中配置开启此方式，反则编译时无法获取到属性值</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="comment">&lt;!--配置资源文件对应的信息--&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">resource</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&lt;!-设定配置文件对应的位置目录，支持使用属性动态设定路径--&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">directory</span>&gt;</span>$</span><span class="template-variable">&#123;project.basedir&#125;</span><span class="language-xml">/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="comment">&lt;!--开启对配置文件的资源加载过滤--&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&lt;/ resource&gt;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="跳过测试">跳过测试</h2><ol><li>使用命令跳过测试(执行的指令生命周期必须包含测试环节)</li></ol><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mvn</span> 某个指令 -D skipTests</span><br></pre></td></tr></table></figure><ol start="2"><li>使用界面操作跳过测试<br><img src="/post-img/Pasted image 20230822164623.png" alt="图片损坏" style="zoom:100%;" /></li><li>使用配置跳过测试（还可以包含或排除某些测试用例）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.22.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span><span class="comment">&lt;!--设置跳过测试--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">includes</span>&gt;</span> <span class="comment">&lt;!--包含指定的测试用例--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">inalude</span>&gt;</span>**/User*Test.java<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludes</span>&gt;</span><span class="comment">&lt;!--排除指定的测试用例--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/User*Testcase.java<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列概述</title>
      <link href="/posts/487a8a3.html"/>
      <url>/posts/487a8a3.html</url>
      
        <content type="html"><![CDATA[<h1>消息队列</h1><p>消息队列源于消费者生产者模式，由生产者（Producer）、消息处理中心（Broker）、和消费者（Consumer）三者构成，一般有点对点和发布订阅两种模式：</p><ol><li>点对点模式：多个生产者向同一个队列发送消息，每个消息只能由一个消费者消费</li><li>发布订阅模式：每个消息都能被多个订阅者获取和处理</li></ol><h1>核心功能</h1><p>消息队列（MQ）提供三个核心功能：解耦、异步处理和削峰。</p><ol><li><strong>业务解耦</strong> 是指在分布式系统中，各组件或服务之间不直接通信，而是通过消息队列进行交互。这种方式使得各组件可以独立地进行更新和扩展，增强了系统的灵活性和可扩展性。例如，在电商平台中，订单服务和支付服务可以通过消息队列进行通信，互不影响，从而减少系统间的直接依赖。</li><li><strong>异步处理</strong> 意味着系统的不同部分可以在不同的时间处理信息，从而提高整体效率和响应速度。在异步模型中，一个服务可以发送消息到队列，而不需要等待接收服务的响应。这种模式在高流量应用中尤其重要，如社交媒体平台中的消息传递。</li><li><strong>流量削峰</strong> 指的是使用消息队列来应对短时间内的高流量。通过消息队列，可以平衡负载，确保系统在面对高峰流量时不会崩溃。例如，在促销或大型销售事件期间，消息队列可以帮助电子商务网站处理突发的大量订单请求。</li></ol><h1>特点</h1><p>作为消息队列中间件，需要具备以下能力：</p><ol><li><strong>消息持久化</strong>：确保在系统故障时消息不会丢失。</li><li><strong>高可用性和容错性</strong>：通过集群和故障转移机制确保系统的稳定运行。</li><li><strong>消息确认和可靠传递</strong>：保证消息被正确接收和处理。</li><li><strong>负载均衡</strong>：在多个生产者和消费者间有效分配消息。</li><li><strong>扩展性</strong>：支持根据负载增加节点以扩展系统。</li></ol><h1>常见消息队列</h1><h2 id="RabbitMQ">RabbitMQ</h2><p>少数几个支持 AMQP 协议的消息队列之一。很容易部署和使用。客户端支持多种编程语言。<br>但有以下缺点：</p><ul><li>对消息堆积的支持不好，当大量消息积压的时候，会导致 RabbitMQ 的性能急剧下降。</li><li>RabbitMQ的性能是这几个消息队列中最差的，大概每秒钟只能处理几万到十几万条消息。如果应用对消息队列的性能要求非常高，那么不要选择 RabbitMQ。</li><li>RabbitMQ使用的编程语言是Erlang，扩展和二次开发成本高。</li></ul><h2 id="Kafka">Kafka</h2><p>Kafka与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域，几乎所有的相关开源软件系统都会优先支持 Kafka。Kafka性能高效、可扩展良好并且可持久化。它的分区特性，可复制和可容错都是不错的。Kafka 使用 Scala 和Java 语言开发，设计上大量使用了批量和异步的思想，使得 Kafka能做到超高的性能。Kafka 的性能，尤其是异步收发的性能，是三者中最好的，但与 RocketMQ 并没有量级上的差异，大约每秒钟可以处理几十万条消息。<br>但有以下缺点：</p><ul><li>同步收发消息的响应时延比较高，因为当客户端发送消息的时候，Kafka 采用的是<strong>批量发送</strong>，在它的 Broker中，很多地方都会使用这种先攒一波再一起处理的设计。当业务场景中每秒钟消息数量没有那么多的时候，Kafka 的时延反而会比较高。所以，Kafka 不太适合在线业务场景。topic达到上百个时，吞吐量会大幅下降。<br>高性能的原因：</li></ul><ol><li>磁盘顺序读写：保证了消息的堆积<ul><li>顺序读写，磁盘会<strong>预读</strong>，预读即在读取的起始地址连续读取多个页面，比随机读写的速度快不少，因为免去了磁盘寻道的时间</li></ul></li><li>使用零拷贝：避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。</li><li>分区分段+索引：Kafka的message消息实际上是分布式存储在一个一个小的segment中的，每次文件操作也是直接操作的segment。为了进一步的查询优化，Kafka又默认为分段后的数据文件建立了索引文件，就是文件系统上的.index文件。这种分区分段+索引的设计，不仅提升了数据读取的效率，同时也提高了数据操作的并行度</li><li>批量压缩/读写：多条消息一起压缩，降低带宽</li><li>直接操作page cache，而不是JVM、避免GC耗时及对象创建耗时，且读写速度更高，进程重启缓存也不会丢</li></ol><h2 id="RocketMQ">RocketMQ</h2><p>RocketMQ 有着不错的性能，<strong>稳定性和可靠性</strong>，具备一个现代的消息队列应该有的几乎全部功能和特性，并且它还在持续的成长中。RocketMQ 有非常<strong>活跃的中文社区</strong>，大多数问题可以找到中文的答案。RocketMQ 使用 Java 语言开发，源代码相对比较容易读懂，容易对RocketMQ 进行扩展或者二次开发。RocketMQ 对<strong>在线业务</strong>的响应时延做了很多的优化，大多数情况下可以做到毫秒级的响应。</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS</title>
      <link href="/posts/969d9481.html"/>
      <url>/posts/969d9481.html</url>
      
        <content type="html"><![CDATA[<h1>什么是CAS</h1><p>CAS（Compare And Swap）是一种多线程并发控制的技术，是一种原子操作。它用于解决多个线程同时修改同一内存位置时可能发生的竞态条件（Race Condition）问题。它是乐观锁思想的一种实现，尤其是在并发量大的业务场景下保证单个实例的原子性，java类库中java.util.concurrent.atomic包下一些方法，均使用CAS处理。CAS 操作是原子的，即整个过程中不会被中断或切换到其他线程执行。因此，CAS 操作在并发编程中常用于实现无锁算法、线程安全的数据结构以及乐观锁机制。</p><h1>操作流程</h1><p>CAS 操作包含三个参数：<strong>内存位置</strong>（通常是一个变量的内存地址）、<strong>期望值</strong>（即当前内存位置的预期值）和<strong>新值</strong>。CAS 操作执行的逻辑是：在操作提交之前，与原获取到的值先进行比较，如果当前内存位置的值等于期望值，则将该位置的值更新为新值；否则，重新获取内存位置的值，与期望值进行比较。 基本操作流程如下：</p><ol><li>读取内存位置的当前值。</li><li>比较当前值与预期值。</li><li>如果相同，则用新值更新内存位置的值，并返回成功标志。</li><li>如果不同，则不做任何操作，并返回失败标志，（稍后重试）。</li></ol><h1>原理</h1><ul><li><strong>UNSAFE</strong> 类：在早期的 JDK 版本中，<code>sun.misc.Unsafe</code> 类提供了对底层内存的直接操作，可以用于实现 CAS 操作。但是，这种方式使用不当可能会导致不安全的操作，因此在 JDK9 中标记为不推荐使用。</li><li><strong>JNI（Java Native Interface）</strong>：通过 JNI 调用本地方法，利用底层平台的原子性操作指令（如 <code>cmpxchg</code> 指令）来实现 CAS 操作。</li><li><strong>Java 内置的 CAS 支持</strong>：一些 JVM 实现提供了直接支持 CAS 操作的原生实现，通过底层的硬件支持或者 JVM 内部的优化来实现 CAS 操作的效率和性能。</li></ul><p>java.util.concurrent.atomic包中的一些方法使用了CAS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">counter.incrementAndGet();</span><br></pre></td></tr></table></figure><p>跟踪可以发现，最终调用的是一个native方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@IntrinsicCandidate</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSetInt</span><span class="params">(Object o, <span class="type">long</span> offset,  </span></span><br><span class="line"><span class="params">                                             <span class="type">int</span> expected,  </span></span><br><span class="line"><span class="params">                                             <span class="type">int</span> x)</span>;</span><br></pre></td></tr></table></figure><p>这个方法的注释说：这个方法的作用是原子性地将 Java 变量更新为指定的值 x，但仅当它当前持有预期的值 expected 时才进行更新。这个操作具有内存语义上的 volatile 读和写，即读取和写入操作具有与 volatile 变量相同的内存语义，保证了对变量的读取和写入操作在内存中的可见性。也就是说，java中使用<strong>CAS+volatile</strong>为我们提供了一种实现并发编程的方法（即Atomic系列类），而CAS的底层调用的是操作系统的一个原子命令。</p><h1>优缺点</h1><h2 id="优点">优点</h2><ul><li><strong>高效性</strong>：CAS 操作是基于硬件支持的原子操作，比传统的锁机制更高效。</li><li><strong>无锁化</strong>：CAS 操作不需要使用锁，避免了锁带来的性能开销和线程阻塞。</li><li><strong>并发安全</strong>：CAS 操作保证了对共享资源的并发访问的安全性，避免了竞态条件和数据不一致的问题。</li></ul><h2 id="可能的问题">可能的问题</h2><ul><li><strong>ABA问题</strong>：CAS 操作可能会忽略中间状态的变化，导致 ABA 问题（即在其他线程修改前后，被比较的值恰好变回了原来的值），这个问题可以通过添加版本号或时间戳的方法来解决（AtomicStampedReference采取的是这种方式）。</li><li><strong>自旋消耗性能</strong>：CAS 操作会引入自旋等待，当多个线程同时尝试更新相同的内存位置时，可能会导致自旋等待过长，影响性能。</li><li><strong>只能修改一个变量</strong>：CAS不能确保代码块的原子性，因为CAS机制确保的是一个变量的原子性操作，并不能保证整个代码块的原子性。如果多个变量共同进行原子性的更新操作，就需要用lock或者synchronized了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized详解</title>
      <link href="/posts/f0baa025.html"/>
      <url>/posts/f0baa025.html</url>
      
        <content type="html"><![CDATA[<h1>并发编程中的三大问题</h1><ol><li><strong>原子性问题（Atomicity）：</strong><ul><li><strong>定义：</strong> 保证一个操作是不可中断的，要么全部执行成功，要么全部不执行。</li><li><strong>问题：</strong> 当多个线程同时执行一组操作时，可能出现一部分操作已经执行而另一部分没有执行的情况，导致数据不一致性。</li></ul></li><li><strong>可见性问题（Visibility）：</strong><ul><li><strong>定义：</strong> 一个线程对共享变量的修改能够及时被其他线程看到。</li><li><strong>问题：</strong> 当一个线程修改了共享变量的值，其他线程可能无法立即感知到这个变化，从而导致数据的不一致性。</li></ul></li><li><strong>有序性问题（Ordering）：</strong><ul><li><strong>定义：</strong> 确保程序执行的顺序与代码的书写顺序一致。</li><li><strong>问题：</strong> 由于编译器的优化或硬件的乱序执行，代码的执行顺序可能与预期不一致，导致意外的结果。</li></ul></li></ol><h1>JMM（Java Memory Modle）</h1><p>Java内存模型，是Java虚拟机规范中所定义的一种内存模型，Java内存模型是标准化的，屏蔽掉了底层不同计算机的区别。它是一套规范，描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节。Java内存模型是一套在多线程读写共享数据时，对共享数据的可见性、有序性、和原子性的规则和保障。</p><ol><li>主内存：是所有线程都共享的，都能访问的。所有的共享变量都存储于主内存。</li><li>工作内存：每一个线程有自己的工作内存，工作内存只存储该线程对共享变量的<strong>副本</strong>。线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接访问对方工作内存中的变量。</li><li>JMM是一种抽象的逻辑概念，Java内存模型和计算机硬件内存架构是一个相互交叉的关系，是一种抽象概念划分与真实物理硬件的交叉</li></ol><h2 id="JMM中主内存与工作内存之间的数据交互过程">JMM中主内存与工作内存之间的数据交互过程</h2><p>Java内存模型中定义了以下8种操作来完成，主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的。<br>分别是lock、read、load、use、assign、store、write、unlock<br>1.如果对一个变量执行lock操作，将会清空工作内存中此变量的值<br>2.对一个变量执行unlock操作之前，必须先把此变量同步到主内存中</p><h1>synchronized与三大特性</h1><p>synchronized可以保证原子性、有序性、可见性，其中有序性和可见性是通过JMM规范的八个命令中的lock和unlock命令保证的</p><ol><li><strong>原子性（Atomicity）：</strong><ul><li><code>synchronized</code> 保证了代码块或方法中的所有操作要么全部执行成功，要么全部失败，不会被其他线程中断。当一个线程获得锁时，它将独占锁，其他线程必须等待释放锁后才能继续执行。</li></ul></li><li><strong>可见性（Visibility）：</strong><ul><li>当一个线程获得锁进入 <code>synchronized</code> 代码块时，它会清空工作内存中的共享变量副本，强制从主内存中重新读取共享变量的值。同样，线程在释放锁的时候会将修改后的值刷新回主内存，这样其他线程能够感知到这些变化。这确保了对共享变量的修改对其他线程可见。</li></ul></li><li><strong>有序性（Ordering）：</strong><ul><li>as-if-serial：不管编译器和CPU如何重排序，必须保证在单线程情况下程序的结果是正确的。也就是逻辑上有先后关系的代码不会被重排序，例如a=1,b=2,c=a+b可能被重排序为b=2,a=1,c=a+b，但不可能被重排序为a=1,c=a+b,b=2</li><li><code>synchronized</code> 保证了线程进入和退出临界区的有序性。即，一个线程在释放锁之前，必须把修改过的变量刷新到主内存，而获取锁的线程要求从主内存中读取变量的最新值。这就确保了线程之间的有序性，防止了乱序执行。</li></ul></li></ol><h1>特性</h1><h2 id="可重入锁">可重入锁</h2><p>一个线程在持有锁的情况下，可以再次获取相同的锁，而不会造成死锁。这是通过<strong>为每个锁关联一个持有者线程和一个计数器</strong>来实现的。当一个线程第一次获取锁时，计数器为1，每次递归获取锁，计数器递增。只有当计数器降为零时，锁才会被释放。这确保了线程可以多次进入同一个 <code>synchronized</code> 代码块，而不会发生死锁。可重入锁是一种提高程序灵活性和避免死锁的设计。</p><h2 id="不可中断">不可中断</h2><p>不可中断：一个线程获得锁后，另一个线程想要获得锁，必须处于阻塞或等待状态，如果第一个线程不释放锁，第二个线程会一直阻塞或等待，不可被中断。</p><h1>原理</h1><h2 id="monitorenter">monitorenter</h2><ol><li>每一个对象都会和一个<strong>监视器</strong>monitor关联。监视器被占用时会被锁住，其他线程无法来获取该monitor。当JVM执行某个线程的某个方法内部的monitorenter时，它会尝试去获取当前对象对应的monitor的所有权。其过程如下︰</li><li>获取当前对象对应的monitor的所有权的过程：<ul><li>若monior的进入数为0，线程可以进入monitor，并将monitor的进入数置为1。当前线程成为monitor的owner (所有者）</li><li>若线程已拥有monitor的所有权，允许它重入monitor，则进入monitor的进入数加1</li><li>若其他线程已经占有monitor的所有权，那么当前尝试获取monitor的所有权的线程会被阻塞，直到monitor的进入数变为0，才能重新尝试获取monitor的所有权。</li></ul></li><li>synchronized的锁对象会关联一个monitor,这个monitor不是我们主动创建的,是JVM的线程执行到这个同步代码块,发现锁对象没有monitor就会创建monitor,monitor内部有两个重要的成员变量：<ul><li>owner:拥有这把锁的线程</li><li>recursions会记录线程拥有锁的次数,当一个线程拥有monitor后其他线程只能等待</li></ul></li></ol><h2 id="monitorexit">monitorexit</h2><ol><li>能执行monitorexit指令的线程一定是拥有当前对象的monitor的所有权（owner）的线程。</li><li>执行monitorexit时会将monitor的进入数减1。当monitor的进入数减为0时，当前线程退出monitor，不再拥有monitor的所有权，此时其他被这个monitor阻塞的线程可以尝试去获取这个monitor的所有权monitorexit释放锁。</li><li>monitorexit插入在方法结束处和异常处，JVM保证每个monitorenter必须有对应的monitorexit，因此<strong>synchornized出现异常时会释放锁</strong></li></ol><h2 id="对象头的结构">对象头的结构</h2><p>在 HotSpot JVM 中，对象头包括两部分信息，分别是 Mark Word 和 Klass Pointer</p><ol><li>Mark Word用于存储对象自身的运行时数据，如哈希码(HashCode ) 、GC分代年龄、锁状态标志线程持有的锁、偏向线程ID、偏向时间戳等等，占用内存大小与虚拟机位长一致。</li><li>Klass Pointer用于存储对象的类型指针，该指针指向它的类元数据，JVM通过这个指针确定对象是哪个类的实例。该指针的位长度为JVM的一个字大小，即32位的JVM为32位，64位的JVM为64位。</li></ol><h1>锁升级</h1><ol><li><strong>偏向锁（Biased Locking）：</strong><ul><li>初始时，一个对象的头部信息会包含偏向锁标记。当某个线程访问这个对象并获取锁时，会将该线程的ID记录在对象头中，并将偏向锁标记置为1。之后，如果同一个线程再次访问该对象，无需竞争，直接获取锁。这提高了同一线程多次获取锁的效率。</li></ul></li><li><strong>轻量级锁（Lightweight Locking）：</strong><ul><li>当有多个线程竞争同一把锁时，偏向锁就不再合适。此时，锁会升级为轻量级锁。在轻量级锁的情况下，当前获取到锁的线程将对象的Mark Word复制到栈帧中的Lock Recod中，Mark Word更新为指向Lock Record的指针。其他线程在尝试获取锁时会将对象头的 Mark Word 复制到线程的栈帧中，并进行自旋操作，而不是直接阻塞线程。如果自旋失败（10次以上仍未获取），锁升级为重量级锁。</li></ul></li><li><strong>重量级锁（Heavyweight Locking）：</strong><ul><li>当轻量级锁自旋失败，多个线程竞争同一把锁的时候，锁会升级为重量级锁。在这种情况下，JVM 使用操作系统提供的互斥量来实现锁。此时，如果一个线程获取了锁，其他线程必须阻塞等待。重量级锁是通过对象头关联的monitor（见补充）实现的。</li></ul></li></ol><h1>优化</h1><ol><li>锁消除：在synchronized修饰的代码中，如果不存在操作临界资源的情况，编译时JIT触发锁消除，相当于无锁</li><li>锁膨胀：如果在一个循环中，频繁的获取和释放做资源，这样带来的消耗很大，锁膨胀就是将锁的范围扩大，避免频繁的竞争和获取锁资源带来不必要的消耗</li><li>锁升级：synchronized在JDK1.6之前，获取不到锁，立即挂起当前线程，所synchronized性能比较差，之后做了锁升级的优化，即无锁—&gt;偏向锁—&gt;轻量级锁—&gt;重量级锁；有的观点认为锁只能升级，不能降级，也有说锁降级确实是会发生的，当 JVM 进入安全点（SafePoint）的时候，会检查是否有闲置的 Monitor，然后试图进行降级。</li></ol><h1>补充</h1><h2 id="java中对象的结构">java中对象的结构</h2><p>java对象由三部分组成：对象头，实例数据，对齐填充</p><ol><li>对象头：由 Mark Word 和 Klass Pointer组成</li><li>实例数据：就是类中定义的成员变量</li><li>对齐填充：并不是必然存在的，也没有什么特别的意义，他仅仅起着占位符的作用，由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头正好是8字节的倍数，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</li></ol><h2 id="monitor">monitor</h2><ol><li>每一个Java对象都<code>可以</code>与一个监视器monitor关联，我们可以把它理解成为一把锁，当一个线程想要执行一段被synchronized圈起来的同步方法或者代码块时，该线程得先获取到synchronized修饰的对象对应的monitor。</li><li>monitor并不是随着对象创建而创建的。我们是通过synchronized修饰符告诉VM需要为我们的某个对象创建关联的monitor对象。</li><li>monitor的重要成员变量<ul><li>_owner:初始时为NULL。当有线程占有该monitor时，owner标记为该线程的唯一标识。当线程释放monitor时，owner又恢复为NULL。owner是一个临界资源，JVM是通过CAS操作来保证其线程安全的。</li><li>_CXq∶竞争队列，所有请求锁的线程首先会被放在这个队列中（单向链接）。_cxq是一个临界资源，JVM通过CAS原子指令来修改_cxq队列。修改前_cxq的旧值填入了node的next字段，_cxq指向新值（新线程)。因此_cxq是一个后进先出的stack(栈)。</li><li>_EntryList : _cxq队列中有资格成为候选资源的线程会被移动到该队列中。</li><li>_WaitSet :因为调用wait方法而被阻塞的线程会被放在该队列中。</li></ul></li><li>monitor是重量级锁：<ul><li>ObjectMonitor（hotspot的monitor实现）的函数调用中会涉及到Atomic::cmpxchg_ptr，Atomic:.inc_ptr等内核函数，执行同步代码块，没有竞争到锁的对象会park()被挂起，竞争到锁的线程会unpark()唤醒。这个过程中存在操作系统用户态和内核态的转换，这种切换会消耗大量的系统资源。所以synchronized在Java语言中是一个重量级(Heavyweight)的操作。</li></ul></li></ol><h2 id="安全点（safe-point）">安全点（safe point）</h2><p>安全点是程序执行的一个状态，JVM 在这个状态下，能够确保所有线程都在安全位置，不会出现对对象引用的修改。在安全点上，JVM 可以停止所有线程，进行垃圾回收、线程栈的修改等操作，而不会导致数据不一致或错误的状态。在安全点上，线程不会在执行关键的、可能导致数据不一致的代码。<br>安全点通常发生在一些特定的位置，包括：</p><ol><li><strong>方法调用：</strong><ul><li>在方法调用的地方，JVM 可以方便地确保所有线程都在一个安全的状态。这可以是方法的入口或返回点。</li></ul></li><li><strong>循环跳跃：</strong><ul><li>在循环的迭代点，例如 for 循环的迭代点，也是安全点。这是因为在循环迭代点，线程通常都在相对较安全的位置。</li></ul></li><li><strong>异常抛出：</strong><ul><li>在抛出异常的地方，例如在 <code>throw</code> 语句附近，也是一个潜在的安全点。</li></ul></li><li><strong>代码生成器插入的安全点：</strong><ul><li>代码生成器在生成机器码时，会在适当的位置插入安全点，以确保在执行这些机器码时，所有线程都在一个安全的状态。。在某些情况下，为了减少安全点的频率，JVM 可能会选择较少的插入安全点，从而提高程序的运行效率。</li></ul></li></ol><h2 id="synchronized与Lock的区别">synchronized与Lock的区别</h2><ol><li>synchronized是关键字，而Lock是一个接口。</li><li>synchronized会自动释放锁，而Lock必须手动释放锁。</li><li>synchronized是不可中断的，Lock可以中断也可以不中断。</li><li>通过Lock可以知道线程有没有拿到锁，而synchronized不能。</li><li>synchronized能锁住方法和代码块，而Lock只能锁住代码块。</li><li>Lock可以使用读锁提高多线程读效率。</li><li>synchronized是非公平锁，ReentrantLock可以控制是否是公平锁。</li></ol><h1>总结</h1><ol><li>synchornized是可重入锁，不可中断锁</li><li>可以保证原子性，有序性和可见性（JMM中定义的8种原子操作）</li><li>原理是java对象头（偏向锁、轻量级锁）以及monitor（重量级锁）</li><li>jdk6后提供了锁优化：锁消除、锁膨胀、锁升级</li></ol>]]></content>
      
      
      <categories>
          
          <category> 源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot自动配置原理</title>
      <link href="/posts/38650253.html"/>
      <url>/posts/38650253.html</url>
      
        <content type="html"><![CDATA[<h1>@SpringBootApplication</h1><p>Spring Boot的启动类上的注解@SpringBootApplication是实现自动配置的关键，跟踪可以看到@SpringBootApplication包含许多注解<br><img src="/post-img/Pasted image 20240303201036.png" alt="图片损坏" style="zoom:100%;" /></p><p>下面依次说明各注解的作用</p><ol><li><code>@Target(&#123;ElementType.TYPE&#125;)</code>: 这个注解指定了该自定义注解可以应用的目标元素类型。在这里，它指定了这个注解只能应用于类（Type）。</li><li><code>@Retention(RetentionPolicy.RUNTIME)</code>: 这个注解指定了该自定义注解在运行时可见。在这里，它表示这个注解在运行时会保留，因此可以通过<strong>反射</strong>来访问它。</li><li><code>@Documented</code>: 这个注解指定了当Java文档工具（如Javadoc）生成文档时，是否将这个注解包含在文档中。在这里，它表示这个注解会被文档化。</li><li><code>@Inherited</code>: 这个注解指定了子类是否会继承父类的注解。在这里，它表示子类会继承这个注解。</li><li><code>@SpringBootConfiguration</code>: 这个注解是Spring Boot提供的一个特殊的配置类注解，它等同于<code>@Configuration</code>。用于标识一个类是Spring Boot应用程序的配置类，通常用于定义Bean。</li><li><code>@EnableAutoConfiguration</code>: 这个注解启用了Spring Boot的自动配置功能。它会根据类路径中的情况自动配置Spring应用程序。这是Spring Boot自动配置的核心注解之一。</li><li><code>@ComponentScan</code>: 这个注解指示Spring在指定的包及其子包中搜索带有注解的组件。它可以用于指定要扫描的包路径。</li></ol><h1>@EnableAutoConfiguration</h1><p>@EnableAutoConfiguration是Spring Boot自动配置的核心注解之一，跟踪可以发现它同样包含许多注解，其中@AutoConfigurationPackage和@Import是自动配置的关键<br><img src="/post-img/Pasted image 20240303201722.png" alt="图片损坏" style="zoom:100%;" /></p><ol><li><code>@AutoConfigurationPackage</code>: 这个注解用于指示Spring Boot应该自动配置位于指定包及其子包中的Bean。它会将该包及其子包下的所有组件加入到Spring Boot的自动配置中。</li><li><code>@Import</code>: 这个注解是Spring的核心注解之一，它用于导入其他配置类或者配置项。在这里，通过导入<code>AutoConfigurationImportSelector.class</code>，实现了自动配置的导入。</li></ol><h1>类AutoConfigurationImportSelector</h1><p>@Import导入了类AutoConfigurationImportSelector，这个类实现了DeferredImportSelector，再跟进可以发现DeferredImportSelector继承自ImportSelector，而ImportSelector中的方法selectImports的返回值就保存着需要自动配置的类的全类名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] selectImports(AnnotationMetadata importingClassMetadata);</span><br></pre></td></tr></table></figure><p>它在AutoConfigurationImportSelector中的实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;  </span><br><span class="line">       <span class="keyword">return</span> NO_IMPORTS;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">AutoConfigurationEntry</span> <span class="variable">autoConfigurationEntry</span> <span class="operator">=</span> getAutoConfigurationEntry(annotationMetadata);  </span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容易发现，返回值是通过getAutoConfigurationEntry方法获取并通过getConfigurations获取的，继续跟进getAutoConfigurationEntry方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title function_">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;  </span><br><span class="line">       <span class="keyword">return</span> EMPTY_ENTRY;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> getAttributes(annotationMetadata);  </span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);  </span><br><span class="line">    configurations = removeDuplicates(configurations);  </span><br><span class="line">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);  </span><br><span class="line">    checkExcludedClasses(configurations, exclusions);  </span><br><span class="line">    configurations.removeAll(exclusions);  </span><br><span class="line">    configurations = getConfigurationClassFilter().filter(configurations);  </span><br><span class="line">    fireAutoConfigurationImportEvents(configurations, exclusions);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationEntry</span>(configurations, exclusions);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出我们需要的configurations集合来自getCandidateConfigurations方法，继续跟进</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> List&lt;String&gt; <span class="title function_">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> &#123;  </span><br><span class="line">    List&lt;String&gt; configurations = ImportCandidates.load(AutoConfiguration.class, getBeanClassLoader())  </span><br><span class="line">       .getCandidates();  </span><br><span class="line">    Assert.notEmpty(configurations,  </span><br><span class="line">          <span class="string">&quot;No auto configuration classes found in META-INF/spring.factories nor in META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. If you are using a custom packaging, make sure that file is correct.&quot;</span>);  </span><br><span class="line">    <span class="keyword">return</span> configurations;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的文本信息很关键，告诉我们auto configuration classes（自动配置类）是在两个文件中获取的（springboot3.0之后已经取消了META-INF/spring.factories），找到这两个文件，可以发现其中确实存在许多全类名，随便选一个类名跟进，可以发现有@AutoConfiguration，而这个注解又包含@Configuration，也就是说，它是一个配置类，并且提供了被@Bean修饰的方法来返回bean对象，因此，一旦该类被加载，对应的bean就会自动进入IOC容器，我们后续就可以使用，这就是所谓的自动配置</p><h1>流程梳理</h1><p>经过上述跟进源码，我们可以梳理一下整个流程：</p><ol><li>Spring Boot实现自动配置的关键注解<ul><li>@SpringBootApplication—&gt;@EnableAutoConfiguration</li><li>@EnableAutoConfiguration—&gt;@Import({AutoConfigurationImportSelector.class})</li></ul></li><li>AutoConfigurationImportSelector类中的方法selectImports返回需要加载的配置类<ul><li>selectImports—&gt;getAutoConfigurationEntry</li><li>getAutoConfigurationEntry—&gt;getCandidateConfigurations</li><li>getCandidateConfigurations—&gt;META-INF/spring.factories文件</li></ul></li><li>META-INF/spring.factories文件中存放了所有需要进行自动配置的类</li></ol><h1>@ConditionalOnXXX</h1><p>一个配置类中通常会包含许多bean，那么这些bean全部都会随着配置类的加载进入IOC容器吗，当然不会，这就是@ConditionalOnXXX系列注解的作用<br>它用于配置类或者组件上(@Bean修饰的方法)上，可以根据项目的特定需求和环境来决定是否加载某个组件或配置，从而实现更加灵活和可配置的应用程序开发。<br>常见的<code>@ConditionalOnXXX</code>注解及其作用：</p><ol><li><code>@ConditionalOnClass</code>: 当指定的类位于类路径中时，才会生效。</li><li><code>@ConditionalOnMissingClass</code>: 当指定的类不位于类路径中时，才会生效。</li><li><code>@ConditionalOnBean</code>: 当指定的Bean存在于Spring应用程序上下文中时，才会生效。</li><li><code>@ConditionalOnMissingBean</code>: 当指定的Bean不存在于Spring应用程序上下文中时，才会生效。</li><li><code>@ConditionalOnProperty</code>: 当指定的属性满足条件时，才会生效。</li><li><code>@ConditionalOnResource</code>: 当指定的资源存在时，才会生效。</li><li><code>@ConditionalOnWebApplication</code>: 当应用程序是一个Web应用程序时，才会生效。</li><li><code>@ConditionalOnNotWebApplication</code>: 当应用程序不是一个Web应用程序时，才会生效。</li><li><code>@ConditionalOnExpression</code>: 当指定的SpEL表达式计算结果为true时，才会生效。</li></ol><h1>总结</h1><p>Spring Boot自动配置原理：</p><ol><li>@SpringBootApplication包含若干注解，其中比较重要的是@ComponentScan，@EnableAutoConfiguration，@@SpringBootApplication，而@EnableAutoConfiguration是实现自动配置的关键注解</li><li>@EnableAutoConfiguration包含@AutoConfigurationPackage和@Import两个关键注解，@AutoConfigurationPackage指明Spring Boot应该自动配置位于指定包及其子包中的Bean，而@Import导入的类AutoConfigurationImportSelector中则通过selectImports方法扫描了META-INF/spring.factories文件，并加载了其中的所有配置类</li><li>配置类加载后，其中的bean根据其条件注解@ConditionalOnXXX决定是否被放入IOC容器中</li><li>可以从IOC容器中获取bean对象，自动配置完成</li></ol><h1>补充</h1><h2 id="ComponentScan的参数">@ComponentScan的参数</h2><p><code>@ComponentScan</code>注解可以包含多个参数，用于指定扫描的方式和范围。下面是<code>@ComponentScan</code>注解常用的参数：</p><ol><li><strong>basePackages</strong>: 指定要扫描的基础包。可以指定一个或多个包路径，多个包路径之间用逗号分隔。如果不指定该参数，默认扫描注解所在类的包及其子包。</li><li><strong>basePackageClasses</strong>: 指定要扫描的基础类。通常是一些标志性的类，<code>@ComponentScan</code>会扫描这些类所在的包及其子包。如果同时指定了<code>basePackages</code>和<code>basePackageClasses</code>，则<code>basePackages</code>会被忽略。</li><li><strong>includeFilters</strong>: 指定包含过滤器，用于指定哪些类应该被包含在扫描范围内。默认为空数组。可以通过<code>@Filter</code>注解指定过滤条件。</li><li><strong>excludeFilters</strong>: 指定排除过滤器，用于指定哪些类应该被排除在扫描范围外。默认为空数组。可以通过<code>@Filter</code>注解指定过滤条件。</li><li><strong>useDefaultFilters</strong>: 是否启用默认过滤器。默认值为true，表示启用默认过滤器，会扫描所有的组件。如果设置为false，则需要显式地配置包含和排除过滤器。</li><li><strong>lazyInit</strong>: 是否启用延迟初始化。默认值为false，表示不启用延迟初始化。如果设置为true，则会延迟初始化扫描到的所有组件。</li><li><strong>resourcePattern</strong>: 指定要扫描的资源模式。默认值为&quot;/*.class&quot;，表示扫描所有的类文件。可以根据需要指定其他模式，比如&quot;/*.java&quot;。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    basePackages = &#123;&quot;com.example.services&quot;, &quot;com.example.controllers&quot;&#125;,</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">        @Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class&#125;),</span></span><br><span class="line"><span class="meta">        @Filter(type = FilterType.REGEX, pattern = &quot;.*Test.*&quot;)</span></span><br><span class="line"><span class="meta">    &#125;,</span></span><br><span class="line"><span class="meta">    useDefaultFilters = false</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 这是一个配置类，用于指定组件扫描的方式和范围</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ComponentScan和-EnableAutoConfiguration">@ComponentScan和@EnableAutoConfiguration</h2><ol><li>在Spring Boot应用程序中，<code>@ComponentScan</code>注解通常用于扫描自定义的配置类（例如包含<code>@Configuration</code>注解的类），以及其他自定义的组件（例如包含<code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, <code>@Controller</code>等注解的类）。这些自定义的配置类和组件通常位于<strong>自己编写的包</strong>中。</li><li>对于<strong>starter中的配置类</strong>，通常是通过<code>@EnableAutoConfiguration</code>注解来启用的。starter通常会提供一些自动配置类，这些自动配置类会被Spring Boot的<code>@EnableAutoConfiguration</code>注解自动扫描并加载。这些自动配置类中通常包含了一些自动配置的逻辑，用于根据项目的依赖和条件自动配置应用程序的一些功能。</li><li>在Spring Boot应用程序中，自定义的配置类和组件可以使用@ComponentScan注解来扫描并加载，而starter中的配置类通常是通过@EnableAutoConfiguration注解来启用的，然后通过SpringFactoriesLoader加载自动配置类。这样就能够实现自定义配置和自动配置的组合使用，从而灵活地定制和配置应用程序的功能。</li></ol><h2 id="自定义starter">自定义starter</h2><ol><li>SpringBoot Starter 类似于一种插件机制，抛弃了之前繁琐的配置，将复杂依赖统一集成进 Starter。所有依赖模块都遵循着约定成俗的默认配置，并允许我们调整这些配置，即遵循“约定大于配置”的理念 。Starter 的出现极大的帮助开发者们从繁琐的框架配置中解放出来，从而更专注于业务代码。</li><li>Spring 官方提供 Starter 通常命名为 spring-boot-starter-{name} 如：spring-boot-starter-web，spring-boot-starter-activemq 等；Spring 官方建议非官方提供的 Starter 命名应遵守 {name}-spring-boot-starter 的格式：如mybatis-spring-boot-starter。</li><li>Starter 也是基于 SpringBoot 项目创建的，所以第一步应该先创建 SpringBoot 项目，编写pom文件和需要自动配置的类（用@Configuration和@Bean），Resources 目录下新建 META-INF 文件夹，然后创建 spring.factories 文件<ul><li>为什么要指定 resources/META-INF 下写 spring.factories？后续补充</li></ul></li><li>完成后通过maven打包测试（可以获取到bean就算成功了）并保存到本地仓库中，后续就可以供自己使用了</li><li>可插拔starter虽然引入了Starter Jar 包，但是可以通过条件判断是否加载满足条件的话加载此 Jar 相关配置，不满足就不加载，这可以通过自定义注解+条件注解实现，例如</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfigTest &#123; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AutoConfigurationTest 类中添加条件注解，然后重新打包至本地仓库</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(annotation = EnableAutoConfigTest.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoConfigurationTest</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ServiceBean <span class="title function_">getServiceBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServiceBean</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在主程序引用 @EnableAutoConfigTest 注解</span></span><br><span class="line"><span class="meta">@EnableAutoConfigTest</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoTestSpringBootStarterApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoTestSpringBootStarterApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么一定是spring-factories">为什么一定是spring.factories</h2><p><code>@EnableAutoConfiguration</code>注解通过读取<code>META-INF/spring.factories</code>文件的内容来加载自动配置类。这个过程是由Spring框架的<code>SpringFactoriesLoader</code>类实现的。<br>具体来说，<code>SpringFactoriesLoader</code>类提供了一个静态方法<code>loadFactoryNames()</code>，这个方法接收一个ClassLoader和一个要加载的工厂类型作为参数，然后返回一个包含工厂名称的列表。在Spring Boot中，<code>@EnableAutoConfiguration</code>注解内部就是通过调用<code>SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class, classLoader)</code>方法来加载自动配置类的。<br><code>SpringFactoriesLoader</code>在加载<code>META-INF/spring.factories</code>文件时，会使用给定的ClassLoader来查找这个文件。一旦找到了<code>spring.factories</code>文件，它会读取文件中每个工厂类型对应的配置，并将这些工厂名称加载到一个列表中返回。<br>总而言之<code>SpringFactoriesLoader#loadFactories</code> 负责完成自动装配类的加载，扫描的就是这个变量文件，因此它的名称不可随意更改</p>]]></content>
      
      
      <categories>
          
          <category> 源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/posts/7b510e10.html"/>
      <url>/posts/7b510e10.html</url>
      
        <content type="html"><![CDATA[<h1>代理模式</h1><p>代理模式是一种结构型设计模式，其主要目的是控制对对象的访问。在代理模式中，代理对象充当了被代理对象的中间人，客户端通过代理对象来间接访问被代理对象，从而可以在访问过程中添加额外的功能或控制访问的权限。其作用包括：</p><ul><li><strong>对客户端透明</strong>：客户端无需知道代理对象的存在，可以直接通过代理对象来访问被代理对象，从而降低了客户端与被代理对象之间的耦合度。</li><li><strong>控制访问</strong>：代理对象可以在访问过程中添加额外的功能，如权限验证、日志记录、性能监控等。</li><li><strong>简化代码逻辑</strong>：代理对象可以隐藏一些复杂的操作，使得客户端代码更加简洁清晰。</li></ul><h1>静态代理</h1><p>在编译时就确定代理类和被代理类的关系，代理类直接持有被代理类的引用，并且代理类和被代理类都实现了相同的接口或继承自相同的父类，相当于是多写了一个代理类，在调用的时候调用的是代理类，在代理类中的处理还是原生的处理逻辑，不过在前后添加上需要添加的代码。 这样做的缺点就是每个被代理类都需要一个接口和对应的代理类。<br>实现方式（被代理类已经写好了自己的逻辑）：</p><ol><li>定义接口，其中定义被代理类需要被代理的方法，代理类和被代理类同时实现该接口。</li><li>代理类实现接口对应的方法，在其中实现额外的逻辑并且调用被代理的原生方法。</li><li>需要使用代理方法时，直接使用代理类中的方法</li></ol><h1>动态代理</h1><p>在运行时动态地创建代理对象，代理对象通过实现一组接口或者继承一个父类，动态地处理被代理对象的方法调用，并且可以在方法调用前后添加额外的逻辑。</p><h2 id="JDK动态代理">JDK动态代理</h2><p>静态代理中需要手动实现代理类之后进行编译，并且每个被代理类都需要不同的代理类，这是非常麻烦的，Java标准库提供了动态代理功能，<strong>允许在运行期动态创建一个接口的实例</strong>； 动态代理是通过 <strong>Proxy</strong> 创建代理对象，然后将接口方法“代理”给 <strong>InvocationHandler</strong> 完成的。但是，该方法<strong>只能代理实现了接口的类</strong>。</p><h3 id="Proxy">Proxy</h3><p>该类提供了一个静态方法 <code>newProxyInstance</code>，用于创建代理对象。该方法接受三个参数：ClassLoader、一组接口(被代理类实现的接口)和一个 InvocationHandler 对象，然后在运行时动态生成代理类并返回代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,   </span></span><br><span class="line"><span class="params">                                       Class&lt;?&gt;[] interfaces,  </span></span><br><span class="line"><span class="params">                                       InvocationHandler h)</span>    </span><br><span class="line">                                <span class="keyword">throws</span> IllegalArgumentException&#123;...&#125;  </span><br></pre></td></tr></table></figure><h3 id="InvocationHandler">InvocationHandler</h3><p>该接口定义了一个方法 <code>invoke</code>，用于处理被代理对象的方法调用。在实现该接口时，需要编写处理方法调用的逻辑。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法的返回值就是代理对象</span></span><br><span class="line"><span class="keyword">public</span> Object invoke(Object proxy, <span class="keyword">Method</span> <span class="title function_">method</span>, <span class="title function_">Object</span>[] <span class="title function_">args</span>) </span><br><span class="line">    <span class="title function_">throws</span> <span class="title function_">Throwable</span> <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    //附加逻辑和原有方法调用逻辑</span></span><br><span class="line"><span class="comment">    ...</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br></pre></td></tr></table></figure><h3 id="实现方式：">实现方式：</h3><ol><li>需要被代理类实现接口，该接口中定义被代理类需要被代理的方法，这点和静态代理相似</li><li>实现InvocationHandler和invoke方法（自定义类或使用匿名内部类），并在invoke方法中编写代理逻辑和调用逻辑</li><li>使用Proxy.newProxyInstance方法创建代理对象，通过调用该代理对象的对应方法即可完成被代理类的方法代理（该代理对象与原代理对象实现了相同接口，是一种多态，是原对象的增强版，因此通过使用该代理对象的相应方法可以完成对被代理类的增强）。</li></ol><h2 id="CGLib动态代理">CGLib动态代理</h2><p>CGLib（Code Generation Library）是一个基于字节码生成库，它允许在运行时动态地生成代理类。与 JDK 动态代理不同，CGLib 动态代理<strong>可以代理没有实现接口的类</strong>。因此CGLib 动态代理相比于 JDK 动态代理更加灵活，它可以代理没有实现接口的类，并且不需要编写额外的接口。然而，<strong>CGLib 动态代理性能相对较差</strong>，因为它是通过生成子类来实现代理的，而不是像 JDK 动态代理那样直接使用接口。CGLib 动态代理通常涉及以下两个重要的类：</p><ol><li><strong>Enhancer 类</strong>：是 CGLib 的核心类之一，用于生成代理类的实例。Enhancer 类提供了一系列方法，用于配置和生成代理类。</li><li><strong>MethodInterceptor 接口</strong>：类似于 JDK 的 InvocationHandler 接口，MethodInterceptor 定义了一个方法 <code>intercept</code>，用于处理被代理对象的方法调用。</li></ol><h3 id="使用示例">使用示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被代理类，无需实现接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RealSubject: Handling request.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 MethodInterceptor 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method invocation.&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args); <span class="comment">// 调用被代理对象的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After method invocation.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Enhancer 对象</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置被代理类的类加载器和接口</span></span><br><span class="line">        enhancer.setSuperclass(RealSubject.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 MethodInterceptor 对象</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MyMethodInterceptor</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        <span class="type">RealSubject</span> <span class="variable">proxy</span> <span class="operator">=</span> (RealSubject) enhancer.create();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用代理对象的方法</span></span><br><span class="line">        proxy.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现原理">实现原理</h3><p>CGLib 的实现原理主要基于字节码生成和类加载技术。</p><ol><li><strong>字节码生成</strong>：<ul><li>CGLib 使用 ASM（一个基于 Java 字节码操作的框架）来生成字节码。</li><li>在代理类中，CGLib会动态生成一个新的类，该类继承自被代理类，因此被代理类不需要实现任何接口。</li><li>CGLib会在代理类中重写被代理类的方法，并在方法内部调用 MethodInterceptor 中定义的逻辑。</li></ul></li><li><strong>类加载</strong>：<ul><li>CGLib 通过创建字节码生成器来动态生成代理类的字节码，并将其转换为 Class 对象。</li><li>CGLib 使用默认的类加载器来加载生成的代理类。</li></ul></li><li><strong>代理对象创建</strong>：<ul><li>在代理对象创建过程中，CGLib 会生成一个新的代理类实例。</li><li>当客户端调用代理对象的方法时，CGLib 会调用代理类中重写的方法，并在其中执行 MethodInterceptor 中定义的逻辑。</li></ul></li><li><strong>MethodInterceptor 接口</strong>：<ul><li>MethodInterceptor 接口定义了一个方法 <code>intercept</code>，用于处理被代理对象的方法调用。</li><li>实现 MethodInterceptor 接口的类可以通过 <code>intercept</code> 方法来实现对被代理对象方法的拦截和处理。</li></ul></li></ol><h1>Spring AOP与动态代理</h1><ol><li>在 Spring AOP 中，使用了动态代理来实现切面对被代理对象的方法调用的拦截和处理。</li><li>当目标对象实现了接口时，Spring AOP 使用 JDK 动态代理来创建代理对象。</li><li>当目标对象没有实现接口时，Spring AOP 使用 CGLib 动态代理来创建代理对象。</li><li>Spring AOP 将切面的通知逻辑织入到目标对象的方法调用中，从而实现对横切关注点的统一管理和处理。</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis为什么高性能</title>
      <link href="/posts/561bfca6.html"/>
      <url>/posts/561bfca6.html</url>
      
        <content type="html"><![CDATA[<h1>原因总结</h1><p>redis作为数据库能拥有如此高的性能具有多方面的原因，本文来探讨其中重要的一部分</p><ol><li><strong>网络I/O：</strong><ul><li><strong>非阻塞I/O模型：</strong> Redis使用非阻塞I/O模型，采用事件驱动的方式进行网络通信。这意味着在一个线程内，可以同时处理多个客户端请求而无需为每个连接创建一个新线程。这提高了并发处理能力。</li><li><strong>高效的协议：</strong> Redis使用轻量级的文本协议，如RESP（REdis Serialization Protocol），它简单而高效，减少了网络传输的开销。</li></ul></li><li><strong>磁盘I/O：</strong><ul><li><strong>内存数据库：</strong> Redis主要将数据存储在内存中，减少了对磁盘的频繁读写操作。这使得对数据的访问速度非常快，适用于高速读写的场景。</li><li><strong>持久化机制：</strong> 尽管主要是内存数据库，但Redis提供了多种持久化机制，如RDB快照和AOF日志文件。这些机制可以根据需求进行配置，以实现数据持久化，同时尽量减小对性能的影响。</li></ul></li><li><strong>计算速度：</strong><ul><li><strong>单线程模型：</strong> Redis采用单线程模型，通过使用高效的数据结构和算法，提高了在单个线程上的计算速度。这对于简单的操作和高并发场景是非常有效的。</li></ul></li><li><strong>数据结构：</strong><ul><li><strong>优化的数据结构：</strong> Redis提供了丰富的数据结构，如字符串、哈希表、有序集合等。这些数据结构在实现上经过了优化，使得它们在各自的应用场景下能够高效地执行相关操作。</li><li><strong>内部编码：</strong> Redis对不同类型的值采用了不同的内部编码方式，例如压缩列表、哈希表、跳跃表等，以提高存储效率。</li></ul></li><li><strong>多路复用：</strong><ul><li><strong>事件驱动和多路复用：</strong> Redis使用事件驱动的模型，通过多路复用技术（如<code>epoll</code>、<code>kqueue</code>等）来处理多个客户端连接。这允许Redis在单个线程上同时监听多个套接字，提高了并发连接的处理能力。</li></ul></li><li><strong>Pipeline 操作：</strong><ul><li><strong>批量操作：</strong> Redis支持Pipeline操作，可以将多个命令打包一次性发送到服务器执行，减少了往返时间。这对于需要执行大量命令的场景，如批量读取或写入，能够显著提高性能。</li></ul></li><li><strong>分布式架构：</strong><ul><li><strong>分布式部署：</strong> Redis支持分布式部署，可以通过分片或集群的方式水平扩展。这意味着可以在多个节点上分布负载，提高整体性能。</li></ul></li><li><strong>内存管理和优化：</strong><ul><li><strong>内存碎片整理：</strong> Redis通过使用内存池和优秀的内存管理算法，减少了内存碎片的产生，提高了内存利用率。</li></ul></li></ol><h1>补充</h1><h2 id="关于多路复用">关于多路复用</h2><p>io多路复用是五种io模型（阻塞IO、非阻塞IO、IO多路复用、信号驱动IO、异步IO）之一</p><h3 id="I-O模型">I/O模型</h3><ol><li>阻塞 I/O 模型（Blocking I/O）:<ul><li>当一个应用程序发起 I/O 操作时，它会被阻塞，直到操作完成。在此期间，应用程序无法执行其他任务。</li><li>适用于简单的同步操作，对于每个操作都等待其完成。</li></ul></li><li>非阻塞 I/O 模型（Non-blocking I/O）:<ul><li>应用程序发起 I/O 操作后，可以继续执行其他任务而不被阻塞。需要通过轮询或者回调等方式来检查操作是否完成。</li><li>适用于需要同时处理多个任务的场景，可以通过轮询或事件通知来实现。</li></ul></li><li>多路复用 I/O 模型（Multiplexing I/O）:<ul><li>通过一种机制（如<code>select</code>、<code>poll</code>、<code>epoll</code>、<code>kqueue</code>等）同时监听多个 I/O 通道，当任意通道就绪时进行处理。</li><li>适用于需要同时处理多个连接的场景，提高了系统的并发性。</li></ul></li><li>信号驱动 I/O 模型（Signal-driven I/O）:<ul><li>应用程序发起 I/O 操作后，通过信号通知操作的完成。应用程序可以继续执行其他任务。</li><li>适用于需要异步通知的场景，但相对较少使用。</li></ul></li><li>异步 I/O 模型（Asynchronous I/O）:<ul><li>应用程序发起 I/O 操作后，可以继续执行其他任务。当操作完成时，应用程序通过回调或其他方式得到通知。</li><li>适用于需要异步处理的场景，能够提高并发和系统的响应性。</li></ul></li></ol><p>下面重点阐述I/O多路复用模型：<br>非阻塞IO解决了一部分问题，即应用程序发起 I/O 操作后，可以继续执行其他任务而不被阻塞，但是，仍需要进行轮询或者回调等方式来检查操作是否完成。那么有没有可能，当操作完成时再通知应用程序来避免“无用功”呢？</p><ol><li><strong>文件描述符</strong>，简称FD，是一个从0 开始的无符号整数，用来关联Linux中的一个文件。在Linux中，一切皆文件，例如常规文件、视频、硬件设备等，当然也包括网络套接字（Socket）。</li><li>当用户去读取数据的时候，<strong>不再去直接调用recvfrom</strong>（在网络编程中用于接收数据的系统调用）了，<strong>而是调用select函数</strong>，select函数会将需要监听的数据交给内核，由内核去检查这些数据是否就绪了，如果说这个数据就绪了，就会通知应用程序数据就绪，然后来读取数据，再从内核中把数据拷贝给用户态，完成数据处理，如果N多个FD一个都没处理完，此时就进行等待。</li><li>监听FD的方式、通知的方式又有多种实现，常见的有：select、poll、epoll</li></ol><ul><li>select和pool相当于是当被监听的数据准备好之后，会把监听的FD整个数据都发送给调用者，需要通过遍历的方式到整个FD中去找哪些是处理好了的文件，所以性能也并不是那么好</li><li>epoll则相当于内核准备好了之后，会把准备好的数据，直接发给调用者</li></ul><h2 id="关于事件驱动">关于事件驱动</h2><p>Redis采用单线程的事件驱动模型，而多路复用则是这种模型的一部分，它的核心是通过监听多个套接字（sockets）上的事件，从而在单个线程内同时处理多个客户端的请求。</p><h3 id="主要组成部分">主要组成部分</h3><ol><li><strong>事件处理器（Event Loop）:</strong><ul><li>Redis的事件处理器负责监听和分发事件。它通过调用操作系统提供的多路复用函数（如<code>select</code>、<code>poll</code>、<code>epoll</code>、<code>kqueue</code>等）来检测套接字上的事件。</li></ul></li><li><strong>文件事件（File Events）:</strong><ul><li>文件事件用于处理套接字上的各种事件，例如可读事件、可写事件、连接事件等。在 Redis 中，<strong>客户端的命令请求和服务器的响应都是通过文件事件来传递的</strong>。</li></ul></li></ol><h3 id="工作流程（事件循环）">工作流程（事件循环）</h3><ol><li><strong>监听事件：</strong><ul><li>事件处理器监听套接字上的事件，包括连接事件、读事件、写事件等。</li></ul></li><li><strong>等待事件：</strong><ul><li>事件处理器等待发生事件的通知。这可以通过阻塞调用多路复用函数，或者使用非阻塞I/O模型中的回调函数来实现。</li></ul></li><li><strong>事件分发：</strong><ul><li>当套接字上发生事件时，事件处理器将事件分发给相应的事件处理函数。例如，可读事件将触发处理命令请求的函数，可写事件将触发发送响应的函数。</li></ul></li><li><strong>执行事件处理函数：</strong><ul><li>事件处理函数执行相应的逻辑，例如处理命令请求、发送响应等。由于采用了非阻塞I/O，一个事件处理函数在执行时不会阻塞其他事件的处理。</li></ul></li><li><strong>重复：</strong><ul><li>事件处理器不断重复上述过程，监听、等待、分发、执行，以处理多个套接字上的事件。</li></ul></li></ol><h3 id="优点">优点</h3><ul><li><strong>高并发：</strong> 多路复用使得 Redis 能够在单线程内同时处理大量的客户端连接，提高了并发处理能力。</li><li><strong>低延迟：</strong> 通过非阻塞I/O和事件驱动模型，Redis可以实现低延迟的请求处理。</li><li><strong>资源效率：</strong> 单线程的事件处理模型减少了线程切换的开销，提高了资源利用率。</li></ul><h2 id="pipeline（Redis管道）">pipeline（Redis管道）</h2><p>Redis的管道（Pipeline）机制是一种优化技术，用于在客户端与服务器之间批量执行多个命令。通过管道机制，可以减少往返时间，提高性能，尤其是在需要执行大量命令时。</p><p>基本原理如下：</p><ol><li><strong>批量发送命令：</strong> 客户端可以将多个命令一次性发送给服务器，而不是分开发送。</li><li><strong>一次性获取回复：</strong> 服务器接收到命令后，不会立即执行，而是将命令缓存起来。然后一次性执行所有命令，并将结果按照命令发送的顺序一次性返回给客户端。</li></ol><p>使用管道机制的好处有：</p><ul><li><strong>减少网络往返时间：</strong> 因为所有命令都在一次通信中完成，而不是多次单独通信。</li><li><strong>提高吞吐量：</strong> 在需要执行大量命令时，通过批量操作可以显著提高性能。<br>创建管道—&gt;向管道中添加命令—&gt;执行命令并获取结果executePipelined</li></ul><h1>总结</h1><p>redis高性能的原因：</p><ol><li>基于内存，计算速度快，减少了对磁盘的频繁读写操作，高速读写</li><li>C语言编写，优化的数据结构</li><li>非阻塞IO模型（多路复用），高效简单的协议</li><li>支持分布式架构扩展，搭建高可用集群</li></ol>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础</title>
      <link href="/posts/fe29e710.html"/>
      <url>/posts/fe29e710.html</url>
      
        <content type="html"><![CDATA[<p>Redis（Remote Dictionary Server），即远程字典服务 !<br>是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API；redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步</p><h1>NoSQL</h1><img src="/post-img/Pasted image 20230922151933.png" alt="图片损坏" style="zoom:100%;" /><h1>redis特征</h1><p>键值（ key-value）型,value支持多种不同数据结构，功能丰富<br>单线程，<strong>每个命令具备原子性</strong>，在网络请求处理方面可以实现多线程<br>低延迟，速度快（<strong>基于内存</strong>、IO多路复用、良好的编码）<br>支持数据持久化<br>支持主从集群、分片集群<br>支持多语言客户端</p><h1>redis通用命令</h1><h2 id="help【command】">help【command】</h2><p>查看一个命令的具体用法</p><h2 id="KEYS-pattern">KEYS pattern</h2><p>查看符合模板的所有key<br>其中模板指的是redis自身的一些定义，相当于模糊匹配<br><img src="/post-img/Pasted image 20230922160409.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="DEL">DEL</h2><p>删除一个指定的key</p><h2 id="EXISTS">EXISTS</h2><p>判断key是否存在</p><h2 id="EXPIRE">EXPIRE</h2><p>给一个key设置有效期，有效期到期时该key会被自动删除</p><h2 id="TTL">TTL</h2><p>查看一个key的剩余有效期</p><h1>key的层级格式</h1><p>Redis没有类似MySQL中的Table的概念，s使用key的分层级形式来区分不同类型的key<br><img src="/post-img/Pasted image 20230922160953.png" alt="图片损坏" style="zoom:100%;" /></p><h1>redis的数据结构</h1><p>redis是键值对型数据库，其键一般是字符串，而值的类型多种多样，以下是一些常见的值的类型的介绍</p><h2 id="string">string</h2><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。<br>其value是字符串，不过根据字符串的格式不同，又可以分为3类:<br>string:普通字符串<br>int:整数类型，可以做自增、自减操作<br>float:浮点类型，可以做自增、自减操作<br>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m.<br><img src="/post-img/Pasted image 20230922160736.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="hash">hash</h2><img src="/post-img/Pasted image 20230922161203.png" alt="图片损坏" style="zoom:100%;" /><img src="/post-img/Pasted image 20230922161224.png" alt="图片损坏" style="zoom:100%;" /><h2 id="list">list</h2><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。<br>既可以支持正向检索和也可以支持反向检索。<br>特征也与LinkedList类似：<br>有序；元素可以重复；插入和删除快；查询速度一般<br><img src="/post-img/Pasted image 20230922161424.png" alt="图片损坏" style="zoom:100%;" /><br>可以用list来模拟栈，队列，阻塞队列等数据结构<br>入口和出口在同一边----&gt;栈<br>入口和出口在不同边----&gt;队列<br>入口和出口在不同边，出队时采用BLPOP或BRPOP----&gt;阻塞队列</p><h2 id="set">set</h2><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。<br>因为也是一个hash表，因此具备与HashSet类似的特征：<br>无序；元素不可重复；查找快；支持交集、并集、差集等功能<br><img src="/post-img/Pasted image 20230922161828.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="sortedset">sortedset</h2><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。<br>SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个<br>跳表（SkipList）加 hash表。<br>SortedSet具备下列特性:<br>可排序；元素不重复；查询速度快<br>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。<br><img src="/post-img/Pasted image 20230922164154.png" alt="图片损坏" style="zoom:100%;" /></p><h1>redis的java客户端</h1><p>jedis：以Redis命令作为方法名称。学习成本低,简单实用。但是Jedis实例是线程不安全的,多线程环境卞需要基于连接池来使用<br>lettuce：是基于Netty实现的,支持同步、异步和响应式编程方式，并且是线程家全的。支持Redis的哨兵模式、集群模式和管道模式。</p><h2 id="jedis快速入门">jedis快速入门</h2><p>官网：[<a href="https://github.com/redis/jedis">https://github.com/redis/jedis</a>]<br>1.引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">grouprd</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">grouprd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.建立连接<br><img src="/post-img/Pasted image 20230922164616.png" alt="图片损坏" style="zoom:100%;" /><br>3.测试string<br><img src="/post-img/Pasted image 20230922164635.png" alt="图片损坏" style="zoom:100%;" /><br>4.释放资源<br><img src="/post-img/Pasted image 20230922164647.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="jedis连接池">jedis连接池</h2><p>jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗<br>因此使用jedis连接池代替jedis的直连方式<br><img src="/post-img/Pasted image 20230922164951.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="SpringDataRedis">SpringDataRedis</h2><p>springdata是spring中数据操作的模块，包含对各种数据的集成，其中对redis的集成模块就是SpringDataRedis，官网:[https:/lsprina.io/proiects/spring-data-redis]<br>它提供了如下功能和便利：<br>1.提供了对不同Redis客户端的整合（Lettuce和Jedis）<br>2.提供了RedisTemplate统一API来操作Redis<br>3.支持Redis的发布订阅模型<br>4.支持Redis哨兵和Redis集群<br>5.支持基于Lettuce的响应式编程<br>6.支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化<br>7.支持基于Redis的JDKCollection实现</p><h3 id="快速入门">快速入门</h3><p>1.引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Redis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupid</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--连接池依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupid</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupid</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">redis:</span></span><br><span class="line"><span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line"><span class="attr">password:</span> <span class="number">123321</span></span><br><span class="line"><span class="attr">lettuce:</span></span><br><span class="line"><span class="attr">pool:</span></span><br><span class="line"><span class="attr">max-active:</span> <span class="number">8</span><span class="comment">#最大连接</span></span><br><span class="line"><span class="attr">max-idle:</span> <span class="number">8</span><span class="comment">#晟大空闲连接</span></span><br><span class="line"><span class="attr">min-idle:</span> <span class="number">0</span><span class="comment">#最小空闲连接</span></span><br><span class="line"><span class="attr">max-wait:</span> <span class="number">100</span> <span class="comment">#连接等待时间</span></span><br></pre></td></tr></table></figure><p>3.注入RedisTemplate</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate</span><br></pre></td></tr></table></figure><p>4.编写测试<br><img src="/post-img/Pasted image 20230922165941.png" alt="图片损坏" style="zoom:100%;" /><br>如果要操作其它数据类型，可以参照下表以及redis中各数据类型的命令（jedis中的方法名与命令名相同），用下表的对应类调用对应方法<br><img src="/post-img/Pasted image 20230922165439.png" alt="图片损坏" style="zoom:100%;" /></p><h3 id="序列化方式">序列化方式</h3><p>RedisTemplate可以接受任意Object作为值写入redis，但是写入前会把Object序列化为字节形式，默认是采用JDK序列化，这样做使得值的可读性差，并且内存占用较大，为了解决这个问题，有两种方式<br><strong>自定义RedisTemplate的序列化方式</strong><br><img src="/post-img/Pasted image 20230922170235.png" alt="图片损坏" style="zoom:100%;" /></p><p>以上是采用jackson序列化的示例，注意需要引入jackson依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>尽管它能改善可读性差的问题，但是为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。<br><strong>使用Spring提供的一个StringRedisTemplate类</strong><br>为了节省内存空间，我们并不会使用JSON序列化器来处理value，而是统一使用String序列化器，它要求只能存储String类型的key和value。当需要存储Java对象时，我们需要<strong>手动完成</strong>对象的序列化和反序列化。<br>StringRedisTemplate的key和value的序列化方式默认就是String方式。省去了我们自定义RedisTemplate的过程<br><img src="/post-img/Pasted image 20230922170840.png" alt="图片损坏" style="zoom:100%;" /><br><img src="/post-img/Pasted image 20230922171119.png" alt="图片损坏" style="zoom:100%;" /></p><h1>事务和乐观锁</h1><h2 id="事务">事务</h2><p>1.原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的操作要么都做，要么都不做。<br>2.一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。<br>3.隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。<br>4.持久性（durability）。持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。<br>在Redis事务没有隔离级别的概念！<br>在Redis单条命令是保证原子性的，但是事务不保证原子性！</p><h2 id="乐观锁">乐观锁</h2><p>1.当程序中可能出现并发的情况时，就需要保证在并发情况下数据的准确性，以此确保当前用户和其他用户一起操作时，所得到的结果和他单独操作时的结果是一样的。<br>2.没有做好并发控制，就可能导致脏读、幻读和不可重复读等问题。<br>在Redis是可以实现乐观锁的！</p><h2 id="事务的实现">事务的实现</h2><p>一、Redis如何实现事务？<br>1.正常执行事务<br><img src="/post-img/Pasted image 20230930154014.png" alt="图片损坏" style="zoom:100%;" /><br>2.放弃事务<br><img src="/post-img/Pasted image 20230930154026.png" alt="图片损坏" style="zoom:100%;" /><br>3.编译时异常，代码有问题，或者命令有问题，所有的命令都不会被执行<br><img src="/post-img/Pasted image 20230930154041.png" alt="图片损坏" style="zoom:100%;" /><br>4.运行时异常，除了语法错误不会被执行且抛出异常后，其他的正确命令可以正常执行<br><img src="/post-img/Pasted image 20230930154059.png" alt="图片损坏" style="zoom:100%;" /><br>5.总结：由以上可以得出结论，Redis是支持单条命令事务的，但是事务并不能保证原子性！</p><h2 id="乐观锁的实现">乐观锁的实现</h2><p>1.watch（监视）<br><img src="/post-img/Pasted image 20230930154234.png" alt="图片损坏" style="zoom:100%;" /><br>2.多线程测试watch<br><img src="/post-img/Pasted image 20230930154302.png" alt="图片损坏" style="zoom:100%;" /><br><img src="/post-img/Pasted image 20230930154313.png" alt="图片损坏" style="zoom:100%;" /><br>3.总结：乐观锁和悲观锁的区别：<br>悲观锁： 什么时候都会出问题，所以一直监视着，没有执行当前步骤完成前，不让任何线程执行，十分浪费性能！一般不使用！<br>乐观锁： 只有更新数据的时候去判断一下，在此期间是否有人修改过被监视的这个数据，没有的话正常执行事务，反之执行失败！</p><h1>持久化</h1><p>Redis 是<strong>内存数据库</strong>，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 Redis 提供了<strong>持久化功能</strong> !</p><h2 id="RDB（Redis-DataBase）">RDB（Redis DataBase）</h2><p>RDB持久化是Redis的一种快照持久化方式，它可以将内存中的数据周期性地保存到磁盘上的一个二进制文件中。这个文件包含了某个时间点上的所有数据，以及服务器的状态信息。RDB持久化的主要特点和步骤如下：</p><ol><li><strong>快照生成</strong>：Redis会定期生成一个快照文件，保存当前数据和服务器状态。你可以通过配置Redis的<code>save</code>指令来指定生成快照的条件，比如多少秒内至少有多少个写操作。</li><li><strong>生成快照文件</strong>：生成快照文件时，Redis会 fork 一个子进程来执行实际的快照生成操作，而父进程则继续响应客户端请求。这样可以确保持久化操作不会阻塞Redis的正常服务。</li><li><strong>保存到磁盘</strong>：生成的快照文件会被保存到磁盘上的一个文件中。</li><li><strong>加载快照</strong>：当Redis服务器启动时，它会检查是否存在RDB快照文件，如果存在，就会加载该文件并将数据还原到内存中。</li></ol><p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。<br>这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。我们默认的就是RDB，一般情况下不需要修改这个配置！在生产环境我们会将这个文件进行备份！</p><h3 id="快照生成机制（生成dump-rdb文件）">快照生成机制（生成dump.rdb文件）</h3><p>1.在redis的配置文件中修改对应区域可以指定快照生成的条件，满足条件生成快照<br><img src="/post-img/Pasted image 20230930155617.png" alt="图片损坏" style="zoom:100%;" /><br><img src="/post-img/Pasted image 20230930155652.png" alt="图片损坏" style="zoom:100%;" /><br>2.执行flushall命令，也会触发rdb规则<br>3.退出Redis，也会触发rdb规则<br>4.手动执行save命令生成快照文件</p><h3 id="恢复快照文件">恢复快照文件</h3><p>一般redis每次重启时会自动加载快照文件，实现持久化<br>1、只需将备份的rdb文件放在我们的redis启动目录即可，Redis启动的时候会自动检查dump.rdb文件并恢复其中的数据！<br>2、查找文件位置的命令：</p><h3 id="优缺点">优缺点</h3><p>优点：<br>1、适合大规模的数据恢复！<br>2、对数据的完整性要求不高！<br>3、性能高：生成快照时使用了子进程，不会影响正常的读写操作<br>4、生成的快照文件紧凑，适用于备份和恢复<br>缺点：<br>1、需要一定的时间间隔进程操作！如果redis意外宕机了，这个最后一次修改数据就没有的了！<br>2、fork进程的时候，会占用一定的内容空间！<br>3、不适用于实时数据备份：生成快照的频率较低，不适用于要求实时数据备份的场景。</p><h2 id="AOF（Append-Only-File）">AOF（Append Only File）</h2><p>Redis默认使用的是RDB模式，所以需要手动开启AOF模式，在配置文件中将下图中的no改为yes<br><img src="/post-img/Pasted image 20230930160809.png" alt="图片损坏" style="zoom:100%;" /><br>开启AOF模式后，redis会自动保存从这次启动redis服务器以来操作的命令，并记录到appendonly.aof文件中，从Redis 2.0版本开始，AOF持久化就已经是默认启用的持久化方式。</p><h3 id="appendonly-aof错误修复">appendonly.aof错误修复</h3><p>由于appendonly.aof文件是可读写的，因此有可能产生错误或遭到破坏，可以通过以下方法修复</p><ol><li><strong>备份原始AOF文件</strong>：首先，确保在尝试恢复之前备份原始的<code>appendonly.aof</code>文件。这可以帮助你在恢复过程中避免进一步的数据损坏。</li><li><strong>检查文件完整性</strong>：使用文本编辑器打开<code>appendonly.aof</code>文件，并检查文件是否完整和有效。有时，AOF文件可能会因某种原因损坏，导致无法正常解析其中的命令。如果文件完全无法打开或损坏严重，可能需要查看备份或考虑其他数据恢复方式。</li><li><strong>手动编辑文件</strong>：如果文件中只有一小部分数据受损，可以尝试手动编辑文件，修复损坏的部分。这可能需要一些Redis命令和AOF文件格式的了解。务必小心操作，以免进一步破坏文件。</li><li><strong>使用Redis-check-aof工具</strong>：Redis提供了一个名为<code>redis-check-aof</code>的工具，可以用于检查AOF文件的有效性并尝试修复其中的问题。可以通过以下命令来使用它：<code>redis-check-aof --fix &lt;AOF文件路径&gt;</code><br>该命令将尝试修复AOF文件中的问题，并在修复完成后生成一个修复后的文件（通常带有<code>.fixed</code>扩展名）。可以将修复后的文件重命名为<code>appendonly.aof</code>并替换原始文件。<br>注意虽然错误的内容少了，但是正确的也有一定的丢失！所以这个修复无法做到百分百修复！</li><li><strong>重新加载AOF文件</strong>：如果成功修复了AOF文件或者恢复了损坏的部分，可以重新启动Redis服务器以加载AOF文件中的命令并还原数据。</li></ol><h3 id="设置appendonly-aof文件大小">设置appendonly.aof文件大小</h3><p>aof默认的就是文件的无限追加，文件会越来越大！在配置文件中可以设置文件的大小！<br><img src="/post-img/Pasted image 20230930161737.png" alt="图片损坏" style="zoom:100%;" /></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>-aof-rewrite-percentage <span class="number">100</span> #写入百分比 </span><br><span class="line"><span class="keyword">auto</span>-aof-rewrite-min-size <span class="number">64</span>mb #写入的文件最大值是多少，一般在实际工作中我们会将其设置为<span class="number">5</span>gb左右！</span><br></pre></td></tr></table></figure><h3 id="优缺点-2">优缺点</h3><p>优点：</p><ol><li><strong>可读性和透明性</strong>：AOF文件是一个可读性的文本文件，它记录了每个写操作的命令。这使得AOF文件易于查看和理解，有助于调试和分析。</li><li><strong>实时备份</strong>：AOF模式以追加的方式记录每个写操作，这意味着数据变化会立即被记录到AOF文件中。这使得AOF模式适用于实时数据备份需求。每一次修改都同步，文件的完整性会更加好</li><li><strong>可靠性</strong>：AOF文件采用了追加写入方式，相对于RDB持久化，更不容易损坏。即使在写入过程中发生意外宕机，已经写入的数据不会丢失。每秒同步一次，最多会丢失一秒的数据</li><li><strong>重写机制</strong>：Redis提供了AOF文件的重写机制，允许定期对AOF文件进行重新压缩和优化。这可以控制AOF文件的大小，避免无限增长。</li><li><strong>数据恢复</strong>：AOF文件记录了写操作的历史，因此可以用于恢复数据。在Redis服务器启动时，AOF文件中的命令将会重新执行，还原数据。<br>缺点：</li><li><strong>文件大小</strong>：AOF文件通常会随着时间的推移逐渐增大，特别是在高写入负载下。较大的AOF文件可能占用大量磁盘空间，因此需要定期进行AOF文件的重写和优化。</li><li><strong>写入性能</strong>：相对于RDB持久化，AOF持久化在高写入负载下可能会稍微降低性能，因为每个写操作都要追加到AOF文件中。</li><li><strong>文件恢复时间</strong>：如果AOF文件过大，Redis服务器在启动时加载AOF文件的时间可能会较长，因为需要重新执行大量写操作。</li><li><strong>数据丢失风险</strong>：虽然AOF文件相对可靠，但在某些极端情况下，可能会出现数据丢失。例如，如果AOF文件在写入期间发生了损坏，那么写入的数据可能会丢失。</li></ol><h2 id="两种方式对比和总结">两种方式对比和总结</h2><p>1、RDB 持久化方式能够在指定的时间间隔内对数据进行快照存储<br>2、AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。<br>3、只做缓存，如果只希望数据在服务器运行的时候存在，也可以不使用任何持久化<br>4、同时开启两种持久化方式时，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。<br>RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，但建议不要只使用AOF，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。<br>5.一般情况下无脑两种一起用，此外<br><strong>使用AOF持久化的情况</strong>：</p><ol><li><strong>实时备份需求</strong>：如果你需要实时备份数据以确保数据不会丢失，AOF持久化是更好的选择。AOF以追加方式记录每个写操作，确保数据变更会立即记录到AOF文件中。</li><li><strong>可读性和调试需求</strong>：AOF文件是可读性的文本文件，易于查看和理解其中的命令。这对于调试和分析非常有用。</li><li><strong>数据恢复要求</strong>：AOF文件记录了写操作的历史，因此可以用于数据恢复。在Redis服务器启动时，AOF文件中的命令将会重新执行，还原数据。</li><li><strong>数据一致性要求高</strong>：AOF模式相对可靠，即使在写入过程中发生宕机，已经写入的数据不会丢失，因此适用于要求数据一致性高的场景。<br><strong>使用RDB持久化的情况</strong>：</li><li><strong>周期性备份需求</strong>：如果你只需要定期备份数据，而不需要实时备份，RDB持久化是一种有效的选择。RDB生成全量快照，适用于周期性的备份操作。</li><li><strong>磁盘空间有限</strong>：RDB文件通常比较小，适用于磁盘空间有限的情况。如果你的磁盘空间有限，可以考虑使用RDB持久化。</li><li><strong>启动速度要求</strong>：在Redis服务器启动时，加载RDB文件比加载大型AOF文件更快。如果需要快速启动，可以选择RDB持久化。</li><li><strong>性能优化</strong>：在某些高性能场景下，RDB持久化可能会比AOF持久化更适合，因为RDB生成快照的性能开销较小。</li></ol><h2 id="性能建议">性能建议</h2><p>1.因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留 save 900 1 这条规则。<br>2.如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率<br>AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。<br>3.如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。</p><h1>发布订阅</h1><p>Redis发布订阅（pub/sub）是一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接受消息。<br><img src="/post-img/Pasted image 20230930174823.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="实现">实现</h2><p>订阅端<br><img src="/post-img/Pasted image 20230930174926.png" alt="图片损坏" style="zoom:100%;" /><br>发送端<br><img src="/post-img/Pasted image 20230930174936.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="常用命令">常用命令</h2><p><strong>发布消息到指定频道</strong>：<br><strong>PUBLISH</strong>：将消息发布到指定的频道。<br><code>PUBLISH channel message</code><br>- <code>channel</code>：指定要发布消息的频道名称。<br>- <code>message</code>：要发布的消息内容。<br><strong>订阅频道</strong>：</p><ol><li><strong>SUBSCRIBE</strong>：订阅一个或多个频道。<br><code>SUBSCRIBE channel [channel ...]</code><ul><li><code>channel</code>：一个或多个频道名称，可以同时订阅多个频道。</li></ul></li><li><strong>PSUBSCRIBE</strong>：通过正则表达式订阅匹配的频道。<br><code>PSUBSCRIBE pattern [pattern ...]</code><ul><li><code>pattern</code>：一个或多个正则表达式，用于匹配多个频道名称。<br><strong>取消订阅频道</strong>：</li></ul></li><li><strong>UNSUBSCRIBE</strong>：取消订阅一个或多个频道。<br><code>UNSUBSCRIBE [channel [channel ...&quot; alt=&quot;图片损坏&quot; style=&quot;zoom:100%;&quot; /&gt;</code><ul><li><code>channel</code>：要取消订阅的频道名称，如果未提供任何频道名称，则取消所有频道的订阅。</li></ul></li><li><strong>PUNSUBSCRIBE</strong>：通过正则表达式取消订阅匹配的频道。<br><code>PUNSUBSCRIBE [pattern [pattern ...&quot; alt=&quot;图片损坏&quot; style=&quot;zoom:100%;&quot; /&gt;</code><ul><li><code>pattern</code>：要取消订阅的正则表达式，如果未提供任何正则表达式，则取消所有匹配的频道的订阅。<br><strong>查看订阅频道</strong>：</li></ul></li><li><strong>SUBSCRIBE</strong> 和 <strong>PSUBSCRIBE</strong> 命令会返回关于订阅状态的信息。你可以使用以下命令来查看当前订阅的频道和模式：<ul><li><code>PUBSUB CHANNELS</code>：列出当前活动的频道。</li><li><code>PUBSUB NUMSUB channel [channel ...]</code>：获取指定频道的订阅者数量。</li><li><code>PUBSUB NUMPAT</code>：获取匹配的模式数量。</li></ul></li></ol><h1>主从复制</h1><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master/leader)，后者称为从节点(slave/follower)；数据的复制是单向的，只能由主节点到从节点。Master以写为主，Slave 以读为主。<br>主要作用：<br>1.数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。<br>2.故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。<br>3.负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。<br>4.高可用（集群）基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</p><h2 id="环境配置（单机集群）">环境配置（单机集群）</h2><p>1.基本查看命令info replication<br><img src="/post-img/Pasted image 20230930175500.png" alt="图片损坏" style="zoom:100%;" /><br>2.例开启三台服务<br><img src="/post-img/Pasted image 20230930175635.png" alt="图片损坏" style="zoom:100%;" /><br>3.全部启动并查看<br><img src="/post-img/Pasted image 20230930175658.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="单机测试（一主二从）">单机测试（一主二从）</h2><p>1.任命一台服务器为主节点，其它服务器为从节点slaveof  IP port<br><img src="/post-img/Pasted image 20230930175810.png" alt="图片损坏" style="zoom:100%;" /><br>2.从主节点处查看信息info replication<br><img src="/post-img/Pasted image 20230930175847.png" alt="图片损坏" style="zoom:100%;" /><br>3.以上的配置是一次性的，如果断电、宕机等，就要重新任命<br>可以通过修改配置文件来实现永久配置<br><img src="/post-img/Pasted image 20230930180117.png" alt="图片损坏" style="zoom:100%;" /><br>4.测试读写操作<br>主机写，从机可读<br>主机死，从机可读<br>主机复活，从机自动寻找主机（配置文件配置时）<br>从机死，不可重连（命令配置时）<br>从机只能读，不能写</p><h2 id="原理">原理</h2><p>Slave 启动成功连接到 master 后会发送一个sync同步命令<br>Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。</p><p>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。<br>增量复制： Master 继续将新的所有收集到的修改命令依次传给slave，完成同步但是只要是重新连接master，一次完全同步（全量复制）将被自动执行！ 我们的数据一定可以在从机中看到</p><h2 id="从机的从机">从机的从机</h2><p>层层链路<br><img src="/post-img/Pasted image 20230930180522.png" alt="图片损坏" style="zoom:100%;" /><br>从机可以有自己的从机（主从机的概念是相对的）</p><h2 id="主机转移（谋朝篡位）">主机转移（谋朝篡位）</h2><p>使用<code>SLAVEOF no one</code>让自己变成主机！其他的节点就可以手动连接到最新的这个主节点（手动）<br>如果主机复活，重新成为从机</p><h2 id="小结">小结</h2><p>一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的（宕机），原因如下：<br>1、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大；<br>2、从容量上，单个Redis服务器内存容量有限，就算一Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该20G。<br>主从复制，读写分离！ 80% 的情况下都是在进行读操作！减缓服务器的压力！架构中经常使用！ 一主二从！<br>只要在公司中，主从复制就是必须要使用的，因为在真实的项目中不可能单机使用Redis！</p><h1>哨兵模式</h1><p>是对主从复制的补充<br>主机断开后，我们得手动设置另一个从机变成主机！这是不智能的！在实际工作中，我们都是用哨兵模式来自动切换主机。Redis从2.8开始正式提供了Sentinel（哨兵） 架构，后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。<br>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的 <strong>进程</strong> ，作为进程，它会独立运行。其原理是哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</p><h2 id="配置哨兵">配置哨兵</h2><p>1.添加哨兵配置文件sentinel.conf<br>内容如下：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sentinel monitor 被监控的名称 host port 1 （代表自动投票选举大哥！）</span></span><br><span class="line">sentinel<span class="built_in"> monitor </span>myredis 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure><p>2.启动哨兵</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel sentinel配置文件路径   <span class="meta">#和启动Redis一致</span></span><br></pre></td></tr></table></figure><p>3.准备测试环境（一主二从三台服务器）<br>4.测试主机宕机后自动选取大哥，如果主机此时回来了，只能归并到新的主机下，当做从机，这就是哨兵模式的规则！等待哨兵的默认配置时间时是30 秒！</p><h2 id="优缺点-3">优缺点</h2><p>优点<br>1.哨兵集群基于主从复制模式 ，所有的主从配置优点，它全有<br>2.主从可以切换，故障可以转移 ，系统的 可用性 就会更好<br>3.哨兵模式就是主从模式的升级，手动到自动，更加健壮<br>缺点<br>1.Redis 不好在线扩容 的，集群容量一旦到达上限，在线扩容就十分麻烦！<br>2.实现哨兵模式的配置其实是很 麻烦 的，里面有很多选择！<br>注意<br>以上所有的配置因为条件所限都是基于单机集群的前提下！正式集群下的多哨兵模式如下图：<br><img src="/post-img/Pasted image 20230930181510.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="哨兵的配置文件解析">哨兵的配置文件解析</h2><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"># Example sentinel.conf </span><br><span class="line"></span><br><span class="line"># 哨兵sentinel实例运行的端口 默认<span class="number">26379</span> </span><br><span class="line">port <span class="number">26379</span> </span><br><span class="line"></span><br><span class="line"># 哨兵sentinel的工作目录 </span><br><span class="line">dir /tmp </span><br><span class="line"></span><br><span class="line"># 哨兵sentinel监控的redis主节点的 ip port </span><br><span class="line"># master-name 可以自己命名的主节点名字 只能由字母A-z、数字<span class="number">0</span><span class="number">-9</span> 、这三个字符<span class="string">&quot;.-_&quot;</span>组成。 </span><br><span class="line"># quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了 </span><br><span class="line"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt; sentinel monitor mymaster <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span> <span class="number">2</span> </span><br><span class="line"></span><br><span class="line"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供 密码</span><br><span class="line"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码 </span><br><span class="line"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt; </span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret<span class="number">-0123</span>passw0rd </span><br><span class="line"></span><br><span class="line"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认<span class="number">30</span>秒 </span><br><span class="line"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt; </span><br><span class="line">sentinel down-after-milliseconds mymaster <span class="number">30000</span> </span><br><span class="line"></span><br><span class="line"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步</span><br><span class="line">#这个数字越小，完成failover所需的时间就越长，</span><br><span class="line"># 但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。 </span><br><span class="line">#可以通过将这个值设为 <span class="number">1</span> 来保证每次只有一个slave 处于不能处理命令请求的状态。 </span><br><span class="line"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt; </span><br><span class="line">sentinel parallel-syncs mymaster <span class="number">1</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面： </span><br><span class="line">#<span class="number">1.</span> 同一个sentinel对同一个master两次failover之间的间隔时间。 </span><br><span class="line">#<span class="number">2.</span> 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那 里同步数据时。 </span><br><span class="line">#<span class="number">3.</span>当想要取消一个正在进行的failover所需要的时间。 </span><br><span class="line">#<span class="number">4.</span>当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时， slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了 </span><br><span class="line"># 默认三分钟 # sentinel failover-timeout &lt;master-name&gt; </span><br><span class="line">sentinel failover-timeout mymaster <span class="number">180000</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># SCRIPTS EXECUTION #配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知 相关人员。 </span><br><span class="line">#对于脚本的运行结果有以下规则： </span><br><span class="line">#若脚本执行后返回<span class="number">1</span>，那么该脚本稍后将会被再次执行，重复次数目前默认为<span class="number">10</span> #若脚本执行后返回<span class="number">2</span>，或者比<span class="number">2</span>更高的一个返回值，脚本将不会重复执行。 </span><br><span class="line">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为<span class="number">1</span>时的行为相同。 </span><br><span class="line">#一个脚本的最大执行时间为<span class="number">60</span>s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。 </span><br><span class="line">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等）， 将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信 息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配 置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无 法正常启动成功。 </span><br><span class="line">#通知脚本 </span><br><span class="line"># shell编程 </span><br><span class="line"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt; </span><br><span class="line">sentinel notification-script mymaster /var/redis/notify.sh </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 客户端重新配置主节点参数脚本 </span><br><span class="line"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已 经发生改变的信息。 </span><br><span class="line"># 以下参数将会在调用脚本时传给脚本: </span><br><span class="line"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;<span class="keyword">from</span>-ip&gt; &lt;<span class="keyword">from</span>-port&gt; &lt;to-ip&gt; &lt;to-port&gt; </span><br><span class="line"># 目前&lt;state&gt;总是“failover”, </span><br><span class="line"># &lt;role&gt;是“leader”或者“observer”中的一个。 </span><br><span class="line"># 参数 <span class="keyword">from</span>-ip, <span class="keyword">from</span>-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通 信的</span><br><span class="line"># 这个脚本应该是通用的，能被多次调用，不是针对性的。 </span><br><span class="line"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt; </span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh </span><br><span class="line"># 一般都是由运维来配置！</span><br></pre></td></tr></table></figure><h1>缓存穿透</h1><p>用户需要查询一个数据，但是redis中没有（比如说mysql中id=-1的数），直接去请求MySQL，当很多用户同时请求并且都没有命中！于是都去请求了持久层的数据库，那么这样会给持久层数据库带来非常大的压力。一般出现这样的情况都不是正常用户，基本上都是恶意用户！<br><strong>缓存穿透前提是：Redis和MySQL中都没有，然后不停的直接请求MySQL。</strong></p><h2 id="解决方案">解决方案</h2><h3 id="布隆过滤器">布隆过滤器</h3><img src="/post-img/Pasted image 20230930181912.png" alt="图片损坏" style="zoom:100%;" />布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则  丢弃，从而避免了对底层存储系统的查询压力；<h3 id="缓冲空对象">缓冲空对象</h3><img src="/post-img/Pasted image 20230930181949.png" alt="图片损坏" style="zoom:100%;" />当存储层查不到，即使是空值，我们也将其存储起来并且在Redis中设置一个过期时间，之后再访问这个数据将会从Redis中访问，保护了持久层的数据库！但是如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多  的空值的键；  即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。<h1>缓存击穿</h1><p>是指一个非常热点的key，在不停的扛着大并发，当这个key失效时，一瞬间大量的请求冲到持久层的数据库中，就像在一堵墙上某个点凿开了一个洞！</p><h2 id="解决方案-2">解决方案</h2><p>1.设置热点key永不过期<br>从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。这样做其实并不合理<br>2.加互斥锁<br>在查询持久层数据库时，保证了只有一个线程能够进行持久层数据查询，其他的线程让它睡眠几百毫秒，等待第一个线程查询完会回写到Redis缓存当中，剩下的线程可以正常查询Redis缓存，就不存在大量请求去冲击持久层数据库了！<br><img src="/post-img/Pasted image 20230930182240.png" alt="图片损坏" style="zoom:100%;" /></p><h1>缓存雪崩</h1><p>在某一个时间段，缓存的key大量集中同时过期了，所有的请求全部冲到持久层数据库上，导致持久层数据库挂掉！<br>范例：双十一零点抢购，这波商品比较集中的放在缓存，设置了失效时间为1个小时，那么到了零点，这批缓存全部失效了，而大量的请求过来时，全部冲过了缓存，冲到了持久层数据库！</p><h2 id="解决方案-3">解决方案</h2><h3 id="Redis高可用">Redis高可用</h3><p>搭建Redis集群，既然redis有可能挂掉，那么多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。（异地多活！）</p><h3 id="限流降级">限流降级</h3><p>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p><h3 id="数据预热">数据预热</h3><p>数据加热的含义就是在正式部署之前，先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀 。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis数据结构</title>
      <link href="/posts/abcb1f8f.html"/>
      <url>/posts/abcb1f8f.html</url>
      
        <content type="html"><![CDATA[<p>通常所说的redis常用数据类型string，hash，set，list，sortedSet等<br>其底层都是精心优化过的数据结构，这也是redis拥有高性能的重要原因之一<br>概括的说，redis的底层有六种数据结构，分别是<strong>SDS（简单动态字符串），hashtable（哈希表），skiplist（跳表），ziplist（压缩列表），intset（整数集合），linkedlist（双向链表）</strong><br>本文从常用的五种数据类型入手，依次说明其底层数据结构</p><h1>字典（dict）</h1><p>字典是redis用来存储所有数据（K-V类型）的一种统一结构体，其定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">dictType *type;</span><br><span class="line"><span class="type">void</span> *privdata;</span><br><span class="line">dictht ht[<span class="number">2</span>];</span><br><span class="line"><span class="type">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125;dict;</span><br></pre></td></tr></table></figure><ol><li><code>dictType *type;</code>  这是一个指向 <code>dictType</code> 结构体的指针，用于表示字典的类型。<code>dictType</code> 中包含了一系列函数指针，定义了字典的操作方法，例如哈希函数、键比较函数和值释放函数等。通过这个指针，字典可以支持不同类型的键值对。</li><li><code>void *privdata;</code>  这是一个指向私有数据的指针，允许用户为字典提供额外上下文信息。</li><li><code>dictht ht[2];</code>  这是一个<strong>包含两个元素的数组，每个元素都是 <code>dictht</code> 结构体的实例</strong>。<code>dictht</code> 是 Redis 字典的哈希表表示，而数组的两个元素则<strong>用于实现哈希表的 rehash 操作</strong>。在 rehash 过程中，字典会使用两个哈希表，逐步将数据从旧表迁移到新表。</li><li><code>long rehashidx;</code>  这是一个长整型变量，<strong>表示当前 rehash 操作的索引</strong>。如果 <code>rehashidx</code> 的值为 -1，表示没有进行 rehash 操作。否则，它表示正在进行 rehash 操作，指示当前正在迁移旧表的索引位置。</li><li><code>unsigned long iterators;</code>  这是一个无符号长整型变量，表示当前正在运行的迭代器的数量。字典的修改操作可能会受到迭代器的影响，因此需要追踪迭代器的数量，以确保安全的遍历字典。</li></ol><h1>dictht（hashtable）</h1><p>dictht是redis中用来存储实际数据的结构体，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">dictEntry **table;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> sizemask ;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure><ol><li><code>dictEntry **table;</code>  这是一个<strong>指向指针数组的指针</strong>，用于表示哈希表的槽位。每个槽位可以包含一个指向 <code>dictEntry</code> 结构体的指针，或者为 <code>NULL</code>，表示该槽位为空。<code>dictEntry</code> 结构体表示哈希表中的一个键值对。<strong>类比hashMap中的数组+链表</strong></li><li><code>unsigned long size;</code>  这是一个无符号长整型变量，表示哈希表的大小，即槽位的数量。它表示哈希表中<strong>可以存储的最大键值对数目</strong></li><li><code>unsigned long sizemask;</code>  这是一个无符号长整型变量，用于快速计算索引位置的掩码。在哈希表的大小为 2 的幂时，通过 <code>sizemask</code> 可以替代取模运算，提高效率。</li><li><code>unsigned long used;</code>  这是一个无符号长整型变量，表示哈希表中当前已经使用的槽位数量，即<strong>已经存储的键值对数目</strong></li></ol><h1>redisObject</h1><p>上面说到redis用dict来存储所有的K-V数据类型，这就像是java中的Map，键固定为String类型，但值可有五种数据类型啊，C语言中又没有类似Object这样的类，于是有了redisObject，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//对象最后一次被访问的时间</span></span><br><span class="line">    <span class="type">unsigned</span> lru:REDIS_LRU_BITS</span><br><span class="line">    <span class="comment">//引用计数</span></span><br><span class="line">    <span class="type">int</span> refcount</span><br><span class="line">    <span class="comment">//指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    ...</span><br><span class="line">&#125; redisObject;</span><br></pre></td></tr></table></figure><ol><li><code>unsigned type:4;</code>  这是一个 4 位的无符号整数，<strong>表示对象的类型</strong>。</li><li><code>unsigned encoding:4;</code>  这是一个 4 位的无符号整数，表示对象的编码方式。Redis 对于不同类型的对象可以使用不同的编码方式，以优化存储和处理性能。以下是一些编码常量：<img src="/post-img/Pasted image 20240216141600.png" alt="图片损坏" style="zoom:100%;" /></li><li><code>unsigned lru:REDIS_LRU_BITS;</code>  这是一个用于 LRU（Least Recently Used）算法的字段，用于记录对象最后一次被访问的时间。</li><li><code>int refcount;</code>  这是一个整数，表示对象的引用计数。引用计数用于追踪对象被引用的次数，确保在没有引用时可以安全地释放对象的内存。</li><li><code>void *ptr;</code>  这是一个指向底层实现数据结构的指针。根据对象的类型和编码方式，<code>ptr</code> 指向实际存储数据的具体结构。例如，对于字符串对象，<code>ptr</code> 可能指向一个包含字符串数据的结构。</li></ol><p><strong>综上我们知道，redis用dict所指向的hashtable结合redisObject已经可以表示五种数据类型，但其实并不是五种数据类型都是通过dict实现的，redis还维护了其它数据结构来优化性能</strong></p><h1>string</h1><h2 id="SDS">SDS</h2><p>string类型的底层是通过SDS实现的，C语言中的字符串是不可变的，使用起来不方便<br>SDS应运而生，它有三个参数：</p><ol><li>len ：保存的字符串长度。获取字符串的长度就是O(1)</li><li>free：剩余可用存储字符串的长度</li><li>buf： 字符串数组，保存字符串<br>通过上述参数，SDS可以实现动态更改字符串的长度，具体实现如下：</li><li><strong>预分配空间：</strong><ul><li>SDS 在分配空间时，会预先分配一定的额外空间，避免每次追加操作都触发内存重新分配。 这个额外空间的大小由 SDS 结构中的free属性表示。</li><li>SDS 的空间分配策略采用了多种方式，根据当前字符串长度和预分配策略动态调整。当字符串长度小于 1MB 时，每次追加操作会分配两倍于所需空间的额外空间。当字符串长度大于等于 1MB 时，每次追加操作只会额外分配1MB的空间。</li></ul></li><li><strong>惰性空间释放：</strong><ul><li>SDS 采用惰性空间释放的策略，即在删除字符串内容时，并不立即释放相应的内存。保留已分配的内存（增大free的值），以备将来再次追加字符串时直接使用，避免频繁的内存分配和释放。</li></ul></li><li><strong>其它特点</strong>：<ul><li>len参数的存在使得获取字符串的长度是O(1)时间复杂度</li><li>上述两种空间分配策略使得SDS能很好的杜绝缓冲区移除和内存泄漏</li><li>SDS可以包含任何数据，最大可存512M，这也是为什么redis的key不能超过512M</li></ul></li></ol><h2 id="int">int</h2><p>对于简单数字或数字字符串，redis会采用int编码，严格意义上并不算是一种数据结构，也就是上述编码变量中的REDIS_ENCODING_INT</p><h1>list</h1><p>list的底层采用的是压缩列表和双向链表</p><h2 id="压缩列表（ziplist）">压缩列表（ziplist）</h2><p>数据量较少时采用<br>具体当list对象同时满足以下两个条件时，使用ziplist<br> 1. list对象保存的所有字符串元素长度都小于64字节<br> 2. list对象保存的元素数量小于512个<br>结构(从前到后依次是)：<br><strong>zlbytes</strong>： 4byte，记录整个压缩列表占用的内存字节数,在对压缩列表内存重分配或计算zlend位置时使用<br><strong>zltail</strong>：4byte，记录最后一个节点离列表起始地址有多少个字节通过这个偏移量，就可以不用遍历整个列表就知道尾节点的位置了<br><strong>zllen</strong>：2byte，记录列表中的节点数,值小于unit16_max(65535)时是准确值，大于时需要遍历<br><strong>entry1…entryN</strong>：列表节点，不定长<br><strong>zlend</strong>：特殊值，标记列表末端<br>在压缩列表中，元素按顺序存储，但不保留插入的顺序信息。每个元素的长度可以是不定长的，这使得压缩列表可以更灵活地存储不同长度的元素。<br>压缩列表也支持快速的头部和尾部插入和删除操作，在某些操作上可能比双向链表更紧凑，特别是在元素较小的情况下。但一般情况下，ziplist的增删改查需要遍历，为O(N)时间复杂度</p><h2 id="双向链表（linkedlist）">双向链表（linkedlist）</h2><p>使用redis的list数据结构时，存储数据较大时，list对象已经不满足上面描述的ziplist条件，则会使用linkedlist，修改效率高，但占用更多内存（存放指针）</p><h2 id="快速列表（quickList）">快速列表（quickList）</h2><p>Quicklist 是对双向链表的进一步优化，将长列表分成多个节点，每个节点都是一个压缩列表。这样，Quicklist 结合了双向链表和压缩列表的优势，提高了对长列表的操作效率。<br>每个 Quicklist 节点都包含压缩列表指针若干和当前节点中元素（所有指针指向的压缩列表中元素总和）的数量</p><h1>hash</h1><p>hash的底层采用的是ziplist 或hashtable，其中ziplist同上，每个列表节点都变为hash类型</p><h2 id="hashtable（dict字典）">hashtable（dict字典）</h2><p><strong>哈希表是字典的一种实现方式，而字典是键值对存储的通用概念</strong><br>字典是哈希类型的一种底层数据结构，它使用哈希表（数组）来存储键值对。哈希表通过哈希函数计算键的索引，将键值对存储在相应的槽（bucket）中。字典的主要特点包括：</p><ul><li><strong>O(1) 时间复杂度的查找、插入和删除操作</strong>：由于哈希表的设计，它提供了快速的键值对查找、插入和删除操作。</li><li><strong>动态扩展和收缩</strong>：字典会根据实际元素数量动态调整哈希表的大小，以平衡内存占用和性能。</li></ul><h3 id="详细说明">详细说明</h3><ol><li><strong>结构（hash表）:</strong><ul><li>Redis 字典的底层数据结构是哈希表，它是一个数组，每个数组元素称为<strong>桶</strong>（bucket）。这个数组的大小是可动态调整的，根据实际存储的键值对数量动态分配。每个桶中又可以存储一个或多个键值对。哈希表使用哈希函数将键映射到数组的特定位置，即桶的索引。</li></ul></li><li><strong>链地址法解决冲突:</strong><ul><li>在哈希表中，可能会出现多个键经过哈希函数后映射到同一个桶的情况，这被称为哈希冲突。Redis 使用链地址法（Separate Chaining）来解决冲突，即在每个桶中维护一个链表，将映射到同一个桶的键值对串在链表上。</li></ul></li><li><strong>O(1) 操作:</strong><ul><li>查找操作：通过哈希函数计算键的哈希值，定位到对应的桶，然后在链表中查找对应的键值对。由于链表长度相对较短，查找时间是常数级别的，即 O(1)。</li><li>插入操作：同样通过哈希函数计算哈希值，定位到对应的桶，然后在链表中插入新的键值对。由于链表操作是常数时间，插入操作也是 O(1)。</li><li>删除操作：通过哈希函数计算哈希值，定位到对应的桶，然后在链表中删除对应的键值对。链表删除操作也是常数时间，所以删除操作是 O(1)。<br>由于哈希表的设计，使得<strong>查找、插入和删除等操作具有常数级别的时间复杂度</strong>，即 O(1)。然而，需要注意的是，在极端情况下，如果哈希冲突过于频繁，导致链表变得很长，性能可能会下降，但平均情况下哈希表提供了高效的字典操作。</li></ul></li></ol><h3 id="hash表的扩展和收缩">hash表的扩展和收缩</h3><ol><li>当哈希表中元素数量达到一定阈值，为了避免哈希冲突过于频繁，Redis 会触发哈希表的<strong>扩展操作</strong>：新建一个更大的哈希表（通常是当前大小的两倍），然后将旧哈希表中的元素重新分布到新哈希表中。由于哈希表扩展是一个耗时的操作，为了不阻塞其他操作，Redis 使用了<strong>渐进式扩展</strong>的策略。这意味着 rehash 操作不会一次性完成，而是分多次逐步完成。在每个事件循环中，只处理一小部分键值对的 rehash 操作。这样可以分摊 rehash对 CPU 和内存的影响，使得系统在扩展时仍能保持响应。</li><li>当哈希表中的元素数量下降到一定程度，为了节省内存，Redis 可以触发哈希表的<strong>收缩操作</strong>：新建一个更小的哈希表，将旧哈希表中的元素重新分布到新哈希表中。与扩展类似，收缩操作也是一个耗时的操作，为了不阻塞其他操作，可以采用<strong>渐进式收缩</strong>的策略。Redis 使用两个哈希表，旧哈希表和新哈希表。在rehash过程中，会逐步将旧哈希表的元素迁移到新哈希表，同时保持两个表中的元素共存。在每个事件循环中，只迁移一小部分元素，减少对系统性能的影响。</li><li>扩展和收缩用到了dict中定义的两个变量ht[2]和rehashidx，ht[2]保存了两个hashtable，通常情况下，只会用到其中一个，当需要扩容时，另一个hashtable会申请一个较大的空间，每次CRUD操作中，rehashidx都会自增，将指向的元素迁移（如果一直没有指向元素，自增10次就会停止），这就是<strong>渐进式哈希</strong>。</li></ol><h1>set</h1><p>set底层使用的是intset 或hashtable</p><h2 id="intset">intset</h2><ol><li>结构：length（元素数量）记录了 intset中元素的数量。contents（元素数组）实际存储整数，元素按照从小到大的顺序存储。</li><li>特点：<ul><li>intset设计紧凑，对于小型整数集合可以减小内存开销。</li><li>元素按照从小到大的顺序存储，这使得在整数集合上执行范围查询等操作更加高效。</li><li>通过二分查找，<code>intset</code> 可以在 O(log N) 的时间内完成查找操作。插入操作也可以在 O(N) 的时间内完成，因为可能需要进行数组的移动和扩容。</li><li>适用于小型整数集合，当整数集合较大时，intset的性能可能不如其他数据结构</li></ul></li><li>补充：<ul><li>节约内存，但由于是连续空间，修改效率不高</li><li>集合中的数都是整数时，且数据量不超过512个时，使用intset，set默认使用hashtable</li></ul></li></ol><h1>sortedSet</h1><p>底层是由ziplist 或 skiplist 实现的<br>有序集合是有序的集合数据结构，每个元素都与一个分数（score）相关联，通过分数进行排序。有序集合中的元素也可以是各种类型，不仅限于整数。分数可以是整数或浮点数。</p><h2 id="skiplist">skiplist</h2><h3 id="结构">结构</h3><ol><li>节点结构：<br>每个节点包含了两个主要部分以及指针：<ul><li>成员（Member）：存储有序集合中的元素（例如字符串）。</li><li>分值（Score）：与成员相关联的分值，用于排序。分值可以是整数或浮点数。</li><li>指针：用于在不同层级上进行快速查找。</li></ul></li><li>多层级结构：<ul><li>skiplist由很多层结构组成，每一层都是一个有序的链表，默认是升序，也可以根据创建映射时所提供的Comparator进行排序，具体取决于使用的构造方法</li><li>最底层(Level 1)的链表包含所有元素，如果一个元素出现在Level i 的链表中，则它在Level i 之下的链表也都会出现。例如，出现在level 3中，则会出现在level 2和level 1中。后续插入新的节点时，会<strong>随机选取插入的层级</strong>，这也影响到该层级之下的所有层级中是否需要插入该节点</li><li>每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素</li></ul></li><li>多级索引：<ul><li>为了提高查找效率，Skiplist包含了多级索引，每一级索引都是元素的子集。这些索引允许在不必遍历所有节点的情况下，通过跳过一些节点来快速找到目标节点。查询时，如果在当前层级找到了大于等于目标元素的位置，就可以下降到下一层级，继续查找，可以在 O(log N) 的时间内完成查询操作</li></ul></li><li>虚拟头节点：<ul><li>Skiplist中通常包含一个虚拟头节点，它不存储实际数据，但有助于简化代码逻辑，使得实现更加简洁。</li></ul></li></ol><h3 id="特点">特点</h3><ul><li>层次结构：skiplis 使用多层级的链表，每一层都是元素的子集。这种层次结构使得在有序集合中进行范围查询更加高效。</li><li>快速查询：skiplist具有 O(log N) 时间复杂度的查询操作，这使得查找某个成员或某个分值范围的成员非常高效。</li><li>元素存储：每个节点包含了一个成员和分值，同时具有多个指针，用于在不同层级上进行快速查找。</li><li>适用范围：适用于较大有序集合，对于元素数量较多或者需要频繁进行范围查询的情况。</li></ul><h1>总结</h1><p>string底层的数据结构：SDS，int<br>list底层的数据结构：ziplist、linkedlist、quicklist<br>hash底层的数据结构：ziplist、hashtable（dict）<br>set底层的数据结构：intset、hashtable（dict）<br>sortedSet底层的数据结构：ziplist、skiplist</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/posts/f1601c3e.html"/>
      <url>/posts/f1601c3e.html</url>
      
        <content type="html"><![CDATA[<h1>懒汉式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(singleton==<span class="literal">null</span>)&#123;  </span><br><span class="line">            singleton=<span class="keyword">new</span> <span class="title class_">Singleton</span>();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>饿汉式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton2 singleton2=<span class="keyword">new</span> <span class="title class_">Singleton2</span>();  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span>&#123;&#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> singleton2;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>双重校验锁</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton3</span> &#123;  </span><br><span class="line"><span class="comment">//    创建一个对象，在JVM中会经过三步：  </span></span><br><span class="line"><span class="comment">//          （1）为singleton分配内存空间  </span></span><br><span class="line"><span class="comment">//          （2）初始化singleton对象  </span></span><br><span class="line"><span class="comment">//          （3）将singleton指向分配好的内存空间  </span></span><br><span class="line"><span class="comment">//在这个过程中2、3步可能发生指令重排序，因此需要使用volatile来修饰  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton3 singleton3;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">()</span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="comment">// 线程A和线程B同时看到singleton = null，如果不为null，则直接返回singleton   </span></span><br><span class="line">        <span class="keyword">if</span> (singleton3 == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="comment">// 线程A或线程B获得该锁进行初始化  </span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton3.class) &#123; </span><br><span class="line">            <span class="comment">// 其中一个线程进入该分支，另外一个线程则不会进入该分支</span></span><br><span class="line">                <span class="keyword">if</span> (singleton3 == <span class="literal">null</span>) &#123;   </span><br><span class="line">                    singleton3 = <span class="keyword">new</span> <span class="title class_">Singleton3</span>();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> singleton3;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>枚举</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton4</span> &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    Singleton4() &#123; System.out.println(<span class="string">&quot;枚举创建对象了&quot;</span>); &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>单例模式的线程安全问题</h1><p>在一般的单例模式实现中，如果没有特殊处理，是不具备线程安全性的。主要的问题在于多线程环境下可能会导致<strong>多个线程同时访问到未初始化完成的实例或者同时执行实例的创建操作</strong>，从而造成实例的不一致性或错误。<br>上述四种单例模式的实现中，饿汉式、双重校验锁、枚举都可以保证单例的线程安全</p><ol><li>饿汉式在类加载时就创建了实例，因此不会存在多线程环境下的竞争问题。但它可能会提前占用资源，因为无论是否使用，实例都会被创建</li><li>双重校验锁使用<code>volatile</code>关键字确保多线程环境下对<code>instance</code>变量的可见性，而双重检查锁定通过在锁内外都进行一次判空来提高性能</li><li>枚举类型在Java中天生就是单例的，且线程安全</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库管理</title>
      <link href="/posts/92ac8f89.html"/>
      <url>/posts/92ac8f89.html</url>
      
        <content type="html"><![CDATA[<h1>概述</h1><p>数据库管理(Database Management)是指为保证数据库系统的正常运行和服务质量必须进行的系统管理工作。</p><h2 id="数据库管理目标">数据库管理目标</h2><p>1.保障数据库系统正常稳定运行<br>2.充分发挥数据库系统的软硬件处理能力<br>3.确保数据库系统安全和用户数据隐私性<br>4.有效管理数据库用户及其角色权限<br>5.解决数据库系统性能优化、系统故障与数据损坏等问题<br>6.最大程度地发挥数据库对其所属机构的作用</p><h2 id="数据库管理内容">数据库管理内容</h2><p>1.DBMS系统运行管理<br>2.数据库性能监控<br>3.数据库索引管理<br>4.数据库查询优化<br>5.数据库事务并发控制<br>6.数据库角色管理<br>7.数据库用户管理<br>8.数据库对象权限管理<br>9.数据安全管理<br>10.数据库备份和恢复</p><h2 id="数据库DBMS功能结构">数据库DBMS功能结构</h2><img src="/post-img/Pasted image 20230826205526.png" alt="图片损坏" style="zoom:100%;" /><h2 id="数据库DBMS系统结构">数据库DBMS系统结构</h2><img src="/post-img/Pasted image 20230826205557.png" alt="图片损坏" style="zoom:100%;" /><h1>事务管理</h1><p>在数据库应用系统中，完成一个业务处理通常需要多个操作步骤才能完成处理。在每个操作步骤中，都可能遭遇失败，若没有一个处理机制，就可能造成操作数据混乱，从而破坏数据一致性。</p><h2 id="事务">事务</h2><p>在数据库中，事务（Transaction）是指由构成单个业务处理单元的一组数据库访问操作，要求它们要么都成功执行，要么都不执行。</p><h2 id="事务状态">事务状态</h2><img src="/post-img/Pasted image 20230826205718.png" alt="图片损坏" style="zoom:100%;" /><h2 id="事务特性（ACID）">事务特性（ACID）</h2><p>原子性（Atomicity）：事务所有操作在数据库中要么全部执行，要么全部不执行。<br>一致性（Consistency）：事务多次执行，其结果应一致。<br>隔离性（Isolation）：事务与事务之间隔离，并发执行透明。<br>持续性（Durability ）：事务完成后，数据改变必须是永久的。</p><h2 id="事务并发执行">事务并发执行</h2><p>事务并发执行是指多个事务程序在数据库系统中同一时段运行。<br>事务并发执行原因：<br>1.改善系统的资源利用率<br>2.减少事务运行的平均等待时间</p><h2 id="事务SQL程序">事务SQL程序</h2><img src="/post-img/Pasted image 20230826205906.png" alt="图片损坏" style="zoom:100%;" /><h3 id="基本框架">基本框架</h3><img src="/post-img/Pasted image 20230826205922.png" alt="图片损坏" style="zoom:100%;" /><h2 id="默认事务处理方式">默认事务处理方式</h2><p>若用户没有显式地定义事务时，DBMS按默认事务方式处理，即每执行一个SQL语句将自动构成一个事务。若将多条SQL语句定义为一个事务时，才使用专门的事务SQL语句显式地定义事务。</p><h1>并发控制</h1><p>并发控制目的：<br>支持并发事务处理，使更多用户并行操作，提高系统的并发访问能力。<br>保证一个事务工作不会对另一个事务工作产生不合理的影响。<br>需解决的问题：<br>1.丢失更新数据<br>T1、T2两个事务并发执行，它们均对数据库共享数据A进行了非锁定资源的读写操作。<br>当事务T1和T2均读入该共享数据A并修改，T2提交的结果破坏了T1提交的结果，导致T1的修改被丢失。<br>2.不可重复读取<br>事务T1读取某一数据后，事务T2对其做了修改（插入，删除），当事务T1再次读该数据时，得到与前一次不同的值。<br>3.脏数据读取<br>脏数据读取是指一个事务读取了被取消持久化（被恢复）的共享数据。</p><h2 id="事务调度">事务调度</h2><p>并发事务调度就是控制多个事务的数据操作语句按照恰当的顺序访问共享数据，使这些事务执行之后，避免造成数据的不一致性，即解决“丢失更新数据”、“不可重复读”、“脏数据读”等问题。</p><h3 id="原理">原理</h3><p>在DBMS中，事务管理器将并发执行事务的SQL数据操作请求提交给并发控制调度器。由并发控制调度器将各个事务的SQL数据操作请求按照一定顺序进行调度执行，并完成对数据库缓冲区的读写操作。</p><h3 id="策略">策略</h3><p>按一定顺序串行<br>在事务并发执行中，只有当事务中数据操作调度顺序的执行结果与事务串行执行结果一样时，该并发事务调度才能保证数据操作的正确性和一致性。符合这样效果的调度称为可串行化调度。</p><h2 id="锁机制">锁机制</h2><p>为了解决多个事务并发对共享数据进行新增、更新、删除、查询带来的数据不一致性问题时，需要对共享数据进行加锁访问。<br>1.资源锁定访问<br>在DBMS中，通过加入锁表机制，来实现共享数据锁定访问，其加锁方式包含如下类型。<br>排它锁定(Lock-X)——锁定后，不允许其它事务对共享数据再加锁<br>共享锁定(Lock-S)——锁定后，只允许其它事务对共享数据添加读取锁<br>2.资源锁定粒度<br>数据库——粒度最大<br>表——粒度较大<br>页面——粒度中等<br>行——粒度小<br>3.资源锁定实施方式<br>隐式锁定-DBMS缺省执行<br>显式锁定-加锁命令显式执行</p><h2 id="控制协议">控制协议</h2><p>为了实现并发事务对共享数据访问的串行化调度执行，还必须约束它们对共享数据的操作访问必须是以互斥方式进行。这就需要用到基于数据库锁机制的并发控制协议。</p><h3 id="锁操作的相容性">锁操作的相容性</h3><img src="/post-img/Pasted image 20230826210714.png" alt="图片损坏" style="zoom:100%;" /><h3 id="加锁协议">加锁协议</h3><p>一级加锁协议：任何事务在修改共享数据对象之前，必须对该数据执行排它锁定指令，直到该事务处理完成，才进行解锁指令执行。可避免出现更新丢失问题<br>二级加锁协议：在一级加锁协议基础上，针对并发事务的共享数据读操作，必须对该数据执行共享锁定指令，读完数据后即刻释放共享锁定。该加锁协议不但可以防止“丢失更新”的数据不一致性问题，还可防止出现脏读数据问题<br>三级加锁协议：在一级加锁协议基础上，针对并发事务对共享数据进行读操作，必须对该数据执行共享锁定指令，直到该事务处理结束才释放共享锁定。该加锁协议不但可以防止“丢失更新”、“脏读”的数据不一致性问题，还可防止出现“不可重复读取”的数据一致性问题。<br><img src="/post-img/Pasted image 20230826210831.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="二阶段锁定协议">二阶段锁定协议</h2><p>一个给定的并发事务调度，当且仅当它是可串行化时，才能保证正确调度。<br>保证可串行化的一个协议是：二阶段锁定协议<br>二阶段锁定协议规定每个事务必须分两个阶段提出加锁和解锁申请:<br>增长阶段，事务只能获得锁，但不能释放锁。<br>缩减阶段，事务只能释放锁，但不能获得新锁。</p><h2 id="死锁">死锁</h2><p>在基于锁机制的并发事务执行中，如果这些事务同时锁定两个以及以上资源时，可能会出现彼此都不能继续执行的状态，即事务死锁状态</p><h3 id="死锁出现的必要条件">死锁出现的必要条件</h3><p>互斥条件<br>请求和保持条件<br>不剥夺条件<br>环路等待条件</p><h3 id="防范死锁的策略">防范死锁的策略</h3><p>允许用户一次发出当前所需全部资源的锁定，使用完成后，再释放给其它用户访问。<br>规定所有应用程序锁定资源的顺序必须完全相同。</p><h3 id="解决死锁的方法">解决死锁的方法</h3><p>当发生死锁时，回滚其中的一个事务，并取消它对数据库所做的改动</p><h1>安全管理</h1><h2 id="存取安全模型">存取安全模型</h2><p>身份验证:从应用系统层面确认登录用户是否是合法使用者<br>权限控制:从DBMS系统层面通过存取权限机制控制用户对数据的访问<br>系统防护:从操作系统层面提供的安全机制防范非法系统访问<br>加密存储:从数据存储层面通过加密算法对数据库中数据进行加密存储</p><h2 id="用户、角色、权限管理">用户、角色、权限管理</h2><h3 id="用户管理">用户管理</h3><p>用户要访问数据库，必须先在DBMS中创建其账号，并成为数据库的用户。此后，用户每次访问数据库，都需要在DBMS进行身份验证，只有合法用户才能进入系统，访问操作数据库对象。<br>在数据库安全管理中，DBMS需要对每个用户进行管理，如用户创建、用户修改、用户删除管理等。<br><img src="/post-img/Pasted image 20230826211241.png" alt="图片损坏" style="zoom:100%;" /><br><img src="/post-img/Pasted image 20230826211303.png" alt="图片损坏" style="zoom:100%;" /><br><img src="/post-img/Pasted image 20230826211317.png" alt="图片损坏" style="zoom:100%;" /></p><h3 id="权限管理">权限管理</h3><p>数据库权限管理是指DBA管理员或数据库对象拥有者对其所拥有对象进行权限控制设置。<br>权限管理基本操作：授予权限、收回权限、拒绝权限<br>权限类别：数据库系统权限、数据库对象访问操作权限、数据库对象定义操作权限<br><img src="/post-img/Pasted image 20230826211429.png" alt="图片损坏" style="zoom:100%;" /></p><h3 id="角色管理">角色管理</h3><p>在DBMS中，为了方便对众多用户及其权限进行管理，通常将一组具有相同权限的用户定义为角色(Role)。<br>角色管理内容：创建角色、修改角色、删除角色<br><img src="/post-img/Pasted image 20230826211534.png" alt="图片损坏" style="zoom:100%;" /></p><h1>数据库备份与恢复</h1><p>数据库备份——是指将数据库当前数据和状态进行副本复制，以便当数据库受到破坏或丢失数据时可以进行修复。<br>数据库恢复——是指数据库中数据丢失或被破坏时，从备份副本将数据库从错误状态恢复到某一正确状态。<br>备份内容——包括数据文件、日志文件等。<br>备份角色——可以是服务器管理员（sysadmin）、数据库所有者（db_owner）、数据库备份员（db_backupoperator）角色之一。</p><h2 id="备份方法">备份方法</h2><img src="/post-img/Pasted image 20230826211650.png" alt="图片损坏" style="zoom:100%;" />1.通过备份文件进行恢复  2.利用事务日志按前滚或回滚方式进行数据库恢复]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库概论</title>
      <link href="/posts/bef137fa.html"/>
      <url>/posts/bef137fa.html</url>
      
        <content type="html"><![CDATA[<h1>基本概念</h1><h2 id="数据库">数据库</h2><p>数据库是一种依照特定数据模型组织、存储和管理数据的文件集合，这些文件一般存放在外部存储器中，以便长久保存数据，并可快速访问<br>特征：三个基本特点（永久存储、有组织、可共享）<br>1.数据按一定的数据模型组织、描述和储存<br>2.可为各种用户共享<br>3.冗余度较小<br>4.数据独立性较高<br>5.易扩展</p><h2 id="数据">数据</h2><p>数据是描述事物的符号记录，包括文字，图形，声音，图像等，它是数据库中存储的基本对象</p><h2 id="数据库管理系统">数据库管理系统</h2><p>数据库管理系统是为于用户与操作系统之间的一层数据管理软件<br>用于科学的组织和存储数据、高效的获取和维护数据</p><h2 id="数据库系统">数据库系统</h2><p>数据库系统是指在计算机系统中引入数据库后的系统构成，简称为数据库<br>由<strong>数据库、数据库管理系统（及其开发工具）、应用系统、数据库管理员和用户</strong>构成</p><h2 id="数据模型">数据模型</h2><p>数据模型是指描述事物对象的数据结构组成、数据语义练习、数据约束的抽象结构及其说明<br>包含：<br><strong>数据结构</strong>是用于描述事物对象的静态特征，包括事物对象的<strong>数据组成、数据类型、数据性质</strong>等<br><strong>数据操作</strong>用于描述事物对象的动态特征，包括<strong>数据的插入、修改、删除和查询</strong>等访问操作。<br><strong>数据约束</strong>用于描述数据结构中<strong>数据之间的语义联系、数据之间的制约和依存关系，以及数据动态变化的规则</strong>等。</p><h3 id="数据库使用的数据模型">数据库使用的数据模型</h3><h4 id="层次数据模型">层次数据模型</h4><p>采用树结构来组织、存储和管理数据</p><h4 id="网状数据模型">网状数据模型</h4><p>采用网状图结构组织、存储和管理数据</p><h4 id="关系数据模型">关系数据模型</h4><p>采用“二维表”结构组织、存储和管理数据，并以关联列实现表之间的联系。<br>关系数据模型优点：<br>数据结构简单、操作灵活<br>支持关系与集合运算操作<br>支持广泛使用的SQL数据库操作语言标准<br>拥有众多的软件厂商产品与用户<br>关系数据模型局限：<br>只用于结构化数据的组织与存储管理<br>支持的数据类型较简单<br>难以支持互联网广泛应用的非结构化数据和复杂数据管理</p><h4 id="其它数据模型">其它数据模型</h4><p>如对象数据模型、键值对数据模型、列式数据模型、文档数据模型、图形数据模型等</p><h1>数据库系统</h1><p>是一类基于数据库进行数据管理与信息服务的软件系统。<br>由用户、数据库应用程序、数据库管理系统和数据库四个部分组成。<br><strong>数据库用户</strong>是指数据库系统的使用人员，如应用程序员，系统分析员，数据库管理员，最终用户<br><strong>数据库应用程序</strong>是一种在DBMS支持下对数据库中数据进行访问处理的应用程序。<br>数据库应用程序基本功能:<br>通过窗口输入框采集用户输入数据<br>通过接口连接访问数据库<br>执行用户数据查询<br>通过表单列表输出结果数据<br><strong>数据库管理系统</strong>是一种专门用来创建数据库、管理数据库、维护数据库，并提供外部对数据库进行访问的系统软件。<br>数据库管理系统一般具有如下基本功能:<br>创建数据库、数据库表以及其它对象<br>读写、修改、删除数据库表中数据<br>维护数据库结构<br>执行数据访问规则<br>提供数据库并发访问控制和安全控制<br>执行数据库备份和恢复<br><strong>数据库</strong>是一种依照特定数据模型组织、存储和管理数据的文件集合。</p><h2 id="关系数据库系统">关系数据库系统</h2><h3 id="关系数据库中的数据内容">关系数据库中的数据内容</h3><p>在<strong>关系数据库</strong>中，除了存储和管理应用的<strong>用户数据</strong>外，还需要存储与管理数据库本身的<strong>元数据、索引数据、运行数据</strong>等系统数据。</p><h3 id="关系数据库的对象组织">关系数据库的对象组织</h3><p>用户表：存储用户的应用数据<br>系统表：存储数据库系统自身数据<br>视图：通过虚拟表实现数据查询处理<br>索引：通过目录数据结构支持快速的数据查询<br>约束：对关系表及其数据施加规则<br>存储过程：在数据库内部实现特定功能程序的数据处理<br>触发器：在数据库内部实现数据操作事件触发自动执行的过程程序</p><h1>数据库应用系统</h1><h2 id="数据库应用系统类型">数据库应用系统类型</h2><p>1.业务处理系统<br>2.管理信息系统<br>3.决策支持系统</p><h2 id="数据系统应用结构">数据系统应用结构</h2><p><strong>1.单机用户结构</strong><br>在单机用户结构系统中，整个数据库应用系统都装在一台计算机上，由一个用户进行访问操作，数据不能共享，数据冗余度大。<br><strong>2.集中式结构</strong><br>特点: 数据库系统的应用程序、DBMS、数据，都部署在同一服务器上运行，多个用户使用自己的计算机终端网络连接服务器，并可实现共享访问数据库。<br>优缺点: 结构简单，易于维护，但是当终端用户增加到一定数量后，服务器及网络将成为数据存取访问的瓶颈，使系统的性能大大地降低。<br><strong>3.客户/服务器结构</strong><br>特点:数据库应用系统的数据集中在数据库服务器管理、应用分布客户机处理。客户端应用程序通过网络并发访问数据库服务器中的数据库。<br>优缺点:在客户/服务器结构系统中，客户机程序与数据库服务器分工进行数据处理，提高了系统的负载分担能力，但仍会因大量客户端并发访问数据库服务器，导致系统性能瓶颈。<br><strong>4.分布式结构</strong><br>特点：分布式结构的数据库系统既实现数据分布，又实现处理分布。分布式数据库系统的各服务器结点数据库在逻辑上是一个整体，但物理分布在计算机网络的不同服务器结点上运行。每个数据库服务器可通过网络既支持多个本地客户机访问，也支持远程客户机访问。网络中的每一个数据库服务器都可以独立地存取与处理数据，并执行全局应用。<br>优缺点:分布式结构数据库系统适合跨地区的大型机构及企业等组织对数据库应用的需求，其处理性能强，但数据库的分布处理与维护有一定的开销与技术难度。</p><h2 id="数据库应用系统生命周期">数据库应用系统生命周期</h2><p>1.需求分析<br>2.系统设计<br>3.系统实现<br>4.系统测试<br>5.系统运行与维护</p><h1>典型数据库管理系统</h1><p>ACCESS——微软公司推出的桌面数据库管理系统<br>SQL SERVER——微软公司推出的商用数据库管理系统<br>Oracle Database——甲骨文公司推出的企业级数据库管理系统<br>IBM DB2——IBM公司推出的企业级数据库管理系统<br>Sybase ASE——Sybase公司推出的企业级数据库管理系统<br>MySql——应用广泛的开源关系数据库管理系统<br>PostgreSQL——技术领先的开源对象-关系数据库管理系统<br>Sybase SQL Anywhere——Sybase推出的移动计算数据库管理系统<br>SQLite——开源的轻量级嵌入式数据库管理系统</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库编程</title>
      <link href="/posts/8c5e4b35.html"/>
      <url>/posts/8c5e4b35.html</url>
      
        <content type="html"><![CDATA[<h1>数据库连接技术（ODBC）</h1><p>开放式数据库互连Open DataBase Connectivity<br>实现了应用程序对多种不同DBMS的数据库的访问，实现了数据库连接方式的变革。<br>ODBC定义了一套基于SQL的、公共的、与数据库无关的API（应用程序设计接口）；<br>使每个应用程序利用相同的源代码就可访问不同的数据库系统，存取多个数据库中的数据；<br>从而使得应用程序与数据库管理系统（DBMS）之间在逻辑上的独立性，使应用程序具有数据库无关性。</p><h2 id="层次结构">层次结构</h2><img src="/post-img/Pasted image 20230826212141.png" alt="图片损坏" style="zoom:100%;" /><p><strong>ODBC应用程序接口：</strong><br>是一种使用ODBC技术实现应用程序与数据库互连的标准接口。<br>ODBC驱动程序管理器：<br>用于管理系统中的各种驱动程序。<br><strong>驱动程序：</strong><br>是一个用于支持ODBC函数调用的模块，通常是一个动态链接库DLL。不同RDBMS的驱动程序是不同的。每种数据库都要向ODBC驱动程序管理器注册它自己的驱动程序。<br>建立与数据源的连接<br>向数据源提交请求<br>在应用程序需求时，转换数据格式<br>返回结果给应用程序<br>将运行错误格式化为标准代码返回<br>需要时可声明和处理游标。<br><strong>数据源：</strong><br>驱动程序与数据库系统连接的桥梁。<br>它不是数据库系统，而是用于表达ODBC驱动程序与DBMS特殊连接的命名。<br>在连接中，用数据源名来代表用户名、服务器名、连接的数据库名等；<br>可以将数据源名看成是与一个具体数据库建立的连接；<br>创建数据源最简单的方法是使用Windows的ODBC驱动程序管理器<br><strong>SQL Server DBMS:</strong><br>是用户向各数据库厂商购买的管理数据库的管理软件；<br>是管理数据库的系统软件；<br>用户可以执行SQL语句；<br>创建数据库、表、视图等；<br>对数据库进行权限管理。<br><strong>SQL Server DB：</strong><br>用户创建的数据库；<br>用于存储用户数据、对象。</p><h2 id="应用程序使用ODBC访问数据库的步骤">应用程序使用ODBC访问数据库的步骤</h2><p>1.首先必须用ODBC管理器注册一个数据源；<br>2.管理器根据数据源提供的数据库位置、数据库类型及ODBC驱动程序等信息，建立起ODBC与具体数据库的联系；<br>3.应用程序只需将数据源名提供给ODBC，ODBC就能建立起与相应数据库的连接；<br>4.这样，应用程序就可以通过驱动程序管理器与数据库交换信息；<br>5.驱动程序管理器负责将应用程序对ODBC API的调用传递给正确的驱动程序；<br>6.驱动程序在执行完相应的SQL操作后，将结果通过驱动程序管理器返回给应用程序</p><h1>数据库连接技术（JDBC）</h1><p>JDBC（Java DataBase Connectivity，Java数据库连接）技术的简称 ，是一种用于执行SQL语句的Java API。<br>它由一组用Java编程语言编写的类和接口组成。这个API由java.sql.* 包中的一些类和接口组成，它为数据库开发人员提供了一个标准的API，使他们能够用纯Java API 来编写数据库应用程序。<br>注意：使用JDBC访问数据库需要相应数据库的JDBC驱动程序。</p><h2 id="工作原理">工作原理</h2><img src="/post-img/Pasted image 20230826212609.png" alt="图片损坏" style="zoom:100%;" /><h2 id="JDBC程序访问数据库步骤">JDBC程序访问数据库步骤</h2><img src="/post-img/Pasted image 20230826212616.png" alt="图片损坏" style="zoom:100%;" />1.加载驱动2.建立连接3.创建Statement对象4.执行SQL语句5.ResultSet保存结果集6.关闭连接<h1>JavaWeb数据库编程</h1><h2 id="Web容器">Web容器</h2><p><a href="http://1.Web">1.Web</a> 容器提供了运行servlet 所需的环境；<br>2.它负责实例化、初始化、调用服务方法并从服务中移除servlet，管理Servlet 的生命周期；<br>3.实现Servlet API；<br>4.它充当Web 服务器和Servlet 之间的桥梁；<br>5.将请求从Web 服务器转发到Servlet；<br>6.将响应从Servlet 转发到Web 服务器。</p><h2 id="Servlet工作流程">Servlet工作流程</h2><img src="/post-img/Pasted image 20230826212907.png" alt="图片损坏" style="zoom:100%;" />1客户机将请求发送到服务器； 2.Servlet程序是由Web服务器调用，Web服务器收到客户端的Servlet访问请求后，解析客户端的请求；3.服务器上的Web容器转载并实例化Servlet；4.调用Servlet实例对象的init()方法；5.调用Servlet的service()方法并将请求和响应对象作为参数传递进去；6.Servlet 创建一个响应，并将其返回到Web容器。7.Web容器将响应发回客户机。8.服务器关闭或Servlet空闲时间超过一定限度时，调用destory()方法退出。<h2 id="MyBatis访问数据库技术">MyBatis访问数据库技术</h2><p>MyBatis 是Apache的开源项目iBatis，基于Java的持久层框架，提供的持久层框架包括SQL Maps和Data Access Objects（DAOs）。<br>MyBatis 是支持普通 SQL查询、存储过程和高级映射的优秀持久层框架。MyBatis 使用简单的XML或注解用于配置和原始映射，将接口和 Java 的POJOs（Plain Ordinary Java Objects，普通的 Java对象）映射成数据库中的记录，而不是使用JDBC代码和参数实现对数据的检索。</p><h3 id="基本步骤">基本步骤</h3><img src="/post-img/Pasted image 20230826213134.png" alt="图片损坏" style="zoom:100%;" />1.读取配置文件SqlMapConfig.xml，此文件作为Mybatis的全局配置文件，配置了Mybatis的运行环境等信息。mapper.xml文件即SQL映射文件，文件中配置了操作数据库的SQL语句，此文件需要在SqlMapConfig.xml中加载；2.SqlSessionFactoryBuilder通过Configuration生成sqlSessionFactory对象。3.通过sqlSessionFactory打开一个数据库会话sqlSession会话，操作数据库需要通过sqlSession进行。4.Mybatis底层自定义了Executor执行器接口操作数据库，Executor接口负责动态SQL的生成和查询缓存的维护，将MappedStatement对象进行解析，SQL参数转化、动态SQL拼接，生成JDBC Statement对象。<h1>数据库存储过程</h1><p>存储过程（Stored Procedure）是一种数据库的对象；<br>由一组能完成特定功能的SQL 语句集构成；<br>是把经常会被重复使用的SQL语句逻辑块封装起来，经编译后，存储在数据库服务器端；<br>当被再次调用时，而不需要再次编译；<br>当客户端连接到数据库时，用户通过指定存储过程的名字并给出参数，数据库就可以找到相应的存储过程予以调用。</p><h2 id="创建存储过程的语法">创建存储过程的语法</h2><img src="/post-img/Pasted image 20230826213230.png" alt="图片损坏" style="zoom:100%;" /><h2 id="执行存储过程">执行存储过程</h2><img src="/post-img/Pasted image 20230826213322.png" alt="图片损坏" style="zoom:100%;" /><img src="/post-img/Pasted image 20230826213330.png" alt="图片损坏" style="zoom:100%;" /><h2 id="删除存储过程">删除存储过程</h2><img src="/post-img/Pasted image 20230826213350.png" alt="图片损坏" style="zoom:100%;" /><h2 id="PL-SQL基本语法">PL/SQL基本语法</h2><h3 id="声明局部变量">声明局部变量</h3><img src="/post-img/Pasted image 20230827152456.png" alt="图片损坏" style="zoom:100%;" />record是指在不明确变量类型的时候，为保证程序语法的格式而使用的占位符它可以存储一个实体类数据（类比，因为SQL中没有实体类的概念），也就是一个实例对象的全部数据（或部分）都可以存放在一个record类型的变量中<h3 id="条件语句">条件语句</h3><img src="/post-img/Pasted image 20230827152658.png" alt="图片损坏" style="zoom:100%;" /><h3 id="循环语句">循环语句</h3><img src="/post-img/Pasted image 20230827152711.png" alt="图片损坏" style="zoom:100%;" /><img src="/post-img/Pasted image 20230827152719.png" alt="图片损坏" style="zoom:100%;" /><h3 id="遍历命令结果">遍历命令结果</h3><img src="/post-img/Pasted image 20230827152746.png" alt="图片损坏" style="zoom:100%;" /><h1>数据库触发器</h1><p>触发器是特殊类型的存储过程，主要由操作事件(INSERT、UPDATE、DELETE) 触发而被自动执行。<br>触发器可以实现比约束更复杂的数据完整性，经常用于加强数据的完整性约束和业务规则。<br>触发器本身是一个特殊的事务单位。<br>特点：<br>与表相关联：必须定义在表或视图上。<br>自动触发：由执行INSERT、DELETE、UPDATE操作时触发，不能直接调用，也不能传递或接受参数<br>是事务的一部分：触发器和触发语句作为可在触发器内回滚的单个事务</p><h2 id="分类">分类</h2><p>1.INSERT触发器、DELETE触发器、UPDATE触发器<br>2.语句级触发器、行级触发器<br>3.BEFORE触发器：在触发事件之前执行触发器。<br>AFTER触发器：在触发事件之后执行触发器。<br>INSTEAD OF触发器：当触发事件发生后，执行触发器中指定的函数，而不是执行产生触发事件的SQL 语句，从而替代产生触发事件的SQL操作。在表或视图上，对于INSERT、UPDATE 或 DELETE 三种触发事件，每种最多可以定义一个INSTEAD OF 触发器</p><h2 id="触发器相关的特殊变量">触发器相关的特殊变量</h2><p>（1）NEW<br>数据类型是RECORD。对于行级触发器，它存有INSERT或UPDATE操作产生的新的数据行。对于语句级触发器，它的值是NULL。<br>（2）OLD<br>数据类型是RECORD。对于行级触发器，它存有被UPDATE或DELETE操作修改或删除的旧的数据行。对于语句级触发器，它的值是NULL。<br>（3）TG_OP<br>数据类型是text；是值为INSERT、UPDATE、DELETE 的一个字符串，它说明触发器是为哪个操作引发。<br>总结：NEW和OLD用于行级触发器，存放修改前（或后）的数据，可以调用数据行中某个字段的数据<br>TG_OP用于语句级触发器，存储触发器的触发类型</p><p>关于语句级触发器（default）和行级触发器（FOR EACH ROW）<br>语句级的语句针对的是SQL语句，当一条SQL语句执行的操作同时修改了数据库表中的任意条数据时，触发器只会执行一次；这种触发器是针对整个 SQL 语句的操作。当执行一条 SQL 语句时，语句级触发器会在整个语句执行完成后被激活，无论这条语句涉及多少行数据。它们对整个语句的操作进行处理，而不是逐行处理。<br>行级的行针对是数据库表，每当修改一行数据时，触发器都会执行一次；这种触发器是针对表的每一行数据的操作。当对表进行 INSERT、UPDATE 或 DELETE 操作时，行级触发器会在每一行上被激活。它们对表中每一行的操作进行处理。</p><h2 id="语法和使用">语法和使用</h2><h3 id="创建触发器">创建触发器</h3><img src="/post-img/Pasted image 20230827153644.png" alt="图片损坏" style="zoom:100%;" /><h3 id="修改触发器">修改触发器</h3><img src="/post-img/Pasted image 20230827153748.png" alt="图片损坏" style="zoom:100%;" /><h3 id="删除触发器">删除触发器</h3><img src="/post-img/Pasted image 20230827153759.png" alt="图片损坏" style="zoom:100%;" /><h3 id="使用步骤">使用步骤</h3><p>（1）检查数据库中将要创建的触发器所依附的表或视图是否存在，如果不存在，必须首先创建该表或视图。<br>（2）创建触发器被触发时所要执行的触发器函数，该函数的类型必须是TRINGER型，是触发器的执行函数。但要注意，有些数据库不需要独立定义触发器函数，而是在创建触发器时，定义触发器的过程体。<br>（3）创建触发器，一般需要指明触发器依附的表，触发器被触发执行的时间，触发器是行级触发器还是语句级触发器，触发器执行需要满足的条件</p><h1>数据库游标</h1><p>（1）游标（Cursor）是一种临时的数据库对象；<br>（2）用来存放从数据库表中查询返回的数据记录；<br>（3）提供了从结果集中提取并分别处理每一条记录的机制；<br>（4）游标总是与一条SQL查询语句相关联；<br>（5）游标包括：SQL语言的查询结果，指向特定记录的指针。</p><h2 id="声明">声明</h2><p>（1）在存储过程中游标类型的变量。例如：游标变量  refcursor;<br>refcursor是关键字；<br>此时，游标变量还没有绑定查询语句，因此不能访问游标变量。<br>（2） 使用游标专有的声明语法，如：<br>游标名  CURSOR [ ( arguments ) ] FOR query;<br>其中arguments为由逗号分隔的参数列表，用于打开游标时向游标传递参数，类似于存储过程或函数的形式参数；query是select数据查询语句，返回的值存储在游标变量中。</p><h2 id="打开">打开</h2><p>（1）OPEN FOR:<br>其声明形式为：<br>OPEN unbound_cursor FOR query;<br>打开未绑定的游标变量，其query查询语句是返回记录的SELECT语句。<br>（2）OPEN FOR EXECUTE<br>其声明形式为：  OPEN unbound_cursor FOR EXECUTE query-string;<br>打开未绑定的游标变量。EXECUTE将动态执行查询字符串。<br>（3）打开一个绑定的游标，其声明形式为：<br>OPEN bound_cursor [ ( argument_values ) ];<br>仅适用于绑定的游标变量，只有当该变量在声明时包含接收参数，才能以传递参数的形式打开该游标，参数将传入到游标声明的查询语句中</p><h2 id="读取">读取</h2><p>其声明形式为：    FETCH cursor INTO target;<br>FETCH命令从游标中读取下一行记录的数据到目标中，读取成功与否，可通过PL/SQL内置系统变量FOUND来判断。</p><h2 id="关闭">关闭</h2><p>CLOSE cursorName;<br>当游标数据不再需要时，需要关闭游标，以释放其占有的系统资源，主要是释放游标数据所占用的内存资源，cursorName是游标名。</p><h2 id="游标和存储过程">游标和存储过程</h2><p>游标不是存储过程，它是一种对象，可以体现为存储过程中的变量，这个特殊的变量可以与某条查询语句查询出来的数据绑定，暂时存储这些数据，并可通过循环将这些数据逐条提供给变量，便于存储过程使用，这可以使得查询结果与存储过程分离，更直观，具有封装性和可重用性</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库设计</title>
      <link href="/posts/841393be.html"/>
      <url>/posts/841393be.html</url>
      
        <content type="html"><![CDATA[<h1>数据库设计方案</h1><p>1.数据库应用架构设计<br>在不同应用需求场景中，数据库的应用架构方式是不同的。数据库应用架构可分为单用户结构、集中式结构、客户/服务器结构和分布式结构。<br>2.数据库结构模型设计<br>数据库结构模型设计一般分为概念层、逻辑程、物理层设计，它们的设计模型分别为概念数据模型、逻辑数据模型和物理数据模型。<br>3.数据库应用访问方式设计<br>数据库应用对数据库访问可以有多种方式，如直接本地接口连接访问、基于标准接口连接访问、基于数据访问层框架连接访问</p><h1>数据库结构模型</h1><h2 id="概念数据模型">概念数据模型</h2><p>(Concept Data Model，CDM)是一种面向用户的系统数据模型，它用来描述现实世界的系统概念化数据结构。使数据库设计人员在系统设计的初始阶段，摆脱计算机系统及DBMS的具体技术问题，集中精力分析业务数据以及数据之间的联系等，描述系统的数据对象及其组成关系。</p><h2 id="逻辑数据模型">逻辑数据模型</h2><p>(Logic Data Model，LDM)是在概念数据模型基础上，从系统设计角度描述系统的数据对象组成及其关联结构，并考虑这些数据对象<br>符合数据库对象的逻辑表示。</p><h2 id="物理数据模型">物理数据模型</h2><p>（Physical Data Model，PDM）是在逻辑数据模型基础上，针对具体DBMS所设计的数据模型。它用于描述系统数据模型在具体DBMS中的数据对象组织、存储方式、索引方式、访问路径等实现信息。</p><h1>数据库开发过程及设计策略</h1><h2 id="数据库开发过程">数据库开发过程</h2><img src="/post-img/Pasted image 20230826195242.png" alt="图片损坏" style="zoom:100%;" /><p><strong>1）数据需求分析阶段</strong><br>从现实业务获取数据表单、报表、查询、业务规则、数据更新的说明<br>分析系统的数据特征、数据类型、数据取值约束<br>描述系统的数据关系、数据处理要求<br>建立系统的数据字典<br><strong>2）数据库设计阶段</strong><br>数据库模型结构设计（概念数据模型、逻辑数据模型、物理数据模型）<br>数据库索引、视图、查询设计<br>数据库表约束设计<br>数据库触发器、存储过程设计<br><strong>3）数据库实现阶段</strong><br>数据库创建<br>数据模型物理实现<br><strong>4）数据库测试阶段</strong><br>数据库数据上线<br>数据库系统测试</p><h2 id="设计策略">设计策略</h2><p>自底向上设计<br>自顶向下设计<br>自内向外设计<br>混合策略设计</p><h1>E-R模型</h1><p>E-R模型是“实体-联系模型”（Entity-Relationship Model）的简称。它是一种描述现实世界概念数据模型、逻辑数据模型的有效方法。</p><h2 id="E-R模型的基本元素">E-R模型的基本元素</h2><h3 id="实体">实体</h3><p>实体(Entity)是指问题域中存在的人、事、物、地点等客观事物在逻辑层面的数据抽象。它用于描述事物的数据对象，如客户、交易、产品、订单等。</p><h3 id="属性">属性</h3><p>属性是指描述实体特征的数据项。每个实体都具有1个或多个属性。</p><h3 id="标识符">标识符</h3><p>标识符是指标识不同实体实例的属性。标识符可以是1个或多个属性。<br>标识符与主键的区别是标识符是一个逻辑概念，主键是物理概念。</p><h3 id="联系">联系</h3><p>联系(Relationship)是指实体之间的联系，如“学生”与“成绩”的联系、“孩子”与“父亲”、“母亲”的联系等。<br>联系中关联的实体数目称为联系度数。</p><h2 id="实体-联系类型">实体-联系类型</h2><img src="/post-img/Pasted image 20230826195725.png" alt="图片损坏" style="zoom:100%;" />上述实体之间的联系反映了一个给定实体有多少实例与另一实体实例存在的数量对应关系。通常采用术语**基数**（Cardinality）来表示。在实体之间除了需要反映了数量对应关系，有时还需要反映实体参与关系的必要性，即**可选（optional）或强制**（mandatory）。<img src="/post-img/Pasted image 20230826195817.png" alt="图片损坏" style="zoom:100%;" />鸟足版本：<img src="/post-img/Pasted image 20230826195846.png" alt="图片损坏" style="zoom:100%;" /><h2 id="E-R模型方法">E-R模型方法</h2><p>理解E-R模型的继承联系<br>理解E-R模型中的强弱实体联系<br>掌握E-R模型扩展建模方法</p><h3 id="实体继承联系">实体继承联系</h3><p>在E-R模型中，实体之间除了基本联系外，还存在继承联系。继承联系用于表示实体之间的相似性关系。<br>在实体继承联系中，一端是具有公共属性的实体，称为父实体；另一端是与父实体具有相似属性，同时也具有特殊性的一个或多个实体，称为子实体。<br>在继承联系中，还可以分为互斥性继承联系和非互斥性继承联系。<br><img src="/post-img/Pasted image 20230826201437.png" alt="图片损坏" style="zoom:100%;" /><br>还可以分为完整继承和非完整继承。如果父实体实例必须属于子实体中的某一个，则称为完整继承联系；否则是非完整继承联系。<br><img src="/post-img/Pasted image 20230826201448.png" alt="图片损坏" style="zoom:100%;" /></p><h3 id="强弱实体联系">强弱实体联系</h3><p>在E-R模型中，按照实体之间的语义关系，可以将实体分为<strong>弱实体和强实体</strong>。弱实体是指那些对于另外实体有依赖关系的实体，即一个实体的存在必须以另一实体的存在为前提。而被依赖的实体称为强实体。<br>其中，根据弱实体在语义上对强实体依赖程度的不同，<strong>弱实体又分为标识符（ID）依赖弱实体和非标识符（非ID）依赖弱实体两类</strong>。如果弱实体的标识符中含有所依赖实体的标识符，则该弱实体称为标识符（ID）依赖弱实体。在有依赖联系的弱实体中，并非所有弱实体都是标识符（ID）依赖弱实体，它们可以有自己的标识符，这样的弱实体即为非标识符（ID）依赖弱实体。</p><h1>数据库建模设计</h1><h2 id="概念数据模型-2">概念数据模型</h2><p>概念数据模型设计是通过对现实世界中数据实体进行抽取、分类、聚集和概括等处理，建立反映系统业务数据组成结构的过程，一般是采用E-R模型方法进行建模设计。<br>设计步骤：<br>1.业务数据分析，抽取数据实体<br>2.定义实体属性及其标识（类图）<br>3.建立实体联系，构建局部E-R模型图（类图间通过鸟足版本建立联系）<br>4.分类、聚集和概括各个部分E-R模型图（添加新类图和联系）<br>5.完善全局E-R模型图，建立系统业务数据组成结构</p><h2 id="CDM-LDM-PDM模型转换设计">CDM/LDM/PDM模型转换设计</h2><h3 id="数据模型元素对应关系">数据模型元素对应关系</h3><img src="/post-img/Pasted image 20230826201917.png" alt="图片损坏" style="zoom:100%;" /><h3 id="不同层次数据模型转换方案">不同层次数据模型转换方案</h3><img src="/post-img/Pasted image 20230826201928.png" alt="图片损坏" style="zoom:100%;" /><h3 id="转换原理">转换原理</h3><p>CDM/LDM到PDM转换原理：<br>当使用关系数据库时，物理数据模型（PDM）即为关系模型。CDM/LDM到PDM的转换其实就是E-R模型到关系模型的转换。<br>E-R模型到关系模型转换原理：<br>1.将每一个实体转换成一个关系表，实体属性转换为关系表的列，实体标识符转换为关系表的主键或外键。<br>2.将实体之间的联系转化为关系表之间的参照完整性约束。<br>将实体转换为关系关系表时，注意如果是弱实体，应在弱实体的关系表中添加一项属性，也就是其所依赖的实体的标识符（主键）</p><h3 id="实体联系转换参照完整性约束">实体联系转换参照完整性约束</h3><h4 id="“1-1实体联系”转换表示">“1:1实体联系”转换表示</h4><p>将其中任意一个实体的主键放入另一个实体中做外键</p><h4 id="“1-N实体联系”转换表示">“1:N实体联系”转换表示</h4><p>两个实体分别转换为关系表，然后将父实体关系表的主键放入子实体关系表中做外键，便可将1:N实体联系转换为关系表参照完整性约束。</p><h4 id="“M-N实体联系”转换表示">“M:N实体联系”转换表示</h4><p>M:N实体联系不能像1:1和1:N实体联系那样直接转换。需要创建一个新的关联表，该关联表分别参照原有实体对应的关系表。（新的关系表中存放两个关系表的主键，在这个新关系表中，它们既是主键又是外键）</p><h3 id="实体继承联系转换参照完整性约束">实体继承联系转换参照完整性约束</h3><p>当带有实体继承联系的E-R模型转换关系模型时，首先父实体和子实体都各自转换为表，其属性均转换为表的列，然后将父表中的主键放置到子表中，既做主键又做外键。</p><h3 id="实体递归联系转换参照完整性约束">实体递归联系转换参照完整性约束</h3><h4 id="“1-N实体递归联系”的转换">“1:N实体递归联系”的转换</h4><p>首先将递归实体转换为表，其属性转换为列，标识符转换为主键，同时还将标识符转换为外键，实现自己对自己的参照。<br><img src="/post-img/Pasted image 20230826202931.png" alt="图片损坏" style="zoom:100%;" /></p><h4 id="“M-N实体递归联系”的转换">“M:N实体递归联系”的转换</h4><p>增加一个关联表，该表分别参照原实体对应的关系表，并对原关系表建立两个参照完整性约束。<br><img src="/post-img/Pasted image 20230826203032.png" alt="图片损坏" style="zoom:100%;" /></p><h1>数据库规范化设计</h1><p>1.减少数据库中的冗余数据，尽量使同一数据在数据库中仅保存一份，有效降低维护数据一致性的工作量。<br>2.设计合理的表间依赖关系和约束关系，便于实现数据完整性和一致性。<br>3.设计合理的数据库结构，便于系统对数据高效访问处理。<br>非规范数据关系在数据操作中出现的问题：<br>不规范的关系表可能存在数据冗余，引出数据访问操作异常现象，难以使数据库保持数据的一致性。</p><h2 id="函数依赖">函数依赖</h2><p>定义：设有一关系模式R（U）， U 为关系R的属性集合，X和Y为属性U的子集。设t，s是关系R中的任意两个元组，如果t[X] = s[X]，则t[Y] = s[Y]。那么称Y函数依赖于X，表示为X→Y。<br>函数依赖的左部称为决定因子，右部称为依赖函数。决定因子和依赖函数都是属性的集合。<br>理解：比如说一个实体有五个属性A,B,C,D,E,其中A,B是候选键（A，B任意一个可以指明这个实体，从而得到它的所有属性，这时X包含A或B，则Y中的任一元素均能被A推出，则Y函数依赖于X）<br>函数依赖反映属性或属性组之间相互依存、互相制约的关系，即关系表中属性之间的依赖关系。</p><h3 id="完全函数依赖和部分函数依赖">完全函数依赖和部分函数依赖</h3><p>X能推出Y，但X的任意子集不能推出Y，则Y完全依赖于X，否则Y部分依赖于X<br>这表明这个关系模式的实体应该是复合键</p><h3 id="属性传递依赖">属性传递依赖</h3><p>设X、Y、Z是某关系的不同属性集，有X→Y，Y推不出X， Y→Z，若X→Z，称Z对X存在函数传递依赖。</p><h3 id="多值传递依赖">多值传递依赖</h3><p>设U是关系模式R的属性集，X和Y是U的子集，Z=U-X-Y，xyz表示属性集XYZ的值。对于R的关系r，在r中存在元组（x, y1, z1）和（x, y2, z2）时，也存在元组（x, y1, z2）和（x, y2, z1），那么在模式R上存在多值函数依赖。<br>例  对于教学关系R（课程, 教师, 课程参考书），一门课程可以有多个任课教师，也可以有多本参考书；每个任课教师可以任意选择他的参考书。该关系存在多值函数依赖。</p><h2 id="关系规范化范式">关系规范化范式</h2><p>关系规范化是把一个有访问异常的关系分解成结构良好的关系的过程，使得这些关系有最小的冗余或没有冗余。<br>规范化范式（Normal Form，NF）是指关系表符合特定规范化程度的模式。</p><h3 id="第一范式">第一范式</h3><p>如果关系表中的属性不可再细分，该关系满足第1范式。反之，该表就不是关系表。</p><h3 id="第二范式">第二范式</h3><p>如果关系满足第1范式，并消除了关系中的属性部分函数依赖，该关系满足第2范式。<br>有一个关系（A,B,N,O,P）,其复合主键为（A,B）,那么N,O,P这三个非键属性都不存在只依赖A或只依赖B情况，则该关系满足第2范式,反之,不满足第2范式。</p><h3 id="第三范式">第三范式</h3><p>如果关系满足第2范式，并切断了关系中的属性传递函数依赖，该关系满足第3范式。<br>若有一个关系（A,N,O,P）,主键为（A）,那么非键属性N,O或P都不能由单个的N,O或P或它们的组合所确定。该关系满足第3范式。</p><h3 id="巴斯-科德范式（BCNF）">巴斯-科德范式（BCNF）</h3><p>在关系中，所有函数依赖的决定因子都是候选键，该关系满足BCNF范式。<br>关系STUDENT(StudentNum, Name, Email)中，决定因子StudentNum也是候选键，该关系满足BCNF范式。</p><h3 id="第四范式">第四范式</h3><p>如果关系满足BCNF范式，并消除了多值函数依赖，该关系满足第4范式。<br>设学校中某一门课程由多个教师讲授，每个教师可有自己的参考书。用关系模式Teaching（Course，Teacher，Book）来表示课程、教师和参考书之间的关系。 该关系Teaching（Course，Teacher，Book），属于BCNF范式；但是存在多值函数依赖，即不满足4NF。<br>将原表进行分解处理，可分解为Teaching（TeachID，CourseID，TeacherID，BookID）、Course（CourseID，CourseName）、 Teacher（TeacherID，TeacherName）、Book（BookID，BookName）后，即可消除多值依赖，便可满足4NF范式。</p><h2 id="关系规范化程度利弊">关系规范化程度利弊</h2><p>关系的规范化程度越高，关系数据库存储的冗余数据就越少，可消除的数据访问异常就越多。<br>不过关系的规范化程度越高，分解出来的关系表就越多，但实现数据查询访问时，需关联多表，其效率降低。</p><h2 id="逆规范化处理">逆规范化处理</h2><p>所谓逆规范化，就是适当降低规范化范式约束，不再要求一个关系表必须达到很高的规范化程度，而是允许适当的数据冗余性，以获取数据访问性能。<br>逆规范化处理的基本方法：<br>（1）增加冗余列或派生列<br>（2）多个关系表合并为一个关系表</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关系模型</title>
      <link href="/posts/a3d48093.html"/>
      <url>/posts/a3d48093.html</url>
      
        <content type="html"><![CDATA[<h1>基本概念</h1><h2 id="关系模型的提出">关系模型的提出</h2><p>IBM的研究员E.F.Codd博士<br>关系模型以关系代数理论为数学基础，将数据操作抽象为关系处理，其关系表结构简单，便于理解和访问。关系模型在当今几乎所有商业数据库中得到广泛应用。</p><h2 id="实体与关系">实体与关系</h2><p>实体（entity）——是指包含有数据特征的事物对象在概念模型世界中的抽象名称。<br>关系（relation）——是指具有关系特征、用于存放实体数据的二维表。关系也常被称为关系表。<br>在关系模型中，使用“关系”来存储“实体”中的数据。</p><h2 id="关系特征">关系特征</h2><p>表中每行存储实体的一个实例数据<br>表中每列包含实体的一项属性数据<br>表中单元格只能存储单个值<br>不允许有重复的行<br>不允许有重复的列<br>列顺序可任意<br>行顺序可任意</p><h2 id="关系的数学定义">关系的数学定义</h2><img src="/post-img/Pasted image 20230826193526.png" alt="图片损坏" style="zoom:100%;" /><h1>关系的基本概念</h1><h2 id="键（复合、候选、主键、代理）">键（复合、候选、主键、代理）</h2><p>在关系中，可以用来唯一标识元组的属性列，称为键（Key），其它属性列都为非键列。<br>复合键（Compound Key）——是指关系中用来唯一标识元组的多列作为键。<br>候选键（Candidate Key）——关系中可能有多个列均适合作为键，将其中每个都称为候选键。<br>主键（Primary key）是关系表中最有代表性的一个候选键，每个关系表中只能定义一个主键。<br>主键作用：<br>唯一标识关系表的每行（元组）<br>与关联表的外键建立联系，实现关系表之间连接<br>数据库文件使用主键值来组织关系表的数据存储<br>数据库使用主键索引快速检索数据<br>代理键——采用DBMS自动生成的数字序列作为关系表的主键，可替代复合主键，以便获得更高性能的数据访问操作处理。</p><h2 id="关系模式语句表述">关系模式语句表述</h2><img src="/post-img/Pasted image 20230826193748.png" alt="图片损坏" style="zoom:100%;" />如EMPLOYEE (EmployeeNumber,FirstNmae,LastName,Department,Email,Phone)<h1>关系模型原理</h1><p>关系模型（Relation Model）——是一种基于二维表结构存储数据实体及实体间联系的数据模型。</p><h2 id="数据结构（二维表）">数据结构（二维表）</h2><h2 id="数据操作">数据操作</h2><p>集合运算操作包括选择（select）、投影（project）、连接（join）、交（intersection）、并（union）、差（difference）等。<br>专门针对元组的关系操作包括数据行插入（Insert）、 修改（Update）、删除（Delete）操作。</p><h2 id="数据关系约束">数据关系约束</h2><p>在关系模型中，数据关系约束是指关系表中实体数据完整性、关联表之间数据一致性等要求，一般由业务需求来确定。<br>在关系模型中，可定义关系表的数据约束如下：<br>属性列取值类型<br>属性列取值范围<br>属性列取值是否唯一<br>属性列是否允许空值<br>关联表的参照完整性约束</p><h2 id="数据操作-2">数据操作</h2><p>关系模型数据操作采用基于关系代数的数据操作，包括传统的集合运算操作和专门的关系运算操作。<br>1.<strong>关系并运算∪</strong>的结果集是由属于R或属于S的所有元组组成，前提是关系R与关系S需有相同属性组成。<br>2.<strong>关系差运算</strong>-的结果集是由属于R，而不属于S的所有元组组成，前提是关系R与关系S需有相同属性组成。<br>3.<strong>关系交运算</strong>∩的结果集是由既属于R又属于S的所有元组组成，前提是关系R与关系S需有相同属性组成。<br>4.<strong>笛卡儿积运算</strong>的结果集是由所有属于R的元组与所有属于S的元组进行组合而成。</p><h2 id="完整性约束">完整性约束</h2><h2 id="关系模型完整性约束">关系模型完整性约束</h2><p>关系模型完整性是指在关系数据模型中对关系实施的完整性约束。<br>完整性约束作用：<br>消除关系表的元组重复存储<br>保持关联表的数据一致性<br>实现业务数据规则</p><h3 id="实体完整性约束（主键应非空且唯一）">实体完整性约束（主键应非空且唯一）</h3><p>实体完整性是指在关系表中实施的主键取值约束，以保证关系表中的每个元组可以被唯一标识。<br>1.每个关系表中的主键属性列都不允许为空值（NULL），否则就不可能标识实体。<br>2.现实世界中的实体是靠主键来标识，主键取值应该唯一，并区分关系表中的每个元组。</p><h3 id="参照完整性约束（主键与外键一致）">参照完整性约束（主键与外键一致）</h3><p>参照完整性是指关系表之间需要遵守的数据约束，以保证关系之间关联列的数据一致性。<br>若关系R中的外键F与关系S中的主键K相关联，则R中外键F值必须与S中主键K值一致。<br>外键（Foreign key）——在关联的两个关系中，它们具有一个或多个相同属性。若关联列在第一个关系中作为主键，则在第二个关系中作为外键。</p><h3 id="用户自定义完整性约束">用户自定义完整性约束</h3><p>用户自定义完整性是指用户根据具体业务对数据处理规则要求所定义的数据约束。<br>1.定义列的数据类型与取值范围<br>2.定义列的缺省值<br>3.定义列是否允许取空值<br>4.定义列取值唯一性<br>5.定义列之间的数据依赖性</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收</title>
      <link href="/posts/72f47432.html"/>
      <url>/posts/72f47432.html</url>
      
        <content type="html"><![CDATA[<h1>分类</h1><ol><li><strong>Minor GC（年轻代垃圾回收）:</strong><ul><li>针对年轻代（Young Generation）进行垃圾回收</li><li>当年轻代满时触发（通常由Eden区满、S0或S1区满触发）</li><li>垃圾对象相对较少，停顿时间较短。存活对象会被移到年老代。</li></ul></li><li><strong>Major GC（主要垃圾回收）:</strong><ul><li>Major GC 这个术语在Java中并不是一个官方的术语，有时也被用来指代Full GC。</li><li>有时人们使用 “Major GC” 来表示一次垃圾回收中涉及老年代的部分，即Full GC中清理老年代的过程。</li></ul></li><li><strong>Full GC（完全垃圾回收或老年代垃圾回收）:</strong><ul><li>针对整个堆（包括年轻代和老年代）进行垃圾回收。</li><li>当年轻代和老年代都满时触发，也可能由永久代（jdk7）满触发。</li><li>清理的范围更广，涉及整个堆。通常停顿时间相对较长。</li></ul></li></ol><h1>垃圾回收算法</h1><h2 id="标记-清除算法（Mark-and-Sweep）">标记-清除算法（Mark and Sweep）</h2><ul><li><strong>标记阶段：</strong> 从根节点开始，通过可达性分析标记所有能够被访问到的对象。</li><li><strong>清除阶段：</strong> 通过遍历整个堆，清除未被标记的对象，即垃圾对象。</li><li><strong>优点：</strong> 简单，容易实现。不需要移动对象。</li><li><strong>缺点：</strong> 产生内存碎片。 暂停时间较长。</li></ul><h2 id="复制算法（Copying）"><strong>复制算法（Copying）</strong></h2><ul><li>将堆分为两个区域，每次只使用其中一个。将存活的对象从一个区域复制到另一个区域。清理当前区域的所有对象。</li><li><strong>优点：</strong> 无内存碎片。适用于小对象，存活对象较少的场景（新生代）。</li><li><strong>缺点：</strong> 需要额外的空间。需要复制对象，移动开销较大。</li></ul><h2 id="标记-整理算法（Mark-and-Compact）"><strong>标记-整理算法（Mark and Compact）</strong></h2><ul><li>标记可达对象，将存活对象向一端移动，然后清理未标记的区域。</li><li><strong>优点：</strong> 无内存碎片。相较于复制算法，减少了对象复制的开销。</li><li><strong>缺点：</strong> 移动对象可能导致引用更新的复杂性。暂停时间相对较长。</li></ul><h2 id="分代回收算法（Generational）"><strong>分代回收算法（Generational）:</strong></h2><ul><li>将堆分为年轻代和老年代。大部分对象在年轻代被快速回收，少部分晋升到老年代。</li><li><strong>优点：</strong> 利用了对象的生命周期不同的特性，针对不同年代使用不同的垃圾回收策略。</li><li><strong>缺点：</strong> 需要额外的管理。不能解决所有的垃圾回收问题。</li></ul><h1>垃圾回收器</h1><ol><li><strong>Serial</strong> Garbage Collector:（串行垃圾回收器）<ul><li>单线程执行，适用于小型应用或测试环境。</li></ul></li><li><strong>Parallel</strong> Garbage Collector:<ul><li>多线程执行，充分利用多核处理器。</li><li>在新生代使用并行垃圾回收器，老年代使用串行垃圾回收器。</li></ul></li><li><strong>Concurrent Mark-Sweep (CMS)</strong> Garbage Collector:<ul><li>主要用于老年代的垃圾回收。</li><li>在标记和清理阶段允许与应用程序线程并发执行，目标是<strong>最小停顿时间</strong>。</li></ul></li><li><strong>Garbage First（G1）</strong> Garbage Collector:<ul><li>适用于大堆内存，具有低停顿时间的需求。</li><li>将堆划分为多个区域（region），通过并行和并发阶段实现垃圾回收。</li></ul></li></ol><h1>CMS</h1><p>四阶段：<strong>初始标记，并发标记，重新标记，并发清除</strong><br>其中第一、三阶段需要STW（stop the world，暂停用户线程）</p><ol><li>初始标记：标记所有直接被GCroot关联的对象，速度比较快</li><li>并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，耗时较长，但是是并发执行，不需要暂停用户线程</li><li>重新标记：修正并发标记期间,因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要STW，但时间不会太长</li><li>并发清除：清理删除掉标记阶段判定的已经死亡的对象,释放内存空间，不需要移动存活对象,可以与用户线程同时并发（产生内存碎片）<br>由于最耗费时间的并发标记与并发清除阶段都是不需要暂停用户线程的,所以整体的回收是低停顿的</li></ol><h1>G1</h1><p>回收步骤与CMS相似，<strong>初始标记，并发标记，最终标记，筛选回收</strong><br>重要概念和特点：</p><ol><li>区域（region）：把堆内存分割为很多不相关的区域(Region)(物理上不连续)，所有region均可以用来当作eden，survivor，old，humongous（存储大对象）（<strong>区域化内存布局</strong>）</li><li>Region之间是复制算法（从若干个rigion回收融合到一个region）,但整体上实际可看作是标记-整理算法</li><li>G1除了追求低停顿外,还能建立可预测的停顿时间模型,能让使用者明确指定在一个长度为M毫秒的时间片段内,消耗在垃圾收集上的时间不得超过N毫秒（<strong>可预测停顿时间</strong>），因为会优先回收价值高的region（<strong>垃圾优先</strong>）</li><li>可以只选取部分区域进行内存回收,这样缩小了范围,因此对于全局停顿情况的发生也能得到较好的控制，可以进行<strong>混合回收</strong>，同时处理新生代和老年代</li><li><strong>并行和并发</strong>执行垃圾回收操作，并行加快标记和复制的速度，并发减少垃圾回收对应用程序的停顿时间</li></ol><h1>补充</h1><h2 id="关于GC-root">关于GC root</h2><p>GCroot（垃圾收集根）是指一组对象，这些对象被认为是在垃圾收集时安全的，不会被垃圾收集器回收。垃圾收集根是整个对象图的起始点，垃圾收集器通过这些根对象能够追踪到其他对象的引用链，从而确定哪些对象是可达的，哪些是不可达的，进而进行垃圾回收。<br>以下是一些常见的 GCroot 类型：</p><ol><li><strong>栈中的局部变量和输入参数：</strong><ul><li>方法中的局部变量和输入参数，以及调用方法时传递的参数，都是GCroot。这是因为它们是程序执行的起点。</li></ul></li><li><strong>静态变量（类变量）：</strong><ul><li>存储在静态变量中的对象也是GCroot，因为它们随着类的加载而存在，不依赖于特定的实例。</li></ul></li><li>JNI 引用：<ul><li>通过 Java Native Interface (JNI) 创建的引用，允许 Java 代码访问和调用本地库的接口。JNI 引用也是 GCroot。</li></ul></li><li>活动的线程：<ul><li>正在运行的线程本身也是 GCroot，因为它们持有一些对象的引用，而这些引用不能被垃圾收集。</li></ul></li><li>Finalizer 引用：<ul><li>当一个对象的finalize()方法被调用时，这个对象是 GCroot，因为在finalize()方法中可能会重新建立对象的引用关系。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM组成部分</title>
      <link href="/posts/c1464964.html"/>
      <url>/posts/c1464964.html</url>
      
        <content type="html"><![CDATA[<h1>组成架构</h1><h2 id="类加载器">类加载器</h2><p>类加载器是用于加载编译后的<code>class</code>文件的，但它只负责将符合格式要求的<code>class</code>字节码信息加载进内存，而只要符合格式规范的<code>class</code>文件都能被加载，至于加载进入的<code>class</code>文件到底是否能执行就并不是它负责的了，这是执行引擎子系统的范围之内的责任。</p><h3 id="分类">分类</h3><ol><li><strong>启动类加载器</strong>（bootstrap）：使用C++语言实现，是JVM自身的一部分，主要负责将<code>&lt;JAVA_HOME&gt;\lib</code>路径下的核心类库或<code>-Xbootclasspath</code>参数指定的路径下的jar包加载到内存中。只为JVM提供加载服务，开发者不能直接使用它来加载自己的类。</li><li><strong>扩展类加载器</strong>（extention）：主要负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录下或者由系统变量<code>-Djava.ext.dir</code>指定位路径中的类库。它可以直接被开发者使用。</li><li><strong>应用类加载器</strong>（application）：负责加载系统类路径<code>java -classpath</code>或<code>-D java.class.path</code>指定路径下的类库，也就是经常用到的<code>classpath</code>路径。应用程序类加载器也可以直接被开发者使用。一般情况下，该类加载器是程序的默认类加载器，我们可以通过ClassLoader.getSystemClassLoader()方法可以直接获取到它。</li><li><strong>自定义类加载器</strong>（user）：在Java程序中，运行时一般都是通过如上三种类加载器相互配合执行的，如果有特殊的加载需求也可以自定义类加载器，通过继承<code>ClassLoader</code>类实现。</li></ol><h3 id="双亲委派模型">双亲委派模型</h3><p>各加载器之间是<strong>层级引用关系</strong>，而非继承或包含关系，当一个类加载器需要加载类时，它首先会委托给父加载器加载。这种委托的关系使得加载器之间形成了一种树状结构，即<strong>启动类加载器-&gt;扩展类加载器-&gt;应用类加载器-&gt;自定义类加载器</strong>。例如：虽然<strong>扩展类加载器不是启动类加载器的直接子类</strong>，但由于委托关系，可以说扩展类加载器在某种程度上扮演了启动类加载器的子加载器角色。这种委托是<strong>双亲委派</strong>思想的体现，即：<strong>向上委托，向下加载</strong></p><ul><li>自下向上检查类是否已经被加载</li><li>从上至下尝试加载类<br>作用：</li></ul><ol><li>避免重复加载</li><li>保障Java核心类的安全性问题</li></ol><h3 id="打破双亲委派模型">打破双亲委派模型</h3><h4 id="线程上下文类加载器">线程上下文类加载器</h4><p>线程上下文类加载器（Thread Context ClassLoader）允许在运行时动态地为线程设置类加载器。<br>最典型的应用场景是Java的SPI机制，位于<code>rt.jar</code>包中的SPI接口，是由Bootstrap类加载器完成加载的，在SPI接口中，会经常调用实现者的代码，所以一般会需要先去加载自己的实现类，但实现类并不在Bootstrap类加载器的加载范围内，而是位于<code>classpath</code>路径下，应该由<code>App</code>类加载器进行加载，此时就必须使用线程上下文类加载器来打破双亲委派规则。当父加载器无法完成类加载工作，会将其直接交由线程上下文类加载来进行加载。而通常<code>App</code>类加载器会被设置为默认的线程上下文类加载器。</p><h4 id="重写loadClass方法">重写loadClass方法</h4><p>无论是<code>ExtClassLoader</code>还是<code>AppClassLoader</code>加载器，其本身都未打破<code>ClassLoader.loadClass()</code>方法中定义的双亲委派逻辑，<code>Bootstrap、Ext、App</code>这些JVM自带的类加载器都默认会遵守双亲委派模型。<br>因此若想打破双亲委派模型，可以实现自定义类加载器，并重写loadClass方法</p><h3 id="类加载过程">类加载过程</h3><ol><li><strong>加载</strong>：加载阶段是指通过完全限定名查找Class文件二进制数据并将其加载进内存的过程。大体流程会分为三步：<ul><li>通过完全限定名查找定位<code>.class</code>文件，并获取其二进制字节流数据</li><li>把字节流所代表的<strong>静态存储结构转换为运行时数据结构</strong></li><li>在<strong>堆</strong>中间中为其创建一个<code>Class</code>对象，作为程序访问这些数据的入口</li></ul></li><li><strong>连接</strong>：连接步骤包含了验证、准备、解析三个阶段。这三个阶段中，前两个执行顺序是确定的，但解析阶段不一定，可能会发生在初始化之后。<ul><li><strong>验证：</strong> 验证确保被加载的类的正确性，包括文件格式的验证、元数据的验证、字节码的验证等。</li><li><strong>准备：</strong> 在准备阶段，类加载器为<strong>类的静态变量</strong>分配内存，并设置<strong>默认初始值</strong>（不是在代码中赋的值）。这里的静态变量是指类的成员（static修饰），但不包含final修饰，因为<code>final</code>在编译的时候就会分配了，准备阶段会显示初始化。</li><li><strong>解析：</strong> 解析阶段是虚拟机将类的符号<strong>引用转换为直接引用</strong>的过程，这个过程可能在初始化阶段之前或之后。</li></ul></li><li><strong>初始化</strong>：在初始化阶段，类加载器执行类的初始化代码，包括对静态变量的赋值和执行静态块中的代码。</li><li>使用：当一个类完整的经过了类加载过程之后，在内存中已经生成了Class对象，同时在Java程序中已经通过它开始创建实例对象使用时，该阶段被称为使用阶段。</li><li>卸载：当一个Class对象不再被任何一处位置引用，即不可触及时，Class就会结束生命周期，该类加载的数据也会被卸载。Java虚拟机自带的类加载器加载的类，在虚拟机的生命周期中始终不会被卸载。</li></ol><h3 id="类加载的时机">类加载的时机</h3><p>类加载器在以下情况下会触发类的加载：</p><ul><li>当创建类的实例对象时，也就是使用<code>new</code>关键字。</li><li>当调用类的静态方法时。</li><li>当访问类的静态字段（被<code>final</code>修饰、已在编译期把结果放入常量池的静态字段除外）时。<br>需要注意的是，类的加载是<strong>懒汉式</strong>的，即只有在需要使用类的时候才会加载。</li></ul><h2 id="执行引擎">执行引擎</h2><p>执行引擎子系统担任着JVM的“翻译官”角色，它负责将加载进内存的<code>class</code><strong>字节码指令“翻译”成机器语言</strong>交由硬件执行。而字节码可以通过解释器和即使编译器两种途径转换为机械指令。<code>HotSpot</code>虚拟机中，采用的便是<strong>解释器+即时编译器</strong>混合执行的工作模式。</p><h2 id="运行时数据区">运行时数据区</h2><p>运行时数据区是整个JVM中的重点，开发者编写的所有代码最终都会被加载在这里之后再开始执行。Java运行时数据区主要可分为PC程序计数器、本地方法栈、虚拟机栈、元数据空间(方法区)以及堆空间五大区域，<strong>其中堆空间和方法区是线程共享的，而程序计数器，本地方法栈和虚拟机栈则是线程私有的</strong>。</p><h3 id="堆">堆</h3><ul><li>Java堆是Java虚拟机管理的最大的一块内存区域，被所有线程共享。</li><li>在Java程序运行时，系统运行过程中产生的大部分实例对象以及数组对象都会被放到堆中存储。</li><li>对于JVM来说，堆空间是唯一的，每个JVM只会存在一个堆空间，同时容量大小会在创建时就被确定，但可以通过参数<code>-Xms</code> 和<code>-Xmx</code>指定堆的起始内存大小和最大内存大小。</li><li>一般所说的新生代、老年代、永久代是一种逻辑上的说法（1.8前物理也分代）。</li><li>本质上来说，Java堆结构是跟JVM运行时所使用的垃圾回收器息息相关的，由GC器决定了运行时的堆空间会被划分为何种结构。</li></ul><h3 id="方法区（元数据空间）">方法区（元数据空间）</h3><ul><li>方法区（Method Area），也称为元数据空间（Metadata Space），是 Java 虚拟机的内存区域之一，用于<strong>存储类的结构信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。</li><li>方法区在 Java 虚拟机的内存模型中是一个逻辑上的概念，它不一定要求在实现中与堆区分配在物理上是不同的内存空间。</li><li>方法区在不同的 Java 虚拟机实现中可能有所不同，有些虚拟机可能会将方法区中的部分数据存储在堆区或其他内存区域中。</li><li>方法区的<strong>大小是有限制</strong>的，在一些情况下可能会出现内存溢出（Out of Memory）的错误。</li></ul><h3 id="虚拟机栈">虚拟机栈</h3><ul><li>生命周期与线程相同</li><li>每个方法的执行都会创建一个栈帧，用于存储<strong>局部变量表、操作数栈、动态链接、方法出口</strong>等信息。</li><li>栈帧的大小在编译时就已经确定，因此在栈上分配的内存是确定的。</li></ul><h3 id="程序计数器">程序计数器</h3><ul><li>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。生命周期与线程一致，随线程启动而生，线程销毁而亡。</li><li>是JVM所有内存区域中唯一不会发生OOM的区域，GC机制不会触及的区域。</li><li>在多线程环境下，每个线程都有一个独立的程序计数器，互不影响，用于记录各自线程执行的位置。</li><li>当线程执行一个Java方法时，记录线程正在执行的字节码指令地址，当执行引擎处理完某个指令后，程序计数器需要进行对应更新，将指针改向下一条要执行的指令地址，执行引擎会根据PC计数器中记录的地址进行对应的指令执行。</li><li>当线程在执行一些由<code>C/C++</code>编写的<code>Native</code>方法时，PC计数器中则为空（<code>Undefined</code>）。</li><li>保证线程发生CPU时间片切换后能恢复到正确的位置执行。</li></ul><h3 id="本地方法栈">本地方法栈</h3><ul><li>本地方法栈类似于Java虚拟机栈，但是为本地方法服务。</li><li>本地方法栈也是线程私有的，用于存储本地方法（由Native关键字修饰的方法）的信息。</li><li>当开始执行一个本地方法时，就会进入不再受虚拟机限制的环境，级别与虚拟机一样，可以直接访问JVM的任何内存区域，也可以直接使用CPU处理器的寄存器和本地内存等。本地方法栈只是存储了线程要运行这个方法的必要信息。</li></ul><h2 id="本地方法接口和本地方法库">本地方法接口和本地方法库</h2><p>本地方法接口的作用主要是为了融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。因为在Java诞生时，正是C语言横行的时候，要想立足就必须要有一个能够调用C代码的模块，于是就专门在内存中开辟了一块区域处理标记为native的方法。简而言之，本地方法接口就是一个Java调用非Java代码的接口，这个非Java代码一般泛指C语言所编写的本地方法库中的函数。</p><h1>补充</h1><h2 id="符号引用与直接引用">符号引用与直接引用</h2><p>符号引用到直接引用的转换是为了在程序运行时能够快速访问到目标，提高执行效率。这个过程发生在类加载的链接阶段，确保在程序执行时能够正确地调用类的方法和访问类的字段。</p><h3 id="解释">解释</h3><p><strong>符号引用：</strong> 符号引用是一种编译时的引用，它以一种符号形式来表示目标，而不直接指向目标。在Java中，符号引用可以是类和接口的全限定名、字段的名称和描述符、方法的名称和描述符等。<br><strong>直接引用：</strong> 直接引用是可以直接指向目标的引用，相对于符号引用，它是在虚拟机加载类的过程中将符号引用转换而来的。直接引用可以是指向方法区的指针、指向堆中对象的指针、直接存储常量值等。</p><h3 id="符号引用转换为直接引用的过程">符号引用转换为直接引用的过程</h3><ol><li>在链接的解析阶段，虚拟机将符号引用转换为直接引用。解析主要有两种方式：静态解析和动态解析。</li><li><strong>静态解析：</strong><ul><li>静态解析是在编译期间完成的，通过类加载器进行。</li><li>对于一些被<code>final</code>修饰的静态变量，编译期已经确定了其值，可以直接将符号引用转换为常量值。</li></ul></li><li><strong>动态解析：</strong><ul><li>动态解析是在运行期间完成的，主要针对方法和字段的动态调用。</li><li>虚拟机会根据类的方法表或字段表在运行时动态地解析符号引用，转换为直接引用。</li><li>动态解析的过程可以涉及到方法的动态绑定（多态）等机制。</li></ul></li></ol><h3 id="举例">举例</h3><p>考虑一个方法调用的过程，例如 <code>obj.method()</code>，其中 <code>obj</code> 是一个对象引用，<code>method</code> 是一个方法的符号引用。在解析阶段，虚拟机会将这个符号引用转换为实际的方法地址，这个地址就是直接引用。这个转换的过程涉及到动态绑定，即根据实际类型来确定调用哪个版本的方法。</p><h2 id="自定义类加载器的作用">自定义类加载器的作用</h2><ul><li>当<code>class</code>文件不在<code>classpath</code>路径下时，需要自定义类加载器加载特定路径下的<code>class</code></li><li>当一个<code>class</code>文件是通过网络传输过来的并经过了加密处理，需要首先对<code>class</code>文件做了对应的解密处理后再加载到内存中时，需要自定义类加载器</li><li>线上环境不能停机时，要动态更改某块代码，这种情况下需要自定义类加载器。比如：当需要实现热部署功能时(一个class文件通过不同的类加载器产生不同class对象从而实现热部署功能)</li></ul><h2 id="虚拟机栈中栈帧的组成">虚拟机栈中栈帧的组成</h2><ol><li><strong>局部变量表（Local Variable Table）</strong>：<ul><li>局部变量表用于存储方法中的局部变量和参数。每个局部变量在局部变量表中占据一个槽位（Slot），槽位的大小可以是 32 位或 64 位，取决于局部变量的数据类型。</li><li>局部变量表从索引为 0 的位置开始，按顺序存储方法的参数和局部变量。</li></ul></li><li><strong>操作数栈（Operand Stack）</strong>：<ul><li>操作数栈用于存储方法执行过程中的操作数和中间结果。当方法调用一个操作时，操作数栈用于传递参数和保存临时数据。</li><li>操作数栈是一个后进先出（LIFO）的数据结构，可以执行各种运算指令，如加减乘除等。</li></ul></li><li><strong>动态链接（Dynamic Linking）</strong>：<ul><li>动态链接用于在运行期间解析调用方法的引用。每个栈帧都包含一个指向运行期常量池中该方法的符号引用的指针，用于动态链接。</li></ul></li><li><strong>方法出口（Return Address）</strong>：<ul><li>方法出口存储了方法执行完毕后返回的地址。当方法执行结束时，程序将跳转到方法出口所指向的地址，继续执行接下来的指令。</li></ul></li></ol><h2 id="方法区包含的主要内容">方法区包含的主要内容</h2><ol><li><strong>类的结构信息</strong>：<ul><li>方法区存储了加载的类的结构信息，包括类的字段、方法、构造方法等信息，以及方法的字节码等。</li></ul></li><li><strong>运行时常量池</strong>：<ul><li>方法区中包含每个类的运行时常量池，用于存储编译时生成的各种字面量（如字符串、数字）、符号引用（如类和方法的引用）等信息。</li></ul></li><li><strong>静态变量</strong>：<ul><li>方法区存储了类的静态变量，即被 static 修饰的成员变量，这些变量在程序运行期间只会被初始化一次，并且在整个程序生命周期内都可以被访问。</li></ul></li><li><strong>即时编译器编译后的代码</strong>：<ul><li>方法区还存储了即时编译器（JIT Compiler）编译后的本地机器代码（Native Code），这些代码用于执行经过优化的方法。</li></ul></li></ol><h2 id="堆的分代结构">堆的分代结构</h2><ul><li>JDK7及之前：堆空间包含新生代、年老代以及永久代。</li><li>JDK8：堆空间包含新生代和年老代，永久代被改为元数据空间，位于堆之外。</li><li>JDK9：堆空间从逻辑上保留了分代的概念，但物理上本身不分代。</li><li>JDK11：堆空间从此以后逻辑和物理上都不分代。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql索引</title>
      <link href="/posts/71014c5a.html"/>
      <url>/posts/71014c5a.html</url>
      
        <content type="html"><![CDATA[<h1>分类</h1><h2 id="按物理结构">按物理结构</h2><p>在 B+ 树的索引中，叶子节点可能存储了当前的键值，也可能存储了当前的键值以及整行的数据，这就是聚簇索引和非聚簇索引。 在 InnoDB 中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。</p><ol><li><strong>聚簇索引</strong>指索引的键值的逻辑顺序与表中相应行的物理顺序一致，即每张表只能有一个聚簇索引，也就是我们常说的<strong>主键索引</strong></li><li><strong>非聚簇索引</strong>的逻辑顺序则与数据行的物理顺序不一致，通常会需要回表查询</li></ol><h2 id="按数据结构">按数据结构</h2><ol><li><strong>B-Tree 索引</strong>：<ul><li>B-Tree（平衡树）索引是最常见的数据库索引类型。</li><li>它适用于大多数情况，支持等值查询、范围查询和排序操作。</li><li>B-Tree索引对于静态和动态数据都很有效，适用于大多数关系型数据库系统。</li></ul></li><li><strong>B+Tree 索引</strong>：<ul><li>B+Tree索引是B-Tree的变种，常用于关系型数据库系统。</li><li>与B-Tree不同，B+Tree索引中只包含叶子节点，内部节点只用于导航，这使得B+Tree索引更适合范围查询和排序操作。</li></ul></li><li><strong>哈希索引</strong>：<ul><li>哈希索引使用散列函数将索引键映射到存储桶（存储位置），通常用于等值查询。</li><li>哈希索引对于等值查询非常高效，但不支持范围查询和排序操作。</li><li>哈希索引在某些情况下可以提供非常快的查询性能，但不适用于所有场景。</li></ul></li><li><strong>全文索引</strong>：<ul><li>全文索引用于搜索文本数据，如文章、博客帖子或文档。</li><li>它支持文本内容的关键字搜索，允许模糊查询和全文搜索。</li><li>全文索引通常用于全文搜索引擎或数据库系统的全文搜索功能。</li></ul></li></ol><h3 id="Hash和B-树索引的区别">Hash和B+树索引的区别</h3><p>哈希索引适用于等值查询，具有快速的等值查询性能和较小的存储开销。<br>B+树索引更通用，适用于各种查询类型，包括等值查询、范围查询和排序操作，但通常需要更多的存储空间。<br><strong>1. 数据结构：</strong></p><ul><li><strong>哈希索引：</strong> 哈希索引使用哈希函数将索引键映射到存储桶（或槽位）中。每个存储桶可以包含一个或多个具有相同哈希值的索引键。哈希索引将索引键与存储桶之间的关系存储在内存中或磁盘上。</li><li><strong>B+树索引：</strong> B+树索引是一种树状结构，通常是平衡树，包括根节点、内部节点和叶子节点。叶子节点包含了实际的索引键和指向数据行的指针。B+树索引的内部节点用于导航和范围查询。<br><strong>2. 支持的查询类型：</strong></li><li><strong>哈希索引：</strong> 哈希索引主要适用于等值查询，即查找具有特定键值的行。哈希索引不支持范围查询和排序操作，因为它将键映射到离散的存储桶中，无法提供有序的数据访问。</li><li><strong>B+树索引：</strong> B+树索引支持等值查询、范围查询和排序操作。它可以在树结构中按照键值的顺序访问数据，因此非常适合各种查询类型。<br><strong>3. 存储和空间需求：</strong></li><li><strong>哈希索引：</strong> 哈希索引通常需要相对较小的存储空间，因为它将键映射到存储桶，但需要注意，存储桶的数量可能会影响性能。</li><li><strong>B+树索引：</strong> B+树索引通常需要更多的存储空间，因为它包含了更多的数据结构，包括内部节点和叶子节点。但由于其平衡树结构，它能够提供高效的范围查询和排序操作。<br><strong>4. 写操作的性能：</strong></li><li><strong>哈希索引：</strong> 哈希索引对于等值查询的写操作（插入、更新、删除）通常非常高效，因为它可以在常数时间内找到特定键值。但对于范围删除或更新操作，哈希索引可能需要扫描整个索引，性能较差。</li><li><strong>B+树索引：</strong> B+树索引对于等值查询和范围查询的写操作都相对高效，因为它的平衡树结构允许根据键值顺序访问数据。</li></ul><h3 id="B-树和B树的区别">B+树和B树的区别</h3><ol><li>B+ 树<strong>减少了 IO 次数</strong>：<ul><li>由于索引文件很大因此索引文件存储在磁盘上，B+ 树的非叶子结点只存关键字不存数据，因而单个页可以存储更多的关键字，即一次性读入内存的需要查找的关键字也就越多，磁盘的随机 I/O 读取次数相对就减少了。</li></ul></li><li>B+ 树<strong>查询效率更稳定</strong>：<ul><li>由于数据只存在在叶子结点上，所以查找效率固定为 O(log n)，所以 B+ 树的查询效率相比B树更加稳定。</li></ul></li><li>B+ 树<strong>更加适合范围查找</strong>：<ul><li>B+ 树叶子结点之间用链表有序连接，所以扫描全部数据只需扫描一遍叶子结点，利于扫库和范围查询；B 树由于非叶子结点也存数据，所以只能通过中序遍历按序来扫。也就是说，对于范围查询和有序遍历而言，B+ 树的效率更高。</li></ul></li></ol><h3 id="为何使用B-树而非二叉查找树做索引">为何使用B+树而非二叉查找树做索引</h3><ol><li><strong>平衡性和稳定性：</strong><ul><li>B+树是一种自平衡树结构，而二叉查找树的平衡性不如B+树好。B+树的平衡性保证了在插入和删除操作后，树的高度保持相对稳定，从而保持了查询性能的稳定性。而BST的不平衡性可能会导致树的高度大幅增加，从而降低查询性能。</li></ul></li><li><strong>范围查询的效率：</strong><ul><li>B+树非常适合范围查询，因为它的叶子节点构成了一个有序链表，可以轻松执行范围查询操作。而BST需要在不同分支上进行搜索，效率相对较低。</li></ul></li><li><strong>提高磁盘io效率（顺序读取）：</strong><ul><li>B+树的节点通常比BST的节点大，因为它需要存储更多的键值对信息。然而，在磁盘上，顺序读取比随机读取更高效。由于B+树的有序性，磁盘IO更加连续，减少了随机读取，从而提高了磁盘IO效率。</li></ul></li><li><strong>叶子节点的存储（所有数据都存储在叶子节点上）：</strong><ul><li>B+树的叶子节点包含了所有索引数据，而内部节点仅包含索引键和指向子节点的指针。这样的设计使得B+树的叶子节点更适合内存缓存，因为它们通常更小，可以容纳更多的数据。相比之下，BST的所有节点都可能包含数据，会导致内存开销较大。</li></ul></li><li><strong>支持高度扇出（每个节点可以有多个子节点）：</strong><ul><li>B+树支持高度扇出（每个节点有多个子节点），这意味着在相对较低的高度下可以容纳大量数据。这对于大型数据库非常重要，因为它可以减少磁盘IO和提高查询性能。</li></ul></li></ol><h2 id="按应用类型">按应用类型</h2><ol><li>普通索引：MySQL 中的基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了提高查询效率。通过 ALTER TABLE table_name ADD INDEX index_name (column) 创建；</li><li>唯一索引：索引列中的值必须是唯一的，但是允许为空值。通过 ALTER TABLE table_name ADD UNIQUE index_name (column) 创建；</li><li>主键索引：特殊的唯一索引，也成聚簇索引，不允许有空值，并由数据库帮我们自动创建；</li><li>复合索引：组合表中多个字段创建的索引，遵守最左前缀匹配规则；</li><li>全文索引：只有在 MyISAM 引擎上才能使用（innoDB新版本支持），同时只支持 CHAR、VARCHAR、TEXT 类型字段上使用。</li></ol><h1>优缺点</h1><h2 id="优点">优点</h2><ol><li><strong>提高检索速度</strong>：<ul><li>最明显的优点是加速数据检索。索引允许数据库系统更快地定位和访问符合查询条件的数据行，特别是在大型数据表中，查询性能得到显著提升。</li></ul></li><li><strong>支持快速查找</strong>：<ul><li>索引使数据库系统能够在常数时间内快速查找特定值，而不是遍历整个数据表。</li></ul></li><li><strong>排序优化</strong>：<ul><li>索引可以提高排序操作的性能，因为数据库可以使用索引按顺序访问数据。</li></ul></li><li><strong>加速连接操作</strong>：<ul><li>当执行连接操作（例如JOIN）时，索引可以加速数据的匹配过程，提高关联查询的性能。</li></ul></li><li><strong>帮助确保数据完整性</strong>：<ul><li>唯一索引可以确保索引列中的数据唯一性，有助于维护数据完整性。</li></ul></li></ol><h2 id="缺点">缺点</h2><ol><li><strong>存储开销</strong>：<ul><li>索引占用额外的存储空间，因为索引数据结构需要额外的内存和磁盘空间。对于大型数据表，索引可以占据相当大的空间。</li></ul></li><li><strong>更新性能降低</strong>：<ul><li>当插入、更新或删除数据行时，索引需要维护，这可能会导致更新性能下降。每次更新都需要更新索引结构，这会增加写操作的开销。</li></ul></li><li><strong>查询性能下降（部分情况）</strong>：<ul><li>在某些情况下，使用不当的索引或过多的索引可以导致查询性能下降。过多的索引可能会导致查询优化器选择错误的索引，增加了查询的成本。</li></ul></li><li>维护成本：<ul><li>数据库维护索引需要额外的工作，包括创建、重新构建和优化索引。</li></ul></li><li>空间复杂性：<ul><li>对于复杂的查询，涉及多个表和多个索引时，查询优化可能变得复杂，不容易预测性能。</li></ul></li></ol><h1>索引设计原则</h1><ol><li><strong>选择唯一索引</strong>：<ul><li>唯一索引的值是唯一的，可以更快速的通过该索引来确定某条记录。</li><li>主键索引和唯一索引，在查询中使用是效率最高的。</li></ul></li><li><strong>为经常需要排序、分组和联合操作的字段建立索引</strong>：<ul><li>经常需要ORDER BY、GROUP BY、DISTINCT和UNION等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。</li></ul></li><li><strong>为常作为查询条件的字段建立索引</strong>：<ul><li>如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度。因此，为这样的字段建立索引，可以提高整个表的查询速度。</li></ul></li><li><strong>尽量使用前缀来索引</strong>：<ul><li>如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT和BLOG类型的字段，进行全文检索会很浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度。</li></ul></li><li><strong>限制索引的数目</strong>：<ul><li>索引的数目不是越多越好。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。修改表时，对索引的重构和更新很麻烦。越多的索引，会使更新表变得很浪费时间。</li></ul></li><li><strong>尽量使用数据量少的索引</strong>：<ul><li>尽量使用字段长度小的列创建索引。如果索引的值很长，那么查询的速度会受到影响。</li></ul></li><li><strong>删除不再使用或者很少使用的索引</strong>：<ul><li>表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。</li></ul></li></ol><h1>补充</h1><h2 id="最左匹配原则">最左匹配原则?</h2><p>最左匹配原则是数据库索引优化的一个关键概念，它指导数据库系统在使用复合索引（Composite Index）时如何有效地匹配查询条件。<br>在最左匹配原则中，索引的复合键（Composite Key）中的多个列按照索引定义的顺序依次匹配查询条件。具体来说，当执行一个查询，涉及到复合索引的多个列时，数据库系统会首先使用索引的最左边的列来过滤数据，然后再逐渐向右匹配更多的列，直到满足查询条件或者不再匹配。<br>这个原则的关键在于，如果查询条件中涉及到复合索引的多个列，那么只有在最左边的列被用于查询时，索引才会发挥作用。如果最左边的列不在查询条件中，那么索引将无法有效利用。</p><p>举个例子，假设有一个复合索引 (A, B, C)，按照最左匹配原则：</p><ol><li>如果查询条件包括 A，那么索引可以被充分利用。</li><li>如果查询条件包括 A 和 B，那么索引也可以被充分利用。</li><li>如果查询条件包括 A、B 和 C，那么索引仍然可以被充分利用。</li><li>但如果查询条件只包括 B 或者 C，而不包括 A，那么索引将无法有效使用。</li><li>其余情况下（A,C），只有A能走索引而C无法走索引</li></ol><h2 id="覆盖索引">覆盖索引</h2><p>覆盖索引（Covering Index）是一种特殊类型的数据库索引，它包含了查询所需的所有列，而不仅仅是索引键列。当一个查询可以完全通过索引本身满足，而不需要访问实际数据表中的数据行时，就称之为覆盖索引。</p><p>覆盖索引具有以下特点和优点：</p><ol><li><strong>减少磁盘IO：</strong> 因为覆盖索引包含了查询所需的数据列，数据库系统可以直接从索引中获取数据，而无需访问数据表，从而减少了磁盘IO操作。这通常会显著提高查询性能，尤其是在大型数据表上。</li><li><strong>减少内存占用：</strong> 由于覆盖索引通常比完整数据行小，所以可以减少内存使用。这对于数据库缓存的性能有积极影响，因为更多的索引页可以驻留在内存中。</li><li><strong>加速查询速度：</strong> 覆盖索引可以加速查询速度，因为不需要额外的数据检索操作。这对于频繁执行的查询特别有用，如报表查询和分析查询。</li><li><strong>降低锁定的持续时间：</strong> 当查询使用覆盖索引时，需要锁定的数据行较少，因此可以减少锁定的持续时间，提高并发性。</li><li><strong>减少网络开销：</strong> 对于分布式数据库系统，使用覆盖索引可以减少数据传输的网络开销，因为不需要传输完整的数据行，只需要索引和查询的列。</li></ol><h2 id="索引下推">索引下推</h2><p>在不使用索引下推的情况下，在使用非主键索引进行查询时，存储引擎通过索引检索到数据，然后返回给 MySQL 服务器，服务器判断数据是否符合条件。<br>而有了索引下推之后，如果存在某些被索引列的判断条件时，MySQL 服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合 MySQL 服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给 MySQL 服务器。<br>总而言之，就是在进行多条件匹配时，不通过索引下推，引擎层可能会将满足第一个条件的所有行提交给服务器端进行筛选（这个过程可能产生多次回标），而有了索引下推后，服务器端将条件告诉引擎层，在引擎层就可以多匹配到条件，减少服务器端回表查询的次数。<br>索引条件下推优化可以<strong>减少存储引擎查询基础表的次数</strong>，也可以减少 MySQL 服务器从存储引擎接收数据的次数。</p><h2 id="索引的维护">索引的维护</h2><p>索引的维护包括页分裂（Page Split）和页合并（Page Merge）两个主要方面，它们是数据库系统在动态数据增删改的情况下，保持索引结构的平衡和高效的重要手段。</p><ol><li><strong>页分裂（Page Split）</strong>：<ul><li>当一个数据页（Index Page）已满，无法再容纳新的数据时，数据库系统会进行页分裂操作。</li><li>页分裂将满页分成两个新的数据页，以腾出空间来存储新的数据。通常是将数据页中的一部分数据移动到新的数据页中，然后在原页中插入新的数据，保持数据的有序性。</li><li>在 B-Tree 索引结构中，页分裂通常发生在树的中间节点或叶子节点上，以保持树的平衡性。</li></ul></li><li><strong>页合并（Page Merge）</strong>：<ul><li>当一个数据页中的数据删除后，导致页面的利用率过低时，数据库系统可能会进行页合并操作。</li><li>页合并将相邻的两个数据页合并成一个更大的数据页，以提高页面的利用率。通常是将两个数据页中的数据合并到一个新的数据页中，并更新父节点的索引。</li><li>在 B-Tree 索引结构中，页合并通常发生在叶子节点上，以减少索引的层次，提高查询性能。<br>页分裂和页合并是数据库系统中的动态操作，它们根据数据的增删改变化来保持索引结构的平衡和高效。通过合理的页分裂和页合并操作，数据库系统可以在保持索引结构的同时，保持较低的空间开销和高效的查询性能。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal</title>
      <link href="/posts/151f44ae.html"/>
      <url>/posts/151f44ae.html</url>
      
        <content type="html"><![CDATA[<h1>什么是线程安全</h1><p>线程安全（Thread Safety）是指在多线程环境下，一个程序或者代码段能够在<strong>并发</strong>执行的情况下正确地执行，不会产生意外的结果。确保线程安全是多线程编程中一个非常重要的概念，因为在多线程环境下，多个线程可能同时访问和修改共享的数据，如果不进行适当的同步和保护，可能导致数据不一致、不确定的行为或者程序崩溃。</p><h2 id="线程安全的关键点">线程安全的关键点</h2><ol><li><strong>原子性（Atomicity）：</strong> 原子操作是指一个操作是不可中断的，要么全部执行成功，要么全部不执行，不会出现部分执行的情况。在多线程环境下，确保某个操作是原子的可以避免竞态条件（Race Condition）。</li><li><strong>可见性（Visibility）：</strong> 当一个线程对共享变量进行了修改，其他线程应该能够立即看到这个修改。Java中使用<code>volatile</code>关键字可以保证变量的可见性。</li><li><strong>有序性（Ordering）：</strong> 确保指令执行的顺序按照程序的顺序来执行。在Java中，通过synchronized关键字、Lock接口等机制可以保证代码块的有序性。</li><li><strong>不变性（Immutability）：</strong> 使用不可变对象或者通过其他手段确保对象在多线程环境中不能被修改，从而避免竞态条件。</li></ol><h2 id="实现线程安全">实现线程安全</h2><ol><li><strong>加锁机制：</strong> 使用<code>synchronized</code>关键字或者<code>ReentrantLock</code>等锁机制来确保在同一时刻只有一个线程能够访问共享资源，从而避免竞态条件。</li><li><strong>原子类：</strong> Java提供了一些原子类（如<code>AtomicInteger</code>、<code>AtomicLong</code>等），这些类的操作是原子的，不需要额外的同步。</li><li><strong>线程局部变量（Thread-Local Variables）：</strong> 使用<code>ThreadLocal</code>可以为每个线程提供独立的变量副本，避免了共享变量的修改冲突。</li><li><strong>不可变对象：</strong> 创建不可变对象，确保对象一旦被创建就不能被修改，从而避免多线程环境中的数据竞争。</li><li><strong>使用并发集合：</strong> Java提供了一些并发集合类（如<code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>等），它们内部实现了线程安全机制，可以在多线程环境下安全地使用。</li></ol><h1>ThreadLocal</h1><ol><li><code>ThreadLocal</code> 是 Java 中的一个特殊类，用于在多线程环境中保持<strong>变量的线程本地副本</strong>。它并不直接保证线程安全，而是通过为每个线程提供独立的变量副本来避免线程间的竞争和共享。</li><li><code>ThreadLocal</code> 使用一个特殊的数据结构来维护每个线程的变量副本，这样每个线程都可以独立地修改自己的副本而不会影响其他线程的副本。这种方式在一些场景下非常有用，比如在线程池中处理任务时，每个任务都可以独立地访问和修改自己的数据，而不用担心线程安全问题。</li><li>使用<code>ThreadLocal</code>有两个作用：<ul><li>线程内资源全局共享</li><li>线程间资源互相隔离</li></ul></li></ol><h3 id="用法示例">用法示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">常用方法：get(),set(object),remove()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 在主线程设置 ThreadLocal 变量</span></span><br><span class="line">        threadLocal.set(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动两个新线程，它们会访问各自独立的 ThreadLocal 变量副本</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">100</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 1: &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 2: &quot;</span> + threadLocal.get());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在主线程获取 ThreadLocal 变量</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Main Thread: &quot;</span> + threadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">Thread <span class="number">1</span>: <span class="number">100</span></span><br><span class="line">Thread <span class="number">2</span>: <span class="literal">null</span></span><br><span class="line">Main Thread: <span class="number">42</span></span><br></pre></td></tr></table></figure><h2 id="原理">原理</h2><p>一个ThreadLocal内部维护了一个ThreadLocalMap，类似于HashMap，当在某个线程中调用其set方法时，会将该线程id作为键，传入参数作为值存入其中；<br>因为map的键必须唯一，所以每个线程只有一个存储的空间，如果需要存储多个变量，可以采用如下办法：</p><ol><li>创建一个包含多个变量的类，然后将这个类的实例存储在一个ThreadLocal中</li><li>使用多个ThreadLocal，每个ThreadLocal保存不同的值</li></ol><h2 id="使用ThreadLocal注意事项">使用ThreadLocal注意事项</h2><p>使用<code>ThreadLocal</code>时，需要注意一些问题以确保正确的使用和避免潜在的错误。下面是一些建议和注意事项：</p><ol><li><strong>ThreadLocal的生命周期：</strong> <strong>ThreadLocal存储的数据与线程的生命周期相关联</strong>。如果线程池中的线程被重用，可能会导致上一次的<code>ThreadLocal</code>数据残留。确保<strong>在线程池中使用</strong><code>ThreadLocal</code>时，在任务执行结束后及时清理相关的<code>ThreadLocal</code>数据。</li><li><strong>手动清理ThreadLocal：</strong> 在使用完<code>ThreadLocal</code>后，尽量手动调用<code>remove</code>方法清理<code>ThreadLocal</code>中的数据。可以使用<code>try-finally</code>块确保在任何情况下都能正确清理。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;  使用ThreadLocal &#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;   threadLocalVariable.remove(); &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>避免内存泄漏：</strong> 由于<code>ThreadLocal</code>的生命周期与线程相绑定，如果在应用中存在很多线程，并且频繁使用<code>ThreadLocal</code>，可能导致内存泄漏。确保使用完<code>ThreadLocal</code>后及时清理，以免过多的<code>ThreadLocal</code>实例占用内存。</li><li><strong>适当使用初始化值：</strong> 可以通过<code>ThreadLocal</code>的<code>withInitial</code>方法在获取线程本地变量时设置默认值。这有助于避免在未设置值时返回<code>null</code>等不可预测的情况。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocalVariable = </span><br><span class="line">ThreadLocal.withInitial(() -&gt; <span class="string">&quot;Default&quot;</span>);</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>不要滥用ThreadLocal：</strong> <code>ThreadLocal</code>是一种方便的工具，但滥用可能导致代码不易理解，尤其是在大规模的并发环境中。在适当的情况下使用，不要过度依赖它。</li><li><strong>清理资源：</strong> 如果<code>ThreadLocal</code>中存储的是一些需要手动释放的资源，确保在不再需要这些资源时进行释放，以防资源泄漏。</li><li><strong>考虑使用InheritableThreadLocal：</strong> 如果线程池中的任务可能会创建子任务，并且需要共享父任务的<code>ThreadLocal</code>数据，可以考虑使用<code>InheritableThreadLocal</code>。它会使子线程继承父线程的<code>ThreadLocal</code>值。</li></ol><h2 id="阿里开源TTL">阿里开源TTL</h2><ol><li>TTL（Transmittable Thread-Local）是阿里巴巴开源的一个Java工具库，用于解决跨线程传递<code>ThreadLocal</code>值的问题。在Java多线程编程中，<code>ThreadLocal</code>通常用于保存线程私有的变量，但当线程池或异步任务池中的线程复用时，<code>ThreadLocal</code>的值无法自动传递，可能导致问题。</li><li>TTL提供了一种解决方案，通过TTL可以在父线程中设置<code>ThreadLocal</code>的值，然后在子线程中获取到这个值。这样，即使线程被线程池复用，<code>ThreadLocal</code>的值也能够正确地传递。</li><li>以下是TTL的一些特点和使用方法：<ul><li><strong>支持父子线程传递：</strong> TTL通过修改<code>ThreadLocal</code>的底层实现，支持在父线程中设置<code>ThreadLocal</code>的值，然后在子线程中获取到这个值。</li><li><strong>透明：</strong> 使用TTL时，对原有的<code>ThreadLocal</code>代码基本没有入侵，通过TTL提供的API可以在需要的地方进行修饰。</li><li><strong>无内存泄漏风险：</strong> TTL会在子线程中自动清理不再需要的<code>ThreadLocal</code>值，避免了传统<code>ThreadLocal</code>可能存在的内存泄漏问题。</li><li><strong>与线程池集成：</strong> TTL对一些常见的线程池（如ThreadPoolExecutor）进行了集成，可以方便地与线程池搭配使用。</li><li><strong>兼容性：</strong> TTL兼容Java原生的<code>ThreadLocal</code> API，使用起来相对简便。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql中的锁</title>
      <link href="/posts/ef86472b.html"/>
      <url>/posts/ef86472b.html</url>
      
        <content type="html"><![CDATA[<p>数据库锁是用于管理并发访问数据库的机制，其主要作用是控制多个事务对共享资源（如数据表、数据行）的访问，以确保数据的一致性和完整性。锁可以防止多个事务同时对同一资源进行不同的操作，从而避免并发问题。</p><h1>从锁的粒度划分</h1><ol><li><strong>行级锁（Row-level Lock）：</strong> 行级锁是一种细粒度的锁，允许事务锁定表中的某一行或某几行，而不是整个表。这种锁的作用是减小锁的粒度，允许并发性更高，减少锁冲突。</li><li><strong>表级锁（Table-level Lock）：</strong> 表级锁是锁定整个表的锁，它的粒度比行级锁更粗，通常会阻塞其他事务的操作，因此在高并发情况下可能导致性能问题。表级锁的使用应该尽量避免，除非确实需要锁定整个表。</li><li><strong>页级锁</strong>：是粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折中的页级，一次锁定相邻的一组记录。</li></ol><h1>从使用性质划分</h1><p>InnoDB 实现了标准的行级锁，包括两种：<strong>共享锁（简称 s 锁）、排它锁（简称 x 锁）。</strong></p><ol><li><strong>共享锁（Shared Lock）：</strong> 也称为读锁。多个事务可以同时持有共享锁，并且不会阻塞其他事务的共享锁。共享锁用于读取操作，允许多个事务同时读取相同的资源，但阻止其他事务持有排他锁。</li><li><strong>排他锁（Exclusive Lock）：</strong> 也称为写锁。只有一个事务可以持有排他锁，其他事务无法同时持有共享锁或排他锁。排他锁用于写入操作，确保只有一个事务可以修改资源，防止其他事务读取或写入相同的资源。</li><li><strong>意向锁（Intention Lock）：</strong> 意向锁是用来表示事务打算对资源进行哪种类型的锁定（共享锁或排他锁）。意向锁不会阻止其他事务获取共享或排他锁，但它们提供了一种机制，让事务了解其他事务的锁定意图，以便更好地管理锁。</li></ol><h1>从主观上划分</h1><ol><li><strong>乐观锁</strong>（Optimistic Lock）：顾名思义，从主观上认定资源是不会被修改的，所以不加锁读取数据，仅当更新时用版本号机制等确认资源是否被修改。乐观锁适用于多读的应用类型，可以系统提高吞吐量。通常通过<strong>增加额外字段</strong>来实现，但仅仅体现一种思想，进行数据库操作时还是使用的mysql底层的锁（悲观锁）</li><li><strong>悲观锁</strong>（Pessimistic Lock）：正如其名，具有强烈的独占和排它特性，每次读取数据时都会认为会被其它事务修改，所以每次操作都需要加上锁。</li></ol><h1>InnoDB中的锁算法（加锁模式）</h1><ul><li>Record Lock：单个行记录上的锁。</li><li>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身</li><li>Next-Key Lock：Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身</li><li>它们都是行级锁的实现</li></ul><h2 id="记录锁（Record-Lock）">记录锁（Record Lock）</h2><p>对表中的记录加锁（锁住索引记录，而不是真正的数据记录）叫做记录锁，简称行锁（区别于行级锁）。例如下面的sql会在 id=1 的记录上加上记录锁，以阻止其他事务插入，更新，删除 id=1 这一行。注意：id 列必须为唯一索引列或主键列，同时查询语句必须为精准匹配（=），不能为 &gt;、&lt;、like 等，否则会退化成临键锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `test` <span class="keyword">WHERE</span> `id`<span class="operator">=</span><span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><h2 id="间隙锁（Gap-Locks）">间隙锁（Gap Locks）</h2><p>间隙锁是一种特殊的锁，用于<strong>锁定范围内的间隙</strong>（两个值之间的空间），<strong>存在于非唯一索引中</strong>，以防止其他事务插入新行。这有助于<strong>避免幻读</strong>问题。当事务查询数据时，InnoDB可以自动获取间隙锁来保护查询范围。例如emp 表中只有 101 条记录，其 empid 的值分别是1, 2, …, 100, 101，下面的SQL不仅会对符合条件的 empid 值为 101 的记录加锁，也会对 empid 大于 101（这些记录并不存在）的 “间隙” 加锁。这时如果插入 empid 等于 102 的数据，如果那边事务还没有提交，就会处于等待状态，无法插入数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> empid <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure><h2 id="临键锁（Next-Key-Locks）">临键锁（Next-Key Locks）</h2><p>Next-key 锁是记录锁和间隙锁的组合，它指的是加在<strong>某条记录以及这条记录前面间隙上</strong>的锁，<strong>存在于非唯一索引中</strong>。 InnoDB使用Next-Key Locks来处理范围查询和避免幻读。这种锁将行级锁与间隙锁结合起来，确保不会有新行插入到查询范围内。可以理解为一种特殊的间隙锁。通过临建锁可以解决幻读的问题。每个数据行上的<strong>非唯一索引</strong>列（该索引里面的值允许重复）上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段 <strong>左开右闭</strong> 区间的数据。例如，假设有如下表，其中id 是主键，age是普通索引。<img src="/post-img/Pasted image 20240215222036.png" alt="图片损坏" style="zoom:100%;" />该表中 age 列潜在的临键锁有：(-∞, 10]，(10, 24]，(24, 32]，(32, 45]，(45, +∞]。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在事务 A 中执行如下命令之一：</span><br><span class="line"><span class="comment">-- 根据非唯一索引列 UPDATE 某条记录 </span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span> <span class="keyword">SET</span> name <span class="operator">=</span> Vladimir <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">24</span>; </span><br><span class="line"><span class="comment">-- 或根据非唯一索引列 锁住某条记录 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">24</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line">会导致以下命令被阻塞：</span><br><span class="line">（事务A在对age为<span class="number">24</span>的列进行<span class="keyword">UPDATE</span>操作的同时也获取了(<span class="number">10</span>, <span class="number">32</span>]这个区间内的临键锁）</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">table</span> <span class="keyword">VALUES</span>(<span class="number">100</span>, <span class="number">26</span>, <span class="string">&#x27;tianqi&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这里对 记录锁、间隙锁、临键锁 做一个总结：<br>InnoDB 中的行锁的实现依赖于索引，一旦某个加锁操作没有使用到索引，那么该锁就会退化为表锁。<br>记录锁 存在于包括 主键索引 在内的唯一索引中，锁定 单条索引 记录。<br>间隙锁 存在于 非唯一索引 中，锁定开区间范围内的一段间隔，它是基于 临键锁 实现的。<br>临键锁 存在于 非唯一索引 中，该类型的每条记录的索引上都存在这种锁，它是 一种特殊的间隙锁，锁定一段 左开右闭 的索引区间。</p><h1>拓展</h1><h2 id="意向锁">意向锁</h2><p>意向锁分为 <strong>意向共享锁（IS）</strong> 和 <strong>意向排他锁（IX）</strong>，是表锁的实现，存在的目的是为了让 InnoDB 中的<strong>行锁和表锁更高效的共存</strong>。</p><ul><li>意向共享锁（IS）和 意向排他锁（IX）都是 <strong>表锁</strong>。</li><li>意向锁是一种 <strong>不与行级锁冲突的表级锁</strong>，这一点非常重要。</li><li>意向锁是 InnoDB 自动加的， 不需用户干预。</li><li>意向锁是在 InnoDB 下存在的内部锁，对于MyISAM 而言没有意向锁之说。</li></ul><ol><li>当某个事务user表中的某行上了排他锁时（例如记录、间隙、临键等），另一个事务此时需要获取表锁，因为共享锁与排他锁互斥，所以事务B对user表加共享锁的时候，必须保证：当前没有其他事务持有 users 表的排他锁，当前没有其他事务持有 users 表中任意一行的排他锁 。后者必<strong>须通过遍历</strong>表中的每一行才能知道，这是一种低效的做法。</li><li>有了意向锁之后，事务 B 只要看表上有没有意向排他锁（某行上了排他锁时会自动为表获取），有则说明表中有些行被行锁锁住了，因此，事务 B 申请表的写锁会被阻塞。</li><li>意向锁与意向锁之间永远是兼容的，因为不论加行级的 X 锁或 S 锁，都会自动获取表级的 IX 锁或者 IS 锁。也就是有 10 个事务，对不同的 10 行加了行级 X 锁，那么这个时候就存在 10 个 IX 锁。这 10 个 IX 存在的作用就是假如这个时候有个事务，想对整个表加排它 X 锁,那它不需要遍历每一行是否存在 S 或 X 锁，而是看有没有存在意向锁，只要存在一个意向锁，那这个事务就加不了表级排它(X)锁，要等上面 10 个 IX 全部释放才行。</li></ol><h2 id="插入意向锁">插入意向锁</h2><ul><li>插入意向锁是在<strong>插入</strong>一条记录行前，由 INSERT 操作产生的一种间隙锁。</li><li>虽然插入意向锁中含有意向锁三个字，但是它并不属于意向锁而属于<strong>间隙锁</strong>，因为意向锁是表锁，而插入意向锁是行锁。</li><li>假设存在两条值分别为 4 和 7 的记录，两个不同的事务分别试图插入值为 5 和 6 的两条记录，每个事务在获取插入行上独占的（排他）锁前，都会获取（4，7]之间的间隙锁，但是因为数据行之间并不冲突，所以两个事务之间并不会产生冲突（阻塞等待）。</li><li>插入意向锁是<strong>一种特殊的间隙锁</strong> ，两个插入意向锁之间互不排斥，所以即使多个事务在同一区间插入多条记录，只要记录本身（<strong>主键、唯一索引</strong>）不冲突，那么事务之间就不会出现冲突等待。也就是说插入意向锁在<strong>锁定区间相同但记录行本身不冲突</strong>的情况下互不排斥。</li><li>具体的说，当多个事务并发地进行插入操作时，如果它们的插入数据范围没有重叠，就可以避免插入意向锁的竞争，提高并发性能。但如果它们的插入数据范围有重叠，可能需要等待其他事务释放锁，以协调插入操作。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务1</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (id, name) <span class="keyword">VALUES</span> (<span class="number">5</span>, <span class="string">&#x27;John&#x27;</span>) LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务2</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (id, name) <span class="keyword">VALUES</span> (<span class="number">7</span>, <span class="string">&#x27;Jane&#x27;</span>) LOCK <span class="keyword">IN</span> SHARE MODE; <span class="comment">-- 不会被阻塞，因为是不同的索引区间</span></span><br></pre></td></tr></table></figure><h1>总结</h1><p>mysql锁分类：<br>按粒度：行级锁、表级锁、页级锁<br>按使用性质：共享锁、排他锁、意向锁<br>按主观：悲观锁、乐观锁<br>按加锁模式：记录锁、间隙锁、临键锁、意向锁、插入意向锁<br><strong>其中粒度，使用性质，主观都是逻辑上的分类</strong><br>行级锁有行锁（记录锁），间隙锁，临键锁<br>表级锁有表锁，意向锁，元数据锁（防止数据定义语句DDL数据操作语句DML起冲突）</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql原理</title>
      <link href="/posts/6b129314.html"/>
      <url>/posts/6b129314.html</url>
      
        <content type="html"><![CDATA[<h1>mysql重要组件</h1><ol><li><strong>MySQL Server（MySQL 服务器）：</strong><ul><li>MySQL Server 是 MySQL 数据库管理系统的核心组件，负责处理客户端的请求、执行 SQL 语句、管理数据库和表结构等核心功能。</li><li>MySQL Server 提供了多种存储引擎，如InnoDB、MyISAM等，用于实现不同的数据存储和管理方式。</li></ul></li><li><strong>Storage Engines（存储引擎）：</strong><ul><li>存储引擎是 MySQL 中负责数据存储和检索的模块。不同的存储引擎具有不同的特性，适用于不同的应用场景。</li><li>常见的存储引擎包括 InnoDB（支持事务、行级锁、外键等特性）、MyISAM（适用于读多写少的场景）、MEMORY（将表数据存储在内存中）、等等。</li></ul></li><li><strong>MySQL Clients（MySQL 客户端）：</strong><ul><li>MySQL 客户端是与 MySQL Server 进行通信的用户接口。它可以是命令行工具（如 mysql 命令行客户端）、图形用户界面工具（如 MySQL Workbench）或应用程序中的数据库连接库。</li><li>客户端通过 MySQL 协议与服务器通信，向服务器发送 SQL 语句并接收执行结果。</li></ul></li><li><strong>SQL Interface（SQL 接口）：</strong><ul><li>SQL 接口是连接 MySQL 客户端和服务器之间的桥梁。它定义了客户端如何与服务器进行通信，以及如何发送 SQL 语句和接收执行结果。</li><li>MySQL 使用标准的 SQL 语言作为与用户交互的接口，用户通过 SQL 语句进行数据库操作。</li></ul></li><li><strong>MySQL Connectors（MySQL 连接器）：</strong><ul><li>MySQL 连接器是用于不同编程语言的 API，允许应用程序与 MySQL 数据库进行连接和通信。常见的连接器包括 JDBC（Java 数据库连接）、ODBC（开放数据库连接）、PHP MySQLi（PHP 连接器）等。</li></ul></li></ol><p><strong>在mysql的各组件中，我们最关注的应该是服务器（也就是通常说的server层）以及存储引擎</strong></p><h2 id="mysql服务器">mysql服务器</h2><p>server层的重要组成部分如下：</p><ol><li><strong>解析器（Parser）：</strong><ul><li>解析器负责对 SQL 语句进行语法分析，将 SQL 语句解析为内部的数据结构，如解析树。这是 SQL 执行的第一步。</li></ul></li><li><strong>优化器（Optimizer）：</strong><ul><li>优化器负责选择最佳的执行计划，即确定如何执行查询以获得最佳性能。它考虑了索引的使用、连接顺序、Join 类型、过滤条件等因素。</li></ul></li><li><strong>执行计划生成器（Execution Plan Generator）：</strong><ul><li>执行计划生成器使用优化器的结果，生成一个具体的执行计划，包括执行每个步骤的顺序。生成的执行计划被存储在缓存中，以便在将来的执行中重用。</li></ul></li><li><strong>存储引擎接口（Storage Engine Interface）：</strong><ul><li>MySQL 支持多种存储引擎，如 InnoDB、MyISAM 等。存储引擎接口提供了与存储引擎进行交互的接口，包括读取、写入、锁定等操作。</li></ul></li><li><strong>缓存和缓存管理器（Cache and Cache Manager）：</strong><ul><li>MySQL 使用缓存来提高查询性能。缓存管理器负责管理查询结果的缓存，以及其他缓存，如索引缓存、表缓存等。</li></ul></li></ol><h2 id="存储引擎">存储引擎</h2><p>mysql的存储引擎有许多实现，最为常见的是innoDB和MyISAM</p><h3 id="MylSAM和-InnoDB的区别">MylSAM和 InnoDB的区别</h3><ol><li><strong>事务支持：</strong><ul><li><strong>MyISAM：</strong> MyISAM不支持事务。这意味着它不适用于需要事务支持的应用，如银行应用或在线购物网站。</li><li><strong>InnoDB：</strong> InnoDB支持事务。它提供了ACID（原子性、一致性、隔离性和持久性）属性，可以确保数据的完整性和一致性。</li></ul></li><li><strong>锁定级别：</strong><ul><li><strong>MyISAM：</strong> MyISAM使用表级锁定（Table-level Locking），这意味着在执行写操作时，整个表将被锁定，阻塞其他写操作。</li><li><strong>InnoDB：</strong> InnoDB使用行级锁定（Row-level Locking），这使得多个事务可以同时操作同一表的不同行，提高了并发性能。</li></ul></li><li><strong>外键支持：</strong><ul><li><strong>MyISAM：</strong> MyISAM不支持外键约束。它不会强制执行引用完整性，因此需要应用程序自行管理外键关系。</li><li><strong>InnoDB：</strong> InnoDB支持外键约束。它可以在数据库层面强制执行引用完整性，确保数据的一致性。</li></ul></li></ol><h3 id="InnoDB的四大特性（了解）">InnoDB的四大特性（了解）</h3><ol><li><strong>插入缓冲（Insert Buffer）：</strong><ul><li>插入缓冲是 InnoDB 存储引擎的一个特性，用于优化插入操作的性能。</li><li>当执行插入操作时，数据首先被写入到插入缓冲中，然后根据适当的时机（通常是在后台任务执行时）将数据合并到主要数据页中。</li><li>这减少了插入操作引起的磁盘 I/O 操作，提高了插入性能。</li></ul></li><li><strong>二次写（Double Write）：</strong><ul><li>二次写是一项用于提高数据完整性的安全措施。</li><li>当数据写入磁盘时，InnoDB 将数据首先写入到一个称为 doublewrite buffer 的地方，然后再写入到实际的数据文件。</li><li>如果在写入过程中发生崩溃，InnoDB 可以从 doublewrite buffer 中恢复数据，以避免数据损坏或丢失。</li></ul></li><li><strong>自适应哈希索引（Adaptive Hash Index，AHI）：</strong><ul><li>自适应哈希索引是 InnoDB 存储引擎中的一种优化技术，用于加速哈希索引的访问。</li><li>在某些情况下，InnoDB 使用哈希索引来提高查询性能。AHI 动态地调整哈希索引的大小和位置，以适应查询模式和工作负载的变化。</li><li>AHI 的目标是确保在高负载环境下，哈希索引仍然可以有效提高查询性能。</li></ul></li><li><strong>预读（Read Ahead）：</strong><ul><li>预读是 InnoDB 存储引擎的一项优化技术，用于减少磁盘 I/O 操作的开销。</li><li>当执行查询时，InnoDB 可以预读邻近的数据页，因为查询通常不仅仅涉及单个数据页。这样，在查询需要这些数据页时，它们已经在内存中，减少了磁盘访问的需求，提高了查询性能。</li></ul></li></ol><h1>InnoDB</h1><h2 id="逻辑存储结构">逻辑存储结构</h2><ol><li><strong>表空间（Tablespace）：</strong><ul><li>表空间是 InnoDB 存储引擎的最顶层结构，用于存储记录，索引等数据。每个数据库表都存储在一个或多个表空间中。</li></ul></li><li><strong>段（Segment）：</strong><ul><li>表空间内的逻辑存储结构被划分为段。每个段包含一个或多个区。InnoDB 使用段来<strong>组织数据</strong>。分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment） , InnoDB是索引组织表，数据段就是B+树的叶子节点，索引段即为B+树的非叶子节点。</li></ul></li><li><strong>区（Extent）：</strong><ul><li>区是 InnoDB 存储引擎中的一个单位，相当于若干个连续的页。每个区的大小默认为 1MB，因此一个区中有64个连续的页。区是<strong>分配和管理存储空间的基本单位</strong>。为了保证页的连续性，InnoDB每次从磁盘中申请4-5个区。</li></ul></li><li><strong>页（Page）：</strong><ul><li>页是 InnoDB 存储引擎的<strong>最小存储单位</strong>，通常为 16KB。所有的数据都存储在页中，包括表数据、索引、回滚段等。页是物理存储的基本单位，也是缓冲池中数据的基本单元。</li></ul></li><li><strong>行（Row）：</strong><ul><li>行是表中的最小数据单元，包含表中的一条记录。InnoDB 存储引擎支持行级别的锁和多版本并发控制（MVCC），使得多个事务可以同时对同一表进行读写操作而不会互相干扰。</li><li>每行还包含两个隐藏字段<strong>Trx_id（事务id）和Rol pointer（隐藏指针）</strong></li><li>Trx_id:每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。</li><li>Rol pointer: 每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul></li></ol><h2 id="内存架构">内存架构</h2><h3 id="缓冲池（Buffer-Pool）：">缓冲池（Buffer Pool）：</h3><ol><li>把磁盘读到的页放到一块内存区域里面,下一次读取相同的页,先判断是不是在这个内存区域里面,如果是,就直接读取,然后操作,不用再次从磁盘中加载。这体现了<strong>局部性原理</strong>和<strong>预加载机制</strong>。</li><li>当磁盘的一块数据被读取的时候,很有可能它附近的位置也会马上被读取到,这就是<strong>局部性原理</strong>。</li><li>每次读取的时候可以多读取一些数据,而不是用多少读多少，这就是<strong>预读取</strong>,体现为以页为最小单位加载数据。</li><li>缓冲池以页（同逻辑结构中的页）为单位，底层采用链表数据结构管理。 根据状态，将Page分为三种类型： <strong>free page</strong>:未被使用，<strong>clean page</strong>:被使用过但数据没有被修改过，<strong>dirty page</strong>:脏页，被使用过且数据被修改过，其数据与磁盘的数据产生了不一致。</li></ol><h3 id="更改缓冲区（Change-Buffer）">更改缓冲区（Change Buffer）</h3><ol><li><strong>针对于非唯一二级索引页</strong></li><li>在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区Change Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中</li><li>目的：与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了ChangeBuffer之后，我们可以在缓冲池中进行合并处理，<strong>减少磁盘IO</strong>。</li></ol><h3 id="自适应哈希（AHI）">自适应哈希（AHI）</h3><ol><li>用于优化对Buffer Pool数据的查询。InnoDB存储引擎会监控对表上各索引页的查询，如果观察到hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。</li><li>无需人工干预，是系统根据情况自动完成。开关参数（默认开）: adaptive_hash_index</li></ol><h3 id="日志缓冲区（Log-Buffer）">日志缓冲区（Log Buffer）</h3><ol><li>用来保存要写入到磁盘中的log日志数据（redolog、undolog），默认大小为16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以减少磁盘l/O。设置缓冲区大小：innodb_log_buffer_size</li><li>日志刷新到磁盘时机参数：innodb_flush_log_at_trx_commit<ul><li>0：每秒将日志写入并刷新到磁盘一次</li><li>1：日志在每次事务提交时写入并刷新到磁盘（保证数据能写到日志）</li><li>2：日志在每次事务提交后写入,并每秒刷新到磁盘一次</li></ul></li></ol><h2 id="磁盘结构">磁盘结构</h2><h3 id="表空间（Tablespace）">表空间（Tablespace）</h3><ol><li><strong>系统表空间（System Tablespace）</strong>：是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等) 参数:innodb_data_file_path</li><li><strong>用户表空间（File-Per-Table Tablespaces）</strong>：每个表的文件表空间，包含单个InnoDB表的数据和索引，并存储在文件系统上的单个数据文件中 参数:innodb_file_per_table</li><li><strong>通用表空间（General Tablespaces）</strong>：需要通过CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。</li></ol><h3 id="双写缓冲区（Doublewrite-Buffer-Files）">双写缓冲区（Doublewrite Buffer Files）</h3><p>innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。（显示为dblwr文件）</p><h3 id="重做日志（Redo-Log）">重做日志（Redo Log）</h3><ol><li>用来<strong>实现事务的持久性</strong></li><li>该日志文件由两部分组成:<ul><li>重做日志缓冲（redo log buffer），在内存中（前面提到的Log Buffer）</li><li>重做日志文件（redo log），在磁盘中。</li><li>当<strong>事务提交之后</strong>会把所有修改信息都会存到该日志中,用于在刷新脏页到磁盘时,发生错误时,进行数据恢复使用。</li></ul></li></ol><h3 id="回滚日志（Undo-Log）">回滚日志（Undo Log）</h3><ol><li>记录了事务发生之前的数据状态(不包括select).如果修改数据时出现异常,可以使用undo log来实现回滚操作(<strong>保持原子性</strong>)</li><li>在执行undo的时候,仅仅是将数据从逻辑上恢复至事务之前的状态,而不是从物理页面上操作实现的,属于逻辑格式的日志</li><li>undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment 回滚段中，内部包含1024个undo log segment</li><li>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除；而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</li></ol><h2 id="MVCC">MVCC</h2><p>全称Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本<br>使得读写操作没有冲突，快照读是MySQL实现MVCC的一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p><h3 id="快照读和当前读">快照读和当前读</h3><ol><li><strong>当前读</strong>：<ul><li>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。以下是一些当前读操作，如:</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ...lock <span class="keyword">in</span> share mode(共享锁)</span><br><span class="line"><span class="keyword">select</span> ... <span class="keyword">for</span> <span class="keyword">update</span>、<span class="keyword">update</span>、<span class="keyword">insert</span>、<span class="keyword">delete</span>(排他锁)</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>快照读</strong>：<ul><li>简单的select (不加锁)就是快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</li><li>Read Committed:每次select，都生成一个快照读。</li><li>Repeatable Read:开启事务后第一个select语句才是快照读的地方。</li><li>Serializable:快照读会退化为当前读。</li></ul></li></ol><h3 id="实现原理">实现原理</h3><h4 id="隐藏字段">隐藏字段</h4><p>每条记录（行）中有三个隐藏字段：</p><ul><li>DB_TRX_ID：最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。</li><li>DB_ROLL_PTR：回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本。</li><li>DB_ROw_ID：隐藏主键,如果表结构没有指定主键，将会生成该隐藏字段。</li></ul><h4 id="undolog版本链">undolog版本链</h4><ol><li>不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</li><li>每个链表的节点都是一条行记录的一个版本，只是隐藏字段不同</li></ol><h4 id="readview读视图">readview读视图</h4><ol><li>是<strong>快照读</strong>SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的） id。不同的隔离级别，生成ReadView的时机不同:<ul><li>READ COMMITTED∶在事务中每一次执行快照读时生成ReadView</li><li>REPEATABLE READ:仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView</li></ul></li><li>ReadView中包含了四个核心字段:<ul><li>m_ids：当前活跃的事务ID集合（当前还未提交的事务ID集合）</li><li>min_trx_id：最小活跃事务ID（最小还未提交事务id）</li><li>max_trx_id：预分配事务ID,当前最大事务ID+1（因为事务ID是自增的）</li><li>creator_trx_id：ReadView创建者的事务ID</li></ul></li><li>版本链访问规则（trx_id是当前事务ID）：<ul><li>trx_id == creator_trx_id ?可以访问该版本（说明数据是当前这个事务更改的）</li><li>trx_id &lt; min_trx_id ?可以访问该版本（说明数据已经提交了）</li><li>trx_id &gt; max_trx_id ?不可以访问该版本（说明该事务是在readview生成后才开启）</li><li>min_trx_id &lt;= trx_id &lt;= max_trx_id ?如果trx_id不在m_ids中是可以访问该版本的（说明数据已经提交）</li></ul></li></ol><h1>SQL执行流程</h1><h2 id="server中">server中</h2><p>查询缓存-&gt;解析-&gt;预处理-&gt;优化器-&gt;执行器-&gt;执行引擎<br><img src="/post-img/Pasted image 20240216204730.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="执行引擎（InnoDB）">执行引擎（InnoDB）</h2><ol><li>写undo log，存储回滚指针和事务ID</li><li>若当前操作记录在内存中，找到数据并更新，否则先从磁盘数据页中加载数据</li><li>写redo log，WAL（write-ahead log），将刷盘从随机读写变为顺序读写，提高性能</li><li>写bin log，备份/主从同步</li><li>事务提交<br><img src="/post-img/Pasted image 20240216205106.png" alt="图片损坏" style="zoom:100%;" /></li></ol>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql基础</title>
      <link href="/posts/8e40d0ad.html"/>
      <url>/posts/8e40d0ad.html</url>
      
        <content type="html"><![CDATA[<h1>单表设计</h1><h2 id="DDL">DDL</h2><p><strong>DDL英文全称是Data Definition Language，数据定义语言，用来定义数据库对象(数据库、表)。</strong></p><h3 id="数据类型">数据类型</h3><h4 id="数值类型">数值类型</h4><img src="/post-img/Pasted image 20230726153339.png" alt="图片损坏" style="zoom:100%;" /><h4 id="字符串类型">字符串类型</h4><img src="/post-img/Pasted image 20230726153459.png" alt="图片损坏" style="zoom:100%;" />char(10)：最多只能存10个字符，不足10个字符占用10个字符空间 性能高，浪费空间varchar(10)：最多只能存10个字符，不足10个字符，按照实际长度存储 性能低，节省空间确定字符串长度用varchar，不确定用char<h4 id="日期类型">日期类型</h4><img src="/post-img/Pasted image 20230726153803.png" alt="图片损坏" style="zoom:100%;" /><h4 id="根据页面原型-需求创建表">根据页面原型/需求创建表</h4><p>通过页面原型和需求获取原型字段（选择合适的类型和约束）<br>加上基础字段如id、create_time、update_time等<br>其中create_time记录当前这条数据插入的时间update_time记录当前这条数据最后更新的时间<br>最终获得合理的表结构</p><h3 id="数据库操作">数据库操作</h3><p>查询所有数据库: show databases;<br>查询当前数据库: select database();<br>使用数据库:use 数据库名;<br>创建数据库:create database [ if not exists ] 数据库名;<br>删除数据库:drop database [ if exists ] 数据库名;<br>注意：上述语法中的database，也可以替换成schema。如: create schema db01;</p><h3 id="表操作">表操作</h3><h4 id="创建">创建</h4><img src="/post-img/Pasted image 20230726152908.png" alt="图片损坏" style="zoom:100%;" />约束是作用于表中字段上的规则，用于限制存储在表中的数据，目的是保证数据库中数据的正确性、有效性和完整性，分为not null、unique、primary key（auto_increment自增）、default、foreign key<img src="/post-img/Pasted image 20230726153144.png" alt="图片损坏" style="zoom:100%;" /><h4 id="查询">查询</h4><p>查询当前数据库所有表: show tables;<br>查询表结构:desc表名;<br>查询建表语句: show create table表名;</p><h4 id="修改">修改</h4><p>添加字段: alter  table  表名  add  字段名类型(长度)  [comment注释]  [约束];<br>修改字段类型: alter  table  表名  modify  字段名  新数据类型(长度);<br>修改字段名和字段类型: alter  table  表名  change  旧字段名  新字段名  类型(长度)  [comment注释]  [约束];<br>删除字段: alter  table  表名  drop  column  字段名;<br>修改表名:rename  table  表名  to  新表名;<br><img src="/post-img/Pasted image 20230726154822.png" alt="图片损坏" style="zoom:100%;" /></p><h4 id="删除">删除</h4><p>删除表:drop table [ if exists ]表名;<br>删除表时，表中的全部数据也会被删除</p><h2 id="DML">DML</h2><p><strong>DML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进行增、删、改操作。</strong></p><h3 id="INSERT-增加">INSERT(增加)</h3><img src="/post-img/Pasted image 20230726155221.png" alt="图片损坏" style="zoom:100%;" /><img src="/post-img/Pasted image 20230726155347.png" alt="图片损坏" style="zoom:100%;" />调用now( )为create_time和update_time赋值注意：1.插入数据时，指定的字段顺序需要与值的顺序是一一对应的。2.字符串和日期型数据应该包含在引号中。3.插入的数据大小，应该在字段的规定范围内。<h3 id="UPDATE（修改）">UPDATE（修改）</h3><img src="/post-img/Pasted image 20230726155611.png" alt="图片损坏" style="zoom:100%;" /><img src="/post-img/Pasted image 20230726155637.png" alt="图片损坏" style="zoom:100%;" />修改表的条件可以有，也可以没有，没有条件会修改整张表的所有数据<h3 id="DELETE-删除">DELETE(删除)</h3><img src="/post-img/Pasted image 20230726155858.png" alt="图片损坏" style="zoom:100%;" /><img src="/post-img/Pasted image 20230726155944.png" alt="图片损坏" style="zoom:100%;" />1.DELETE语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。2.DELETE 语句不能删除某一个字段的值(如果要操作，可以使用UPDATE，将该字段的值置为NULL)。<h2 id="DQL">DQL</h2><p><strong>DQL英文全称是Data Query Language(数据查询语言)，用来查询数据库表中的记录。</strong><br><img src="/post-img/Pasted image 20230726160258.png" alt="图片损坏" style="zoom:100%;" /></p><h3 id="基本查询">基本查询</h3><img src="/post-img/Pasted image 20230726160313.png" alt="图片损坏" style="zoom:100%;" />其中查询所有字段使用通配符虽然比较简洁，但是性能比较低，不推荐，建议用将表中的所有字段列出的方式查询<h3 id="条件查询">条件查询</h3><img src="/post-img/Pasted image 20230726160601.png" alt="图片损坏" style="zoom:100%;" /><h3 id="聚合函数">聚合函数</h3><img src="/post-img/Pasted image 20230726160719.png" alt="图片损坏" style="zoom:100%;" /><img src="/post-img/Pasted image 20230726160726.png" alt="图片损坏" style="zoom:100%;" />count的三种使用方式：1.conut（字段）字段必须是非空的，因为聚合函数不对null值进行运算2.count（任意不为null的常量）3.count（\*）推荐使用，mysql底层有优化<h3 id="分组查询">分组查询</h3><img src="/post-img/Pasted image 20230726161051.png" alt="图片损坏" style="zoom:100%;" />where与having区别：1．执行时机不同: where是分组之前进行过滤，不满足where条件，不参与分组;而having是分组之后对结果进行过滤。2.判断条件不同:where不能对聚合函数进行判断，而having可以。注意：1.分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。2.执行顺序: where >聚合函数>having 。<h3 id="排序查询">排序查询</h3><img src="/post-img/Pasted image 20230726161302.png" alt="图片损坏" style="zoom:100%;" />排序方式：ASC升序（默认）、DESC降序如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序<h3 id="分页查询">分页查询</h3><img src="/post-img/Pasted image 20230726161439.png" alt="图片损坏" style="zoom:100%;" />注意：1.起始索引从0开始，起始索引=（查询页码–1）  * 每页显示记录数。2.分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。3.如果查询的是第一页数据，起始索引可以省略，直接简写为limit 10。<h3 id="DQL小结">DQL小结</h3><img src="/post-img/Pasted image 20230726161617.png" alt="图片损坏" style="zoom:100%;" /><h1>多表设计</h1><p>项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系</p><h2 id="一对多">一对多</h2><p>在数据库表中多的一方，添加字段，来关联一的一方的主键<br>为了避免数据的不完整、不一致问题，这个字段定义为多的一方的外键<br><img src="/post-img/Pasted image 20230726162008.png" alt="图片损坏" style="zoom:100%;" /><br><img src="/post-img/Pasted image 20230726162030.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="一对一">一对一</h2><p>关系:一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他字段放在另一张表中，以提升操作效率<br>实现:在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)</p><h2 id="多对多">多对多</h2><p>关系:一个学生可以选修多门课程，一门课程也可以供多个学生选择<br>实现:建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p><h1>多表查询</h1><p><strong>从多张表中查询数据</strong></p><h2 id="连接查询">连接查询</h2><h3 id="内连接">内连接</h3><img src="/post-img/Pasted image 20230726162420.png" alt="图片损坏" style="zoom:100%;" /><h3 id="外连接">外连接</h3><img src="/post-img/Pasted image 20230726162449.png" alt="图片损坏" style="zoom:100%;" />左外连接:查询左表所有数据(包括两张表交集部分数据)右外连接:查询右表所有数据(包括两张表交集部分数据)左外连接和右外连接可以互相转换，因此多用左外连接<img src="/post-img/Pasted image 20230726162608.png" alt="图片损坏" style="zoom:100%;" /><h2 id="子查询">子查询</h2><img src="/post-img/Pasted image 20230726162642.png" alt="图片损坏" style="zoom:100%;" />分析时建议一步步查询，最后再将变量替换即可<h3 id="标量子查询">标量子查询</h3><img src="/post-img/Pasted image 20230726162907.png" alt="图片损坏" style="zoom:100%;" /><h3 id="列子查询">列子查询</h3><img src="/post-img/Pasted image 20230726162916.png" alt="图片损坏" style="zoom:100%;" /><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">select</span> id <span class="keyword">from</span> tb_dept <span class="keyword">where</span> name <span class="operator">=</span><span class="string">&#x27;教研部&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;咨询部&#x27;</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_emp <span class="keyword">where</span> dept_id <span class="keyword">in</span>(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_emp <span class="keyword">where</span> dept_id <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> tb_dept <span class="keyword">where</span> name <span class="operator">=</span><span class="string">&#x27;教研部&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;咨询部&#x27;</span>); </span><br></pre></td></tr></table></figure><h3 id="行子查询">行子查询</h3><img src="/post-img/Pasted image 20230726163250.png" alt="图片损坏" style="zoom:100%;" /><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">select</span> entrydate,job <span class="keyword">from</span> tb_emp <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;韦一笑&#x27;</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_emp <span class="keyword">where</span> entrydate <span class="operator">=</span> &quot;2007-01-01&#x27; and job=2;</span><br><span class="line">//select * from tb_emp where (entrydate,job) = (&quot;<span class="number">2007</span><span class="number">-01</span><span class="number">-01</span><span class="string">&#x27;,2);</span></span><br><span class="line"><span class="string">select * from tb_emp where (entrydate,job) = (select entrydate,job from tb_emp where name = &#x27;</span>韦一笑<span class="string">&#x27;);</span></span><br></pre></td></tr></table></figure><h3 id="表子查询">表子查询</h3><img src="/post-img/Pasted image 20230726163732.png" alt="图片损坏" style="zoom:100%;" /><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span>,d.name <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_emp <span class="keyword">where</span> entrydate <span class="operator">&gt;</span><span class="string">&#x27;2006-01-01&#x27;</span>) e,tb_dept d <span class="keyword">where</span> e.dept_id <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure><h1>事务和索引</h1><h2 id="事务">事务</h2><p>一组操作的集合，这组操作要么全部成功，要么全部失败<br><img src="/post-img/Pasted image 20230726163756.png" alt="图片损坏" style="zoom:100%;" /><br><img src="/post-img/Pasted image 20230726163819.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="索引">索引</h2><p>索引时帮助数据库高效获取数据的数据结构，在mysql中，默认使用的是B+树（多路平衡搜索树）<br>没有索引，查询数据需要进行全表扫描，在数据量大时效率极低；通过索引，可以大幅缩短查询所需的时间</p><h3 id="优点">优点</h3><p>提高数据查询的效率，降低数据库的lO成本。<br>通过索引列对数据进行排序,降低数据排序的成本，降低CPU消耗。</p><h3 id="缺点">缺点</h3><p>索引会占用存储空间。<br>索引大大提高了查询效率，同时却也降低了insert、update、delete的效率。</p><h3 id="语法">语法</h3><img src="/post-img/Pasted image 20230726164532.png" alt="图片损坏" style="zoom:100%;" />主键字段，在建表时，会自动创建主键索引。添加唯一约束时，数据库实际上会添加唯一索引。<h3 id="B-树的特点">B+树的特点</h3><p>1.每一个节点，可以存储多个key(有n个key，就有n个指针)。<br>2.所有的数据都存储在叶子节点,非叶子节点仅用于索引数据。<br>3.叶子节点形成了一颗双向链表,便于数据的排序及区间范围查询。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO</title>
      <link href="/posts/8601bab2.html"/>
      <url>/posts/8601bab2.html</url>
      
        <content type="html"><![CDATA[<h1>io流</h1><p>存储和读取数据的解决方案，用于读写文件中的数据（以程序为参照，程序在读取文件或网络上的数据或向文件或网络上写入）<br>可分为输入流和输出流；或者字节流和字符流（其中字节流可以是所有类型的文件，字符流只能是纯文本文件（利用windows记事本能打开并且能读懂的文件，如.txt,.md））<br><strong>使用io流的基本原则：什么时候用什么时候创建，什么时候不用什么时候关闭</strong><br><img src="/post-img/Pasted image 20230715171849.png" alt="图片损坏" style="zoom:100%;" /></p><h1>字节流</h1><p><strong>FileOutputStream和FileInputStream</strong>是字节流的两个实现类：<br>通过创建它们的对象可以实现对文件的写入和读取操作</p><h2 id="FileOutputStream写数据的三种方式">FileOutputStream写数据的三种方式</h2><img src="/post-img/Pasted image 20230715172806.png" alt="图片损坏" style="zoom:100%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FileOutputStream写数据程序</span></span><br><span class="line"><span class="comment">//1.创建对象,在程序和文件之间形成了一条传输通道</span></span><br><span class="line"><span class="comment">//写出输出源Outputstream</span></span><br><span class="line"><span class="comment">//本地文件File</span></span><br><span class="line"><span class="type">FileoutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(name:<span class="string">&quot;myio\\a.txt&quot;</span>);</span><br><span class="line"><span class="comment">//2.写出数据</span></span><br><span class="line">fos.write(<span class="number">97</span>);</span><br><span class="line"><span class="comment">//3.释放资源，摧毁传输通道</span></span><br><span class="line">fos.close();</span><br><span class="line"></span><br><span class="line">字节输出流的细节:</span><br><span class="line"><span class="number">1.</span>创建字节流输出对象</span><br><span class="line">细节<span class="number">1</span>:参数是字符串表示的路径或者是File对象都是可以的</span><br><span class="line">细节<span class="number">2</span>:如表文件不存在会创建一个新的文件，但是要保证父级路径是存在的</span><br><span class="line">细节<span class="number">3</span>：如果文件己经存在，则会清空文件；如果想要续写而非重写，需要在<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(name:<span class="string">&quot;myiolla.txt&quot;</span>)时添加第二个参数<span class="literal">true</span></span><br><span class="line"><span class="number">2.</span>写数据</span><br><span class="line">细节： werite方法的参数是整数，但是实际上写到本地文件中的是整数在ASCII上对应的字符</span><br><span class="line"><span class="number">3.</span>释放资源</span><br><span class="line">如果不释放资源，文件会被视作仍在被占用着，其他地方无法操作它</span><br></pre></td></tr></table></figure><h2 id="FileInputStream读数据的两种方式：">FileInputStream读数据的两种方式：</h2><p>注意，第二个方法一次读取一个字节数组的数据，适用于比较大的文件，<br>可以结合String的有参构造方法控制读数组中的哪几个连续数据<br><img src="/post-img/Pasted image 20230715174024.png" alt="图片损坏" style="zoom:100%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建对象</span></span><br><span class="line"><span class="type">FileInputstream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputstream</span>( name: <span class="string">&quot;myio\\b.txt&quot;</span>);</span><br><span class="line"><span class="comment">//2.读取数据</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b1</span> <span class="operator">=</span> fis.read();</span><br><span class="line">system.out.print1n((<span class="type">char</span>)b1);</span><br><span class="line"><span class="comment">//3.释放资源</span></span><br><span class="line">fis.close();</span><br><span class="line">字节输入流的细节:</span><br><span class="line"><span class="number">1.</span>创建字节输入流对象</span><br><span class="line">细节<span class="number">1</span>:如果文件不存在，就直接报错。（对比输出流文件不存在是创建）</span><br><span class="line">程序中最重要的是:数据。</span><br><span class="line"><span class="number">2.</span>写数据</span><br><span class="line">细节<span class="number">1</span>:一次读一个字节，读出来的是数据在ASCII上对应的数字</span><br><span class="line">方便阅读时需要强转为<span class="type">char</span></span><br><span class="line">细节<span class="number">2</span>:读到文件末尾了，read方法返回-<span class="number">1</span>。</span><br><span class="line"><span class="number">3.</span>释放资源</span><br><span class="line">细节:每次使用完流之后都要释放资源</span><br><span class="line"><span class="number">4.</span>循环读取时，需要有一个中间变量接取每一次读取的数据，否则会出现数据丢失</span><br></pre></td></tr></table></figure><h2 id="文件复制">文件复制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件复制程序</span></span><br><span class="line"><span class="comment">//1.创建对象</span></span><br><span class="line"><span class="type">FileInputstream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputstream</span>(<span class="string">&quot;D:\\itheima\\movie.mp4&quot;</span> );</span><br><span class="line"><span class="type">FileOutputstream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fileoutputstream</span>(<span class="string">&quot;myiol\copy.mp4&quot;</span>);</span><br><span class="line"><span class="comment">//2.拷贝</span></span><br><span class="line"><span class="comment">//核心思想:边读边写</span></span><br><span class="line"><span class="comment">//此处可以利用一次读取一个字节数组的数据提高效率</span></span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="keyword">while</span>((b = fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">fos.write(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.释放资源</span></span><br><span class="line"><span class="comment">//规则:先开的最后关闭</span></span><br><span class="line">fos.close();</span><br><span class="line">fis.close();</span><br></pre></td></tr></table></figure><h2 id="捕获异常">捕获异常</h2><p>在字节流中，无论程序中是否存在异常，最后都需要关流，因此有try-catch-finally来满足此需要，finally中包含的程序是try-catch中无论是否捕捉到异常都会执行的，因此可以把关流的语句放在此处，但是此处一处另一个问题，如果在try中创建字节流对象，那么字节流对象的作用域仅限域try所在的大括号而无法作用于finally中，因此需要将创建字节流对象的语句移动至try的上方，并且赋初值Null，否则会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建对象</span></span><br><span class="line"><span class="type">FileInputstream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">Fileoutputstream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">fis = <span class="keyword">new</span> <span class="title class_">FileInputstream</span>(<span class="string">&quot;D:\\itheima\\movie.mp4&quot;</span>);</span><br><span class="line">fos = <span class="keyword">new</span> <span class="title class_">Fileoutputstream</span>(<span class="string">&quot;myio\\copy.mp4&quot;</span>);</span><br><span class="line"><span class="comment">//2.拷贝</span></span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">5</span>];</span><br><span class="line"><span class="keyword">while</span>((len = fis.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">fos.write(bytes,off: e,len);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">e.printstackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//3.释放资源</span></span><br><span class="line"><span class="keyword">if</span>(fos != <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">fos.close();</span><br><span class="line">&#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">e.printstackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">if</span>(fis != <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">fis.close();</span><br><span class="line">&#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">e.printstackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续java改进了此做法，使try后面的小括号中可以添加对象参数，但是只有实现了AutoCloseable接口的类，才能在小括号中创建对象，因为创建对象的代码可能太长，因此还可以在创建对象后直接传入。此时资源用完后会自动释放，不再需要手动释放。<br><img src="/post-img/Pasted image 20230716151715.png" alt="图片损坏" style="zoom:100%;" /></p><h1>字符流</h1><h2 id="字符集（GBK，UTF-8）">字符集（GBK，UTF-8）</h2><p>1.在计算机中，任意数据都是以二进制的形式来存储的<br>2.计算机中最小的存储单元是一个字节<br>3.ASCII字符集中，一个英文占一个字节<br>4.简体中文版windows，默认使用GBK字符集<br>5.GBK字符集完全兼容ASCI字符集<br>一个英文占一个字节，二进制第一位是0<br>一个中文占两个字节，二进制高位字节的第一位是1</p><h3 id="GBK">GBK</h3><p>计算机的存储规则(汉字)(GBK)<br>规则1:汉字两个字节存储<br>规则2:高位字节二进制一定以1开头，转成十进制之后是一个负数<br>计算机的存储规则(英文)(GBK)<br>规则:英文一个字节存储，兼容ASCI,二进制前面补0<br>因此，可以通过观察首位是0还是1来判断该字节表示的是英文还是中文</p><h3 id="UTF-8">UTF-8</h3><p>Unicode字符集的UTF-8编码格式<br>一个英文占一个字节，二进制第一位是0，转成十进制是正数<br>一个中文占三个字节，二进制第一位是1，第一个字节转成十进制是负数<br>产生乱码的原因是编码和解码所采取的编码方式不同，可以通过以下方式避免：<br>1.不要用字节流读取文本文件<br>2.编码解码时使用同一个码表，同一种编码方式</p><h3 id="java中编码的方法">java中编码的方法</h3><img src="/post-img/Pasted image 20230716154811.png" alt="图片损坏" style="zoom:100%;" /><h2 id="字符流">字符流</h2><p>字符流是在字节流的基础上加入了字符集<br>特点：<br>输入流：一次读一个字节，遇到中文时，一次读多个字节<br>输出流：底层会把数据按照指定的编码方式进行编码，变成字节再写到文件中</p><h3 id="FileReader和FileWriter">FileReader和FileWriter</h3><h4 id="FileReader">FileReader</h4><p>1.创建字符输入流对象<br>public FileReader(File file)<br>创建字符输入流关联本地文件<br>public FileReader(string pathname)<br>创建字符输入流关联本地文件<br>2.读取数据<br>public int read()<br>读取数据，读到末尾返回-1<br>public int read(char[ ] buffer)<br>读取多个数据，读到末尾返回-1<br>细节1:按字节进行读取，遇到中文，一次读多个字节，读取后解码，返回一个整数<br>细节2:读到文件末尾了，read方法返回-1。<br>3.释放资源<br>piblic viod close（）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建对象并关联本地文件</span></span><br><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>( fileName: <span class="string">&quot;myio\\a.txt&quot;</span>);</span><br><span class="line"><span class="comment">//2.读取数据 read()</span></span><br><span class="line"><span class="comment">//字符流的底层也是字节流，默认也是一个字节一个字节的读取的。</span></span><br><span class="line"><span class="comment">//如果遇到中文就会一次读取多个，GBK一次读两个字节，UTF-8一次读三个字节</span></span><br><span class="line"><span class="comment">// read()）细节:</span></span><br><span class="line"><span class="comment">//1.read():默认也是一个字节一个字节的读取的,如果遇到中文就会一次读取多个</span></span><br><span class="line"><span class="comment">//2.在读取之后，方法的底层还会进行解码并转成十进制，最终把这个十进制作为返回值</span></span><br><span class="line"><span class="comment">//想看到中文汉字，需要把这些十进制数据，再进行强转</span></span><br><span class="line"><span class="comment">//使用带参的read方法时，相当于将读取数据，解码，强转散步合并了，把强转之后的字符放到数组当中，因此它相当于空参的read加强制类型转换</span></span><br><span class="line"><span class="keyword">while</span>((ch = fr.read())!= -<span class="number">1</span>)&#123;</span><br><span class="line">system.out.print((<span class="type">char</span>)ch);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.释放资源</span></span><br><span class="line">fr.close();</span><br></pre></td></tr></table></figure><h4 id="FileWriter">FileWriter</h4><p>构造方法：<br><img src="/post-img/Pasted image 20230716160224.png" alt="图片损坏" style="zoom:100%;" /><br>成员方法：<br><img src="/post-img/Pasted image 20230716160254.png" alt="图片损坏" style="zoom:100%;" /><br>1.创建字符输出流对象<br>细节1∶参数是字符串表示的路径或者File对象都是可以的<br>细节2:如果文件不存在会创建一个新的文件，但是要保证父级路径是存在的<br>细节3:如果文件已经存在，则会清空文件，如果不想清空可以打开续写开关<br>2.写数据<br>细节:如果write方法的参数是整数，但是实际上写到本地文件中的是整数在字符集上对应的字符<br>3.释放资源<br>细节:每次使用完流之后都要释放资源</p><h4 id="字符流底层原理（缓冲区）">字符流底层原理（缓冲区）</h4><p>1.创建字符输入/出流对象<br>底层:关联文件，并创建缓冲区（长度为8192的字节数组）<br>2.读取数据<br>1.判断缓冲区中是否有数据可以读取<br>2.缓冲区没有数据:就从文件中获取数据，装到缓冲区中，每次尽可能装满缓冲区<br>如果文件中也没有数据了，返回-1<br>3.缓冲区有数据:从缓冲区中读取。<br>空参的read方法:一次读取一个字节，遇到中文一次读多个字节，把字节解码并转成十进制返回有参的read方法:把读取字节，解码，强转三步合并了，强转之后的字符放到数组中<br>注意：<br>FileWriter默认是不打开续写开关的，因此在读取数据后直接使用FileWriter，会清空文件<br>但是缓冲区中的数据仍然可以被读取，剩下的文件中的数据无法读取到</p><h1>高级流</h1><h2 id="字节缓冲流">字节缓冲流</h2><img src="/post-img/Pasted image 20230716161217.png" alt="图片损坏" style="zoom:100%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建缓冲流的对象</span></span><br><span class="line"><span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BuffenedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;myio\\a.txt&quot;</span>));</span><br><span class="line"><span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;myio\\copy.txt&quot;</span>);</span><br><span class="line"><span class="comment">//2.循环读取并写到目的地</span></span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="keyword">while</span> ((b = bis.read()!= -<span class="number">1</span>)&#123;</span><br><span class="line">bos.write(b);</span><br><span class="line">)</span><br><span class="line"><span class="comment">//3.释放资源</span></span><br><span class="line"><span class="comment">//只需要关闭高级流即可，java底层会自动关闭字节流</span></span><br><span class="line">bos.close();</span><br><span class="line">bis.close();</span><br></pre></td></tr></table></figure><p>字节缓冲流的最大作用就是使字节流也可以使用缓冲区，从而能够提高文件读写的效率<br>这是因为缓冲区是开辟在内存中的，而读写过程中字节流所创建的“通道”是连接硬盘和内存的<br>内存中的读写速率远快于硬盘，从而提高了效率<br>字节输入缓冲流和字节输出缓冲流都有自己的缓冲区，而第三方变量就在这两个缓冲区之间起着传递数据的作用</p><h2 id="字符缓冲流">字符缓冲流</h2><img src="/post-img/Pasted image 20230716162146.png" alt="图片损坏" style="zoom:100%;" />字符流本身自带缓冲区，因此字符缓冲流更重要的作用是提供了两个特有的方法字符缓冲输入流：public String readLine（）；读取一行数据，直到遇到回车换行结束，但是不会把回车换行读取到内存中，如果没有数据可读了，返回Null字符缓冲输出流：public void newLine（）；提供跨平台的换行<h3 id="拷贝文件的四种方式">拷贝文件的四种方式</h3><p>字节流的基本流:一次读写一个字节<br>字节流的基本流:一次读写一个字节数组<br>字节缓冲流:一次读写一个字节<br>字节缓冲流:一次读写一个字节数组<br>其中第二种和第四种方式性能较好</p><h2 id="转换流">转换流</h2><p><strong>InputStreamReader和OutputStreamWriter</strong><br>是字符流和字节流之间的桥梁<br><img src="/post-img/Pasted image 20230716163227.png" alt="图片损坏" style="zoom:100%;" /><br>作用：<br>1.按照指定字符编码读取<br>JDK11前：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;myio\\gbkfile.txt&quot;</span>),<span class="string">&quot;GBK&quot;</span>);</span><br></pre></td></tr></table></figure><p>JDK11后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;myio\\gbkfilg,txt&quot;</span> , charset.forName(<span class="string">&quot;GBK&quot;</span>));</span><br></pre></td></tr></table></figure><p>2.字节流想要使用字符流中的方法（缓冲流中的readLine和newLine）<br>字节流在读取中文的时候，是会出现乱码的，但是字符流可以搞定；<br>字节流里面是没有读一整行的方法的。只有字符缓冲流才能搞定</p><h2 id="序列化流和反序列化流">序列化流和反序列化流</h2><p><strong>序列化流</strong>ObjectOutputStream可以将一个对象写到本地文件中<br>构造方法：public ObjectOutputStream （OutputStream out）<br>成员方法：public final void writeObject（Object obj）将对象序列化写出到文件中，防止被修改<br><strong>反序列化流</strong>ObjectInputStream可以将序列化到本地文件中的对象读取到程序中<br>构造方法：public ObjectInputStream （InputStream out）<br>成员方法：public Object readObject（）把序列化到本地文件中的对象读取到程序中<br>注意：<br>1.要使用序列化流，对象的javabean类必须实现Serilizable接口，这是一个标记式接口，其中不含抽象方法，否则会出现NotSerialzableException异常<br>2.使用序列化流时，java会通过成员变量等信息计算得到一个版本号，将它和对象信息一起写入文件中，如果后续jacabean类发生修改使得版本号发生改变，导致读取时版本号与javabean中版本号不一致，会发生报错，因此需要固定版本号<br>private static final long serialVersionUID=1L;<br>3.如果有不想序列化到文件中的成员变量，可以使用transient关键字，称为瞬态关键字：<br>private transient String address ；<br>4.序列化流写到文件中的数据是不能修改的，一但修改就无法再次读回来了<br>5.将多个自定义对象序列化到文件中，但是对象的个数不确定时，可以将对象添加到ArrayList中，用反序列化流读取ArrayList中的数据再强转为ArrayList，最后再循环获取，这样做的原因是ArrayList也实现了Serilizable接口（可以从ArrayList的源码中获取serialVersionUID）</p><h2 id="打印流">打印流</h2><p><strong>PrintStream和Printwriter</strong><br>特点1:打印流只操作文件目的地，不操作数据源<br>特点2:<strong>特有的写出方法</strong>可以实现，数据原样写出<br>特点3:<strong>特有的写出方法</strong>可以实现自动刷新，自动换行<br>打印一次数据=写出＋换行＋刷新</p><h3 id="字节打印流">字节打印流</h3><p>字节打印流没有缓冲器，开不开自动刷新都一样<br>构造方法：<br><img src="/post-img/Pasted image 20230716170941.png" alt="图片损坏" style="zoom:100%;" /><br>成员方法：<br><img src="/post-img/Pasted image 20230716171047.png" alt="图片损坏" style="zoom:100%;" /></p><h3 id="字符打印流">字符打印流</h3><p>字符流有缓冲区，想要自动刷新需要开启<br>构造方法：<br><img src="/post-img/Pasted image 20230716171307.png" alt="图片损坏" style="zoom:100%;" /><br>成员方法：<br><img src="/post-img/Pasted image 20230716171336.png" alt="图片损坏" style="zoom:100%;" /><br>输出语句System.out.println() 再理解<br>System.out其实就是获取了一个打印流对象，此打印流在虚拟机启动的时候，由虚拟机创建，默认指向控制台，它是一个特殊的打印流，是系统中的标准输出流，不能关闭，否则后面的输出语句都没用了，在系统中是唯一的</p><h2 id="解压缩流和压缩流">解压缩流和压缩流</h2><p><strong>ZipInputStream和ZipOutputStream</strong><br>压缩包中的每一个文件(包括文件夹中的文件)可视作一个ZipEntry，解压的本质就是将每一个ZipEntry按照层级拷贝到本地另一个文件夹中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个方法用来解压</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unzip</span><span class="params">(File src,File dest)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个解压缩流用来读取压缩包中的数据</span></span><br><span class="line"><span class="type">zipInputStream</span> <span class="variable">zip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">zipInputstream</span>(<span class="keyword">new</span> <span class="title class_">FileInputstream</span>(src));</span><br><span class="line"><span class="comment">//要先获取到压缩包里面的每一个zipentry对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//表示当前在压缩包中获取到的文件或者文件夹</span></span><br><span class="line">ZipEntry entry;</span><br><span class="line"><span class="keyword">while</span>(entry = zip.getNextEntry() != <span class="literal">null</span>)&#123;</span><br><span class="line">System.out.println(entry);</span><br><span class="line"><span class="keyword">if</span>(entry.isDirectory())&#123;</span><br><span class="line"><span class="comment">//文件夹:需要在目的地dest处创建一个同样的文件夹</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(dest,entry.toStringO);</span><br><span class="line">file.mkdirs();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//文件:需要读取到压缩包中的文件，并把他存放到目的地dest文件夹中（按照层级目录进行存放)</span></span><br><span class="line"><span class="type">Fileoutputstream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileoutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(dest,entry.toString()));</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="keyword">while</span>(b = zip.read() != -<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//写到目的地</span></span><br><span class="line">fos.write(b);</span><br><span class="line">&#125;</span><br><span class="line">fos.close();</span><br><span class="line"><span class="comment">//表示在压缩包中的一个文件处理完毕了</span></span><br><span class="line">zip.closeEntry();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">zip.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//作用:压缩</span></span><br><span class="line"><span class="comment">//参数一:表示要压缩的文件</span></span><br><span class="line"><span class="comment">//参数二:表示压缩包的位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">toZip</span><span class="params">(File src,File dest)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">//1.创建压缩流关联压缩包</span></span><br><span class="line"><span class="type">ZipOutputStream</span> <span class="variable">zos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(dest,<span class="string">&quot;a.zip&quot;</span>)));</span><br><span class="line"><span class="comment">//2.创建ZipEntry对象,表示压缩包里面的每一个文件和文件夹</span></span><br><span class="line"><span class="type">zipEntry</span> <span class="variable">entry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">zipEntry</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line"><span class="comment">//3.把ZipEntry对象放到压缩包当中</span></span><br><span class="line">zos.putNextEntry(entry);</span><br><span class="line"><span class="comment">//4.把src文件中的数据写到压缩包当中</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="keyword">while</span>((b= fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">zos.write(b);</span><br><span class="line">&#125;</span><br><span class="line">zos.closeEntry();</span><br><span class="line">zos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用工具包">常用工具包</h2><h3 id="Commons-io">Commons-io</h3><p><a href="https://www.bilibili.com/video/BV1yW4y1Y7Ms?p=116&amp;vd_source=ed6c39835b03d1fda588ce43bc8a16e6">IO流-43-常用工具包（Commons-io）_哔哩哔哩_bilibili</a></p><h3 id="Hutool">Hutool</h3><p><a href="https://www.bilibili.com/video/BV1yW4y1Y7Ms?p=117&amp;vd_source=ed6c39835b03d1fda588ce43bc8a16e6">IO流-44-常用工具包（hutool）_哔哩哔哩_bilibili</a></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/posts/7af799fd.html"/>
      <url>/posts/7af799fd.html</url>
      
        <content type="html"><![CDATA[<p>反射允许对成员变量，成员方法和构造方法的信息进行编程访问<br>它从字节码文件中获取这些信息，因此使用反射必须先获取class对象<br><img src="/post-img/Pasted image 20230719121447.png" alt="图片损坏" style="zoom:100%;" /></p><h1>获取class对象的三种方式</h1><p>1.Class.forName（”全类名“）<br>使用于源代码阶段，全类名即包名+类名（选中类名右键copy）<br>2.类名.class<br>适用于加载阶段，一般用于当作参数传递<br>3.对象.getClass（）<br>适用于运行阶段，已经创建对象后<br>注意字节码文件是唯一的，因此上述三种方法获取的是同一个对象</p><h1>利用反射获取构造方法</h1><img src="/post-img/Pasted image 20230719122046.png" alt="图片损坏" style="zoom:100%;" />获取到构造方法后，可以通过方法获取构造方法的信息，如权限修饰符，参数类型等getModifiers（）获取权限修饰符，返回整数（2的次方数）表示修饰符类型getParameterCount（）获取参数数量getParameterTypes（）获取参数类型getParameter（）获取所有参数newInstance（）构造新的对象setAccessible（true）临时取消权限校验<h1>利用反射获取成员变量</h1><img src="/post-img/Pasted image 20230719122800.png" alt="图片损坏" style="zoom:100%;" />获取到成员变量后，可以通过方法获取成员变量的信息，如权限修饰符，名字等getModifiers（）获取权限修饰符，返回整数（2的次方数）表示修饰符类型getName（）获取名字getType（）获取数据类型get（对象）获取成员变量记录的值setAccessible（true）临时取消权限校验set（）修改对象里面记录的值<h1>利用反射获取成员方法</h1><img src="/post-img/Pasted image 20230719123234.png" alt="图片损坏" style="zoom:100%;" />获取到成员方法后，可以通过方法获取成员方法的信息，如权限修饰符，名字等getModiifiers（）获取权限修饰符，返回整数（2的次方数）表示修饰符类型getName（）获取名字getParameters（）获取形参getExceptionTypes（）获取方法的抛出异常//方法运行Method类中用于创建对象的方法Object invoke(Object obj, object. . . args):运行方法参数一:用obj对象调用该方法（方法的调用者对象）参数二:调用方法的传递的参数（如果没有就不写）返回值:方法的返回值（如果没有就不写）<h1>反射的作用</h1><p>1.获取一个类里面所有的信息，获取到了后执行其他业务逻辑<br>2.结合配置文件，动态创建对象并调用方法（只需要修改配置文件就可以不需要更改代码在别的类中实现相同的作用）</p><h1>总结</h1><img src="/post-img/Pasted image 20230719124007.png" alt="图片损坏" style="zoom:100%;" />]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/posts/5729df21.html"/>
      <url>/posts/5729df21.html</url>
      
        <content type="html"><![CDATA[<h1>线程</h1><p>线程是操作系统中能够进行运算调度的最小单位。它被包含在进程中，是进程中的实际运作单位<br>进程是程序的基本执行实体<br>多线程可以让程序同时做多件事情，其本质是提高效率<br>应用场景：想要让多个事情同时运行时（宏观上），可以采用多线程</p><h1>并发和并行</h1><p>并发：在同一时刻，有多个指令在单个CPU上交替执行<br>并行：在同一时刻，有多个指令在多个CPU上同时执行</p><h1>多线程的实现方式</h1><h2 id="继承Thread类的方式进行实现">继承Thread类的方式进行实现</h2><p>1.自己定义一个类继承Thread<br>2.重写run方法（线程要执行的任务）<br>3.创建子类对象，并启动线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyThread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><h2 id="实现Runnable接口的方式进行实现">实现Runnable接口的方式进行实现</h2><p>1.自己定义一个类实现Runable接口<br>2.重写run方法<br>3.创建子类对象<br>4.创建一个Thread类的对象，并启动线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类中的代码</span></span><br><span class="line"><span class="comment">//创建NyRun的对象</span></span><br><span class="line"><span class="comment">//表示多线程要执行的任务</span></span><br><span class="line"><span class="type">MyRun</span> <span class="variable">mr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRun</span>();</span><br><span class="line"><span class="comment">//创建线程对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mr);</span><br><span class="line"><span class="comment">//开启线程</span></span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><p>注意：此时定义的类并不继承自Thread类，因此不能直接使用Thread中的方法如setName，此时可以在run方法中用Thread.currentThread()来获取当前线程的对象，从而使用Thread中的方法</p><h2 id="利用Callable接口和Future接口方式实现">利用Callable接口和Future接口方式实现</h2><p><strong>特点:可以获取到多线程运行的结果</strong><br>1.创建一个类MyCallable实现Callable接口<br>2.重写call(是有返回值的。表示多线程运行的结果)<br>3.创建MyCallable的对象（表示多线程要执行的任务）<br>4.创建FutureTask的对象(作用:管理多线程运行的结果)<br>5.创建Thread类的对象，并启动(表示线程)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Nycallable的对象（表示多线程要执行的任务)</span></span><br><span class="line"><span class="type">MyCallable</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line"><span class="comment">//创建FutureTask的对象(作用管理多线程运行的结果)</span></span><br><span class="line">FutureTask&lt;Integer&gt; ft= <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(mc);</span><br><span class="line"><span class="comment">//创建线程的对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t1.start();</span><br><span class="line"><span class="comment">//获取多线程运行的结果</span></span><br><span class="line">Integer result= ft.get();</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure><h2 id="多线程三种实现方式对比">多线程三种实现方式对比</h2><img src="/post-img/Pasted image 20230718122056.png" alt="图片损坏" style="zoom:100%;" /><h1>多线程中的常见成员方法</h1><img src="/post-img/Pasted image 20230718122159.png" alt="图片损坏" style="zoom:100%;" /><p><strong>1.getName（）</strong><br>如果没有给线程设置名字，线程有默认的名字，<br>格式为：Thread-X（X是从零开始的序号）<br><strong>2.setName（String name）</strong><br>如果要给线程设置名字，可以用setName方法，也可以用构造方法。<br>但是使用构造方法时要注意，子类继承父类时，不会继承构造方法，<br>因此要重写构造方法，并且在方法体中使用super调用父类构造方法<br><strong>3.currentThread（）</strong><br>当JVM虚拟机启动之后，会自动的启动多条线程<br>其中有一条线程就叫main线程，它的作用是调用main方法，并执行里面的代码<br>在以前我们写的所有的代码，其实都是运行在main线程当中<br><strong>4.sleep（long time）</strong><br>哪条线程执行到这个方法，那么哪条线程就在这里停留对应的时间<br>方法的参数:就表示睡眠的时间,单位毫秒<br>当时间到了之后,线程会自动的醒来，继续执行下面的其他代码<br><strong>5.setPriority（int newPriority）和getPriority（）</strong><br>最小是1，最大是10，默认为5<br>优先级越高，抢到CPU的概率越高，但不是一定<br><strong>6.setDaemon（boolean on）</strong><br>当其他的非守护线程执行完毕以后，守护线程会陆续结束（即使没有执行完毕），但不是立即结束，可能有较短的时间在继续执行<br><strong>7.yield（）</strong><br>静态方法，用类名调用，相对于单一进程，一般在run（）中使用<br>某线程执行完一轮后，将CPU执行权交出，所有线程重新抢夺，该线程有可能再次得到CPU执行权，该方法可以尽可能使进程间均匀执行<br><strong>8.join（）</strong><br>相对于进程之间，由某个进程调用，可以使该进程插入到当前线程之前<br>（如在main线程中调用，则先执行该线程，结束后执行main线程中的其他代码）</p><h1>线程的生命周期</h1><img src="/post-img/Pasted image 20230718124141.png" alt="图片损坏" style="zoom:100%;" /><h1>线程的安全问题</h1><h2 id="同步代码块">同步代码块</h2><p>把操作共享数据的代码锁起来<br>特点：锁默认打开，有一个线程进去了，锁自动关闭，里面的代码全部执行完毕，锁自动打开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步代码块</span></span><br><span class="line"><span class="comment">//obj是锁对象，可以是任意的对象，但一定要是唯一的，一般可以用该类的字节码文件(.class)</span></span><br><span class="line"><span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line"><span class="comment">//被锁起来的代码</span></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同步方法">同步方法</h2><p>修饰符 sunchronized 返回值类型 方法名（方法参数）{…}<br>特点：同步方法是锁住方法里面所有的代码，并且锁对象不能自己指定<br>如果是非静态方法，为this，静态方法是当前类的字节码文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//1.循环</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="comment">//2.同步代码块(同步方法)</span></span><br><span class="line"><span class="keyword">if</span> (method()) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//3.判断共享数据是否到了末尾,如果到了末尾,跳出循环</span></span><br><span class="line"><span class="keyword">if</span> (ticket == <span class="number">100</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//4.判断共享数据是否到了末尾,如果没有到末尾,执行代码逻辑</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace(）;</span><br><span class="line">&#125;</span><br><span class="line">ticket++;</span><br><span class="line">System.out.println(Thread.currentThread().getName() +<span class="string">&quot;在卖第” + ticket +&quot;</span>张票!!!<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">    return false;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Lock锁">Lock锁</h2><p>虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock<br>Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作<br>Lock中提供了获得锁和释放锁的方法，可以手动上锁、手动释放锁<br>void lock():获得锁<br>void unlock():释放锁<br>Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化ReentrantLock的构造方法<br>ReentrantLock():创建一个ReentrantLock的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="comment">//synchronized(MYThread.class)&#123;//同步代码块表述</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ticket == <span class="number">100</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//4.判断共享数据是否到了末尾,如果没有到末尾,执行核心逻辑</span></span><br><span class="line">Thread.sleep(<span class="number">10</span>);</span><br><span class="line">ticket++;</span><br><span class="line">System.out.println(Thread.currentThread().getName() +<span class="string">&quot;在卖第” + ticket +&quot;</span>张票!!!<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;catch(InterruptedException e)&#123;</span></span><br><span class="line"><span class="string">e.printStackTrace();</span></span><br><span class="line"><span class="string">&#125;finally&#123;</span></span><br><span class="line"><span class="string">//释放锁一定要运行，放在finally中</span></span><br><span class="line"><span class="string">lock.unlock();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="死锁">死锁</h2><p>在程序中出现了锁的嵌套时，会出现死锁，导致线程都进入循环等待的状态</p><h2 id="等待唤醒机制">等待唤醒机制</h2><h3 id="生产者、消费者问题">生产者、消费者问题</h3><p>常见方法：<br><img src="/post-img/Pasted image 20230718140001.png" alt="图片损坏" style="zoom:100%;" /><br>这几个方法都是通过锁对象调用（锁在资源类中创建，资源类用来控制生产者和消费者的执行）</p><h3 id="阻塞队列">阻塞队列</h3><p>放数据时，放不进去，会等着，即阻塞<br>取数据时，取不到，会等着，也会阻塞<br>阻塞队列实现的四个接口：Iterable、Collection、Quene、BlockingQuene<br>创建阻塞队列的实现类对象：ArrayBlockingQuene、LinkedBlockingQuene<br>其中前者的底层时数组，有界；后者的底层是链表，无界，但是最大为int的最大值<br>生产者和消费者必须使用同一个阻塞队列，所以阻塞队列对象应该在测试类中创建，但是生产者和消费者的类中应该给出阻塞队列的定义（但不赋值）<br>注意take方法的底层也是有锁的，因此不能再自己加锁，否则可能死锁</p><h1>线程的状态</h1><img src="/post-img/Pasted image 20230718141327.png" alt="图片损坏" style="zoom:100%;" />线程共有七种状态，但java中只定义了除运行外的其他六种状态，这是因为运行时java将线程交给操作系统了，不再管理<h1>线程池</h1><h2 id="原理">原理</h2><p>1.创建一个池子，池子中是空的<br>2.提交任务时，池子会（自动）创建新的线程对象，任务执行完毕，线程归还给池子，下回再次提交任务时，不需要创建新的线程，直接复用已有的线程即可<br>3.如果提交任务时，池子中没有空闲线程，也无法创建新的线程，任务就会排队等待<br>创建线程池-&gt;提交任务-&gt;所有任务全部执行完毕，关闭线程池</p><h2 id="代码实现">代码实现</h2><img src="/post-img/Pasted image 20230718142302.png" alt="图片损坏" style="zoom:100%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取线程池对象</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool1</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">//2.提交任务</span></span><br><span class="line"><span class="comment">//在MyRunable类中的run方法写任务</span></span><br><span class="line">pool1.submit(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line"><span class="comment">//3.销毁线程池</span></span><br><span class="line">pool1.shutdown();</span><br></pre></td></tr></table></figure><h3 id="自定义线程池">自定义线程池</h3><p>当一些任务想要被线程运行时，线程池的分配顺序如下：<br>核心线程开始运行，剩下的任务进入排队队列，若还有剩下的任务，则进入临时线程（最大线程数量减核心线程数量），若还有剩下的任务，则被拒绝<br>代码实现：<br>ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor<br>(核心线程数量,最大线程数量,空闲线程最大存活时间,任务队列,创建线程工厂,任务的拒绝策略);<br>参数一:核心线程数量     不能小于0<br>参数二:最大线程数        不能小于等于0.最大数量&gt;=核心线程数量<br>参数三:空闲线程最大存话时间    不能小于0<br>参数四:时间单位        用TimeUnit指定<br>参数五:任务队列        不能为null<br>参数六:创建线程工厂       不能为null<br>参数七:任务的拒绝策略       不能为null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line"> <span class="number">3</span>,     <span class="comment">//核心线程数量。不能小于0</span></span><br><span class="line"> <span class="number">6</span>，    <span class="comment">//最大线程数，不能小于0.最大数量&gt;=核心线程数量</span></span><br><span class="line"> <span class="number">60</span>,    <span class="comment">//空闲线程最大存活时间</span></span><br><span class="line">TimeUnit.SECONDS ,  <span class="comment">//时间单位</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">3</span>),  <span class="comment">//任务队列</span></span><br><span class="line">Executors.defaultThreadFactory(),<span class="comment">//创建线程工厂</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicyo(),<span class="comment">//任务的拒绝策略</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//任务的拒绝策略是ThreadPoolExecutor的静态内部类，这是因为拒绝策略为线程池服务，并且是一个独立的个体</span></span><br></pre></td></tr></table></figure><p>四种拒绝策略：<br><img src="/post-img/Pasted image 20230718143400.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="最大并行数">最大并行数</h2><p>四核八线程（超线程技术）的最大并行数就是8<br>Runtime.getRuntime.().availableProcessors()可以获取可用处理器数目即最大并行数<br>线程池的大小：<br>CPU密集型运算：最大并行数+1（+1即替补）<br>I/O密集型运算：最大并行数* 期望CPU利用率* （总时间即CPU计算时间+等待时间）/CPU计算时间（利用工具thread dump获取数据）</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常</title>
      <link href="/posts/23a3bd72.html"/>
      <url>/posts/23a3bd72.html</url>
      
        <content type="html"><![CDATA[<h1>异常的分类：</h1><img src="/post-img/Pasted image 20230713171105.png" alt="图片损坏" style="zoom:100%;" />编译时异常:除了RuntimeExcpetion和他的子类，其他都是编译时异常。编译阶段需要进行处理，作用在于提醒程序员。运行时异常:RuntimeException本身和所有子类，都是运行时异常。<h1>异常的作用：</h1><p>作用一:异常是用来查询bug的关键参考信息<br>作用二∶异常可以作为方法内部的一种特殊返回值，以便通知调用者底层的执行情况</p><h1>异常的处理方式</h1><h2 id="JVM默认处理异常的方式">JVM默认处理异常的方式</h2><ol><li>把异常的名称,异常原因及异常出现的位置等信息输出在控制台</li><li>程序停止执行,异常下面的代码不会再执行了</li></ol><h2 id="try-catch处理异常">try-catch处理异常</h2><p>try-catch：提前预判程序中哪个地方可能会出现某种错误，出现后执行catch中的代码，并且程序可以继续运行<br>如果try中没有遇到问题，会将try中的所有代码全部执行完毕，并且跳过catch中代码<br>如果try中可能遇到多个问题，可以写多个catch与之对应，并且父类异常应该写在下面<br>如果try中遇到的问题没有被捕获，相当于try-catch白写了，异常交给虚拟机处理<br>如果try中遇到了问题，try下面其他的代码不会继续执行，直接跳转到对应的catch，此时try中后面的代码不会运行，但try-catch后面的其它代码会继续运行；<br>如果没有对应的catch，则交给虚拟机处理，此时后面的其它代码也不会运行<br><img src="/post-img/Pasted image 20230713171318.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="throws和throw">throws和throw</h2><p>throws：写在方法定义处，表示声明一个异常，告诉调用者，使用本方法可能会有哪些异常，其中编译时异常必须要写，运行时异常可以不写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 方法() <span class="keyword">throws</span> 异常类名<span class="number">1</span>，异常类名<span class="number">2.</span>..&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>throw：写在方法内，结束方法，手动抛出异常对象，交给调用者，并且方法中下面的代码不再运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 方法()&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三种异常处理方式的对比">三种异常处理方式的对比</h2><p>1．虚拟机默认处理异常的方式<br>把异常信息以红色字体打印在控制台，并结束程序<br>2．捕获:try…catch<br>一般用在调用处，能让代码继续往下运行。<br>3．抛出: throw throws<br>在方法中，出现异常了。<br>方法就没有继续运行下去的意义了，采取抛出处理。<br>让该方法结束运行并告诉调用者出现了问题。</p><h1>自定义异常</h1><p>定义异常类，名字格式：当前异常的名字+Exception<br>写继承关系，由于参数错误导致的问题继承RuntimeException，提醒程序员检查本地信息继承Exception<br>空参构造，ctrl+alt+insert<br>带参构造，ctrl+alt+insert<br>让控制台的报错信息更加见名知意，自定义异常类就是为了这个名字</p><h1>异常的常见方法：</h1><p>public string getMessage()   返回此throwable 的详细消息字符串<br>public String toString()   返回此可抛出的简短描述<br>这两个方法要用变量存储返回值后再打印在控制台<br>public void printstackTrace()  把异常的错误信息输出在控制台<br>只是打印消息，不会终止程序运行<br><a href="//System.err.println">//System.err.println</a>(“something”)<br>以红色字体将消息打印在控制台</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件</title>
      <link href="/posts/d4cf1cb8.html"/>
      <url>/posts/d4cf1cb8.html</url>
      
        <content type="html"><![CDATA[<h1>File文件对象</h1><p>表示路径，可以是文件或文件夹，可以是存在的，也可以是不存在的<br>绝对路径是带盘符的，相对路径是不带盘符的，默认到当前项目下去找</p><h1>File的三种构造方法</h1><p>public File(String pathname)：把字符串表示的路径变成File对象<br>public File(String parent,string child)：把父级路径和子级路径进行拼接<br>public File(File parent，String child)：把父级路径和子级路径进行拼接</p><h1>File成员方法</h1><img src="/post-img/Pasted image 20230715164122.png" alt="图片损坏" style="zoom:100%;" /><img src="/post-img/Pasted image 20230715164135.png" alt="图片损坏" style="zoom:100%;" /><img src="/post-img/Pasted image 20230715164202.png" alt="图片损坏" style="zoom:100%;" /><h2 id="部分方法的细节">部分方法的细节</h2><p><strong>length（）：</strong><br>返回值是long，单位是字节，如果想要改变单位，/1024<br>无法获取文件夹的大小，如果要获取文件夹的大小，累加文件夹中所有文件<br><strong>createNewFile（）：</strong><br>当前文件夹不存在，创建成功，返回true；存在，创建失败，返回false；<br>如果父级路径不存在，方法会有异常IOException；<br>创建的一定是文件，如果路径中不包含后缀名，创建一个没有后缀的文件<br><strong>mkdir（）：</strong><br>windows中路径是唯一的，如果当前路径已经存在，创建失败，返回false；<br>此方法只能创建单级文件，无法创建多级文件夹；而mkdirs（）方法既可创建单级的，又可以创建多级的文件夹；<br><strong>delete（）：</strong><br>如果删除的是文件，直接删除，不走回收站；<br>如果删除的是空文件夹，直接删除，不走回收站；<br>如果删除的是有内容的文件夹，则删除失败；<br><strong>listFiles（）：</strong><br>当调用者File表示的路径不存在时，返回null；<br>当调用者File表示的路径是文件时，返回null；<br>当调用者File表示的路径是一个空文件夹时，返回一个长度为0的数组；<br>当调用者File表示的路径是一个有内容的文件夹时，将里面所有文件和文件夹的路径放在File数组中返回；<br>当调用者File表示的路径是一个有隐藏文件的文件夹时，将里面所有文件和文件夹的路径放在File数组中返回，包含隐藏文件；<br>当调用者File表示的路径是需要权限才能访问的文件夹时，返回null；</p><h1>遍历文件夹</h1><p>要遍历某个盘符或某个文件夹中的所有文件，通常需要使用递归：<br>1.进入想要遍历的文件夹，利用listFiles（）方法获取file数组<br>2.遍历数组，依次得到每一个文件夹或文件<br>3.判断如果是文件执行业务逻辑<br>4.判断如果是文件夹，递归，此时参数是文件夹的次一级路径<br>5.注意是否可能存在空指针异常（一般是由于存在无访问权限的文件，此时listFile（）返回的是Null）</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式接口与lambda表达式</title>
      <link href="/posts/b427a511.html"/>
      <url>/posts/b427a511.html</url>
      
        <content type="html"><![CDATA[<h1>函数式接口</h1><ol><li>函数式接口是指只包含一个抽象方法的接口。Java中引入了函数式接口的概念，主要是为了支持Lambda表达式的使用。Lambda表达式是一种轻量级的匿名函数，可以直接传递给函数式接口的对象。函数式接口的定义要求使用<code>@FunctionalInterface</code>注解，该注解用于强制检查接口是否符合函数式接口的标准。</li><li>以下是函数式接口的特征：<ul><li>接口中只能有一个抽象方法（可以包含默认方法和静态方法）。</li><li><code>@FunctionalInterface</code> 注解用于标识该接口是函数式接口（可选）。</li></ul></li></ol><h1>函数式接口的实现方式</h1><ol><li><strong>使用匿名内部类：</strong> 使用匿名内部类是最传统的方式，它允许直接实现接口的抽象方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyFunctionalInterface</span> <span class="variable">myFunction</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyFunctionalInterface</span>() &#123;     </span><br><span class="line"><span class="meta">@Override</span>     </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> &#123;         </span><br><span class="line">System.out.println(<span class="string">&quot;Implementation using anonymous inner class&quot;</span>);     </span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>使用Lambda表达式：</strong> Lambda表达式是一种更简洁的方式，特别适用于函数式接口。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyFunctionalInterface</span> <span class="variable">myFunction</span> <span class="operator">=</span> </span><br><span class="line">() -&gt; System.out.println(<span class="string">&quot;Implementation using Lambda expression&quot;</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>使用方法引用：</strong> 如果接口的抽象方法与现有方法的签名兼容，可以使用方法引用。方法引用提供了一种更简洁的语法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在这里，`myObject::myMethod` 是对 `MyFunctionalInterface` 中的抽象方法的实现。</span></span><br><span class="line">  <span class="type">MyClass</span> <span class="variable">myObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>(); </span><br><span class="line">  <span class="type">MyFunctionalInterface</span> <span class="variable">myFunction</span> <span class="operator">=</span> myObject::myMethod;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>使用构造方法引用：</strong> 如果函数式接口代表的是一个构造函数，可以使用构造方法引用。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里假设 `MyClass` 是一个函数式接口 `MyFunctionalInterface` 的实现类。</span></span><br><span class="line"> <span class="type">MyFunctionalInterface</span> <span class="variable">myFunction</span> <span class="operator">=</span> MyClass::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure><h1>lambda表达式</h1><p>Lambda表达式是Java中引入的一种轻量级的函数式编程特性，它允许你将一个函数（或称为代码块）作为一个参数传递给方法，或者更简洁地实现函数式接口。</p><p>Lambda表达式的基本语法如下：</p><ul><li><code>(parameters) -&gt; expression</code></li><li><code>(parameters) -&gt; &#123; statements; &#125;</code><br>其中，<code>parameters</code> 是Lambda表达式的参数列表，<code>expression</code> 或 <code>&#123; statements; &#125;</code> 是Lambda表达式的主体。</li></ul><p>以下是一些示例，演示了Lambda表达式的不同用法：</p><ol><li><strong>不带参数的Lambda表达式：</strong><br><code>Runnable runnable = () -&gt; System.out.println(&quot;Hello, Lambda!&quot;);</code><br><code>new Thread(runnable).start();</code></li><li><strong>带参数的Lambda表达式：</strong><br><code>(x, y) -&gt; x + y</code><br>这表示一个接受两个参数 <code>x</code> 和 <code>y</code>，并返回它们的和。</li><li><strong>带主体的Lambda表达式：</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主体可以包含多条语句，并且可以有返回值。</span></span><br><span class="line">(x, y) -&gt; &#123;     </span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> x + y;     </span><br><span class="line">System.out.println(<span class="string">&quot;Sum: &quot;</span> + sum);     </span><br><span class="line"><span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>遍历集合的Lambda表达式：</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里使用了 `forEach` 方法和Lambda表达式，简化了集合的遍历操作。</span></span><br><span class="line">    List&lt;String&gt; languages = Arrays.asList(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>); </span><br><span class="line">    languages.forEach(language -&gt; System.out.println(language));`</span><br></pre></td></tr></table></figure><p>Lambda表达式的引入使得代码更加简洁、易读，并支持更函数式的编程风格。在使用Lambda表达式时，通常用于实现函数式接口（只有一个抽象方法的接口）的匿名实现。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用API</title>
      <link href="/posts/e3dac448.html"/>
      <url>/posts/e3dac448.html</url>
      
        <content type="html"><![CDATA[<h1>MATH</h1><img src="/post-img/Pasted image 20230719171712.png" alt="图片损坏" style="zoom:100%;" /><h1>System</h1><img src="/post-img/Pasted image 20230719171743.png" alt="图片损坏" style="zoom:100%;" /><h1>Runtime</h1><img src="/post-img/Pasted image 20230719171840.png" alt="图片损坏" style="zoom:100%;" /><h1>Object和Objects</h1><h2 id="Object">Object</h2><p>1.Object是java中的顶级父类，所有的类都直接或间接的继承于Object类<br>2.Object类中的方法可以被所有子类访问<br>3.Objet类中没有成员变量，因此只有一个空参构造方法</p><h3 id="成员方法">成员方法</h3><img src="/post-img/Pasted image 20230719172210.png" alt="图片损坏" style="zoom:100%;" /><p><strong>1.toString（）</strong><br>当我们打印一个对象的时候。底层会调用对象的toString方法。把对象变成字符串。然后再打印在控制台上,打印完毕换行处理。<br>默认情况下,因为Object类中的toString方法返回的是地址值，所以默认情况下打印一个对象打印的就是地址值，但是地址值对于我们是没什么意义的，如果要看到对象内部的属性值，应该重写Object类中的toString方法<br><strong>2.equals（）</strong><br>如果没有重写equals方法，那么默认使用Object中的方法进行比较，比较的是地址值是否相等。一般来讲地址值对于我们意义不大，所以我们会重写，重写之后比较的就是对象内部的属性值了。<br><strong>3.clone（）</strong><br>方法在底层会帮我们创建一个对象，并把原对象中的数据拷贝过去。<br>书写细节:</p><ol><li>重写Object中的clone方法</li><li>让javabean类实现Cloneable接口</li><li>创建原对象并调用clone<br>深克隆和浅克隆：<br>浅克隆：不管对象内部的属性是基本数据类型还是引用数据类型，都完全拷贝过来（引用拷贝地址值），是Object中的默认方式<br>深克隆：基本数据类型拷贝过来，字符串复用，引用数据类型重新创建新的空间拷贝数据后返回新地址值，需要重写clone方法</li></ol><h1>BigInteger</h1><h2 id="构造方法">构造方法</h2><p>对象一旦被创建数据不能被修改<br><img src="/post-img/Pasted image 20230719173753.png" alt="图片损坏" style="zoom:100%;" /><br>1.获取指定的大整数细节:字符串中的数字必须是整数<br>2.获取指定进制的大整数细节:<br>字符串中的数字必须是整数；<br>字符串中的数字必须要跟进制吻合。<br>比如二进制中，那么只能写0和1，写其他的就报错。<br>3.public static BigInteger valueOf(1ong val)<br>静态方法获取BigInteger的对象，内部有优化<br>细节:<br>1.能表示范围比较小，只能在long的取值范围之内，如果超出long的范围就不行了<br>2.在内部对常用的数字:-16 ~ 16进行了优化。<br>提前把-16 ~ 16 先创建好BigInteger的对象，如果多次获取不会重新创建新的。<br><img src="/post-img/Pasted image 20230719174258.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="成员方法-2">成员方法</h2><img src="/post-img/Pasted image 20230719174324.png" alt="图片损坏" style="zoom:100%;" /><h2 id="底层存储方式">底层存储方式</h2><p>通过数组分段，分别表示符号，基数和次幂<br>最大可以是42亿的21亿次方</p><h1>BigDecimal</h1><h2 id="创建方法">创建方法</h2><p>表示较大的小数和解决小数运算精度失真的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过传递double类型的小数来创建对象，可能是不精确的，不建议使用</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecima</span>(<span class="number">0.01</span>);</span><br><span class="line"><span class="comment">//通过传递字符串表示的小数来创建对象</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecima</span>(<span class="string">&quot;0.01&quot;</span>);</span><br><span class="line"><span class="comment">//通过静态方法创建对象</span></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">bd</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//如果要表示的数字不大，没有超出double的取值范围，建议使用静态方法</span></span><br><span class="line"><span class="comment">//如果要表示的数字超出了double的取值范围，建议使用构造方法</span></span><br><span class="line"><span class="comment">//如果传递的是0~10之间的整数，包含0和10，方法会返回已经创建好的对象，不会重新创建；但是如果传递的是小数，则是直接创建新的对象</span></span><br></pre></td></tr></table></figure><h2 id="成员方法-3">成员方法</h2><img src="/post-img/Pasted image 20230720164842.png" alt="图片损坏" style="zoom:100%;" /><h2 id="底层存储方式-2">底层存储方式</h2><p>遍历字符串，得到每一个数字和小数点代表的ASKII码，存入一个数组中</p><h1>正则表达式</h1><p>1.检验字符串是否满足规则<br>2.在一段文本中查找满足要求的内容<br><img src="/post-img/Pasted image 20230720165324.png" alt="图片损坏" style="zoom:100%;" /><br><img src="/post-img/Pasted image 20230720165726.png" alt="图片损坏" style="zoom:100%;" /></p><p>注意：<br>1.如果要求两个范围的交集，要写”&amp;&amp;“，如果只写一个，表示的仅仅是”&amp;“这个符号<br>2.&quot;\&quot;是转义字符<br><img src="/post-img/Pasted image 20230720165836.png" alt="图片损坏" style="zoom:100%;" /><br><img src="/post-img/Pasted image 20230720165901.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="爬虫">爬虫</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span>获取正则表达式的对象</span><br><span class="line">Pattern p = Pattern.compile<span class="params">(&quot;Java\\d&#123;0,2&#125;)</span>;</span><br><span class="line"><span class="string">//</span>获取文本匹配器的对象</span><br><span class="line"><span class="string">//m</span>:文木匹配器的对象</span><br><span class="line"><span class="string">//str</span>:大串</span><br><span class="line"><span class="string">//p</span>:规则</span><br><span class="line"><span class="string">//m</span>要在str中找符合p规则的小串</span><br><span class="line">Matcher m = p.matcher<span class="params">(str)</span>;</span><br><span class="line"><span class="string">//</span>拿着文本匹配器从头开始读取，寻找是否有满足规则的子串</span><br><span class="line"><span class="string">//</span>如果没有，方法返回<span class="literal">false</span></span><br><span class="line"><span class="string">//</span>如果有，返回<span class="literal">true</span>。在底层记录子串的起始索引和结束索引+1</span><br><span class="line">boolean b = m.find<span class="params">()</span>;</span><br></pre></td></tr></table></figure><h2 id="正则表达式在字符串方法中的使用">正则表达式在字符串方法中的使用</h2><img src="/post-img/Pasted image 20230720170913.png" alt="图片损坏" style="zoom:100%;" />贪婪爬取和非贪婪爬取"ab+"和"ab+?"<h2 id="分组">分组</h2><p>可以复用前面已经有的正则表达式<br>1.每组是有组号的，也就是序号。从1开始，连续不间断。<br>2.以左括号为基准，最左边的是第一组，其次为第二组，以此类推。<br>3.\\组号： 表示把第x组的内容再用一次<br><img src="/post-img/Pasted image 20230720171347.png" alt="图片损坏" style="zoom:100%;" /></p><h1>时间</h1><h2 id="Date">Date</h2><p>Date类是一个JDK写好的Javabean类，用来描述时间，精确到毫秒。利用空参构造创建的对象，默认表示系统当前时间。<br>利用有参构造创建的对象，表示指定的时间。<br><img src="/post-img/Pasted image 20230720171641.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="SimpleDateFormat">SimpleDateFormat</h2><img src="/post-img/Pasted image 20230720171817.png" alt="图片损坏" style="zoom:100%;" /><h2 id="Calender">Calender</h2><img src="/post-img/Pasted image 20230720172005.png" alt="图片损坏" style="zoom:100%;" /><img src="/post-img/Pasted image 20230720172023.png" alt="图片损坏" style="zoom:100%;" /><h1>包装类</h1><p>为了将基本数据类型转化为对象，提出了包装类的概念，其本质是在堆内存中开辟了一块空间，用来存储基本数据类型的值，而把这块空间的地址值传递给包装类对象，这样做可以使所有的数据类型都可以视为对象，是object的子类，排除了代码的局限性，此外，集合的泛型中也需要传递包装类</p><h2 id="获取包装类对象的方法（以Integer为例）">获取包装类对象的方法（以Integer为例）</h2><img src="/post-img/Pasted image 20230720172756.png" alt="图片损坏" style="zoom:100%;" />细节：1.-128~127间的数据，用的比较多，因此java底层已经创建好了这些数据的对象，如果用到了会直接返回对象的地址值，因此在这个范围内获取两个值相同的数据时，实际上获取的是同一个对象，这样做的目的是不浪费太多内存2.JDK5后对包装类新增了自动装箱和自动拆箱的操作<h2 id="Integer成员方法">Integer成员方法</h2><img src="/post-img/Pasted image 20230720173222.png" alt="图片损坏" style="zoom:100%;" />]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stream流和方法引用</title>
      <link href="/posts/6ae8bba9.html"/>
      <url>/posts/6ae8bba9.html</url>
      
        <content type="html"><![CDATA[<h1>Stream流</h1><p>作用：结合lambda表达式，简化集合和数组的操作<br>可以理解为是一种流水线作业，将集合或数组中的元素放到流水线（stream流）上，进行响应的处理后（使用链式编程可以更方便的处理），进行输出或其他操作<br>使用步骤：获取Stream流对象，使用中间方法处理数据，使用终结方法处理数据<br>获取Stream流对象的方法：<br>单列集合：collection中的默认方法stream<br>双列集合：不能直接获取（可以转化为单列集合后获取）<br>数组：Arrays工具类中的静态方法stream<br>零散数据（相同数据类型）：Stream接口中的静态方法of<br>常见的方法：<br>中间方法：filter，limit，skip，distinct，concat，map<br>终结方法：forEach，count，collect，toArray</p><h2 id="获取Stream流对象：">获取Stream流对象：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单列集合</span></span><br><span class="line">ArrayList&lt;String&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">Collections.addAll(list,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;d&quot;</span>,<span class="string">&quot;e&quot;</span>);  </span><br><span class="line"><span class="comment">//创建流水线对象，后续可以进行其他操作</span></span><br><span class="line">Stream&lt;String&gt; stream1 = list.stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//双列集合</span></span><br><span class="line">HashMap&lt;String,Integer&gt; hashMap=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">hashMap.put(<span class="string">&quot;aaa&quot;</span>,<span class="number">111</span>);  </span><br><span class="line">hashMap.put(<span class="string">&quot;bbb&quot;</span>,<span class="number">222</span>);  </span><br><span class="line">hashMap.put(<span class="string">&quot;ccc&quot;</span>,<span class="number">333</span>);  </span><br><span class="line">hashMap.put(<span class="string">&quot;ddd&quot;</span>,<span class="number">444</span>);  </span><br><span class="line">hashMap.put(<span class="string">&quot;eee&quot;</span>,<span class="number">555</span>);</span><br><span class="line"><span class="comment">//1.通过获取键构造单列集合</span></span><br><span class="line">Stream&lt;String&gt; stream2 = hashMap.keySet().stream();</span><br><span class="line"><span class="comment">//2.通过获取键值对构造单列集合</span></span><br><span class="line">Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; stream = hashMap.entrySet().stream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基本数据类型</span></span><br><span class="line"><span class="type">int</span>[] arr1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="comment">//引用数据类型</span></span><br><span class="line">String[] arr2=&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>&#125;;  </span><br><span class="line"><span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> Arrays.stream(arr1);  </span><br><span class="line">Stream&lt;String&gt; stream1 = Arrays.stream(arr2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//零散数据</span></span><br><span class="line">Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">Stream.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Stream接口中静态方法of的细节</span></span><br><span class="line"><span class="comment">//方法的形参是一个可变参数，可以传递一堆零散的数据。也可以传递数组</span></span><br><span class="line"><span class="comment">//但是数组必须是引用数据类型的，如果传递基本数据类型，是会把整个数组当做一个元素，放到Stream当中。</span></span><br></pre></td></tr></table></figure><h2 id="中间方法">中间方法</h2><img src="/post-img/Pasted image 20230713163230.png" alt="图片损坏" style="zoom:100%;" />1.中间方法返回的是新的stream流，原来的stream流只能使用一次，因此建议使用链式编程2.修改stream流中的数据，不会影响原来集合或数组中的数据<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//filter过滤函数</span></span><br><span class="line">list.stream().filter(s-&gt;过滤条件(满足条件留下));</span><br><span class="line"></span><br><span class="line"><span class="comment">//limit截取前几个元素，可以配合filter或skip使用，在某条件下再截取前几个元素</span></span><br><span class="line">list.stream().limit(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//skip跳过前几个元素，可以配合filter或skip使用，在某条件下再跳过前几个元素</span></span><br><span class="line">list.stream().skip(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//distinct去重(依赖hashcode和equals方法，若传递自定义数据类型，需重写这两个方法)</span></span><br><span class="line">list.stream().distinct();</span><br><span class="line"></span><br><span class="line"><span class="comment">//concat合并两个流(尽可能使两个流的数据类型保持一致)</span></span><br><span class="line">Stream.concat(list1.stream(),list2.stream);</span><br><span class="line"></span><br><span class="line"><span class="comment">//map改变数据类型（但更像是提供一个对流中数据进行操作的平台）</span></span><br><span class="line">list.stream().map(s-&gt; Integer.parseInt(s.split( regex: <span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="终结方法">终结方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//forEach遍历</span></span><br><span class="line">list.stream().forEach(s-&gt;操作)；</span><br><span class="line"></span><br><span class="line"><span class="comment">//count记录集合元素个数</span></span><br><span class="line">list.stream().count();</span><br><span class="line"></span><br><span class="line"><span class="comment">//toArray将流中的数据收集起来存到一个数组中</span></span><br><span class="line"><span class="comment">//参数的作用：创建一个指定类型的数组</span></span><br><span class="line"><span class="comment">//返回值：装着流中所有数据的数组</span></span><br><span class="line">list.stream().toArray(value(元素个数)-&gt;<span class="keyword">new</span> <span class="title class_">String</span>[value]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//collect收集流中的数据，放到集合中（List Set Map）</span></span><br><span class="line">List&lt;String&gt; newList = list.stream( )</span><br><span class="line">.filter(s -&gt;“男”<span class="string">&quot;.equals(s.split( regex:&quot;</span>-<span class="string">&quot;&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">.collect(collectors.toList()/toSet());</span><br><span class="line">List&lt;String&gt; newList = list.stream( )</span><br><span class="line">.filter(s -&gt;“男”<span class="string">&quot;.equals(s.split( regex:&quot;</span>-<span class="string">&quot;&quot;</span>)[<span class="number">1</span>]))</span><br><span class="line">.collect(collectors.toMap(键的生成规则，值的生成规则));</span><br><span class="line">  </span><br><span class="line"><span class="comment">//    参数一:  </span></span><br><span class="line"><span class="comment">//    Function泛型一:表示流中每一个数据的类型  </span></span><br><span class="line"><span class="comment">//    泛型二:表示Nap集合中键的数据类型  </span></span><br><span class="line"><span class="comment">//    方法apply形参:依次表示流里面的每一个数据  </span></span><br><span class="line"><span class="comment">//    方法体:生成键的代码  </span></span><br><span class="line"><span class="comment">//    返回值:己经生成的键  </span></span><br><span class="line"><span class="comment">//    参数二:  </span></span><br><span class="line"><span class="comment">//    Function泛型一:表示流中每一个数据的类型  </span></span><br><span class="line"><span class="comment">//    泛型二:表示Hap集合中值的数据类型  </span></span><br><span class="line"><span class="comment">//    方法apply形参:依次表示流里面的每一个数据  </span></span><br><span class="line"><span class="comment">//    方法体:生成值的代码  </span></span><br><span class="line"><span class="comment">//    返回值:已经生成的值</span></span><br><span class="line">Map&lt;String,Integer&gt; map2 = list.stream()  </span><br><span class="line">        .filter(s -&gt;<span class="string">&quot;男&quot;</span>.equals(s.split( <span class="string">&quot;-&quot;</span>)[<span class="number">1</span>]))  </span><br><span class="line">        .collect(Collectors.toMap(  </span><br><span class="line">        s-&gt; s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">1</span>],  </span><br><span class="line">        s-&gt;Integer.parseInt(s.split(<span class="string">&quot;-&quot;</span>)[<span class="number">2</span>])));</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合</title>
      <link href="/posts/d366874c.html"/>
      <url>/posts/d366874c.html</url>
      
        <content type="html"><![CDATA[<h1>单列集合</h1><img src="/post-img/Pasted image 20230710135523.png" alt="图片损坏" style="zoom:100%;" /><h2 id="单列集合的特点">单列集合的特点</h2><p><strong>List集合系列元素：有序，可重复，有索引<br>Set集合系列元素：无序，不重复，无索引</strong></p><h2 id="集合和数组的对比">集合和数组的对比</h2><p>数组长度固定，既可以存基本数据类型，又可以存引用数据类型<br>集合长度可变，可以存引用数据类型，基本数据类型需要转为其包装类</p><h2 id="泛型">泛型</h2><h3 id="不指定泛型">不指定泛型</h3><p>如果在创建集合的时候不指定泛型，默认认为所有的数据都是object类型，这意味着可以往该集合中添加任意类型的数据，但是这使得在获取数据的时候，无法使用该数据类型的特有方法（多态的弊端）</p><h3 id="作用">作用</h3><p>1.统一数据类型<br>2.把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为在编译期间类型就能确定</p><h3 id="细节">细节</h3><p>1.泛型中不能写基本数据类型<br>2.指定泛型的基本类型后，传递数据时，可以传入该类类型或其子类类型<br>3.不写泛型，类型默认是Object</p><h3 id="使用位置">使用位置</h3><h4 id="泛型类">泛型类</h4><p>当一个类中，某个变量的数据类型不确定时，可以定义带有泛型的类,但在使用时，应该给泛型一个确定的数据类型</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">ArrayList</span>&lt;<span class="symbol">E</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型方法">泛型方法</h4><p>方法中形参不确定时，可以使用类名后面定义的泛型，所有方法都能使用；<br>也可以在方法申明上定义自己的泛型，只有本方法可以使用</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyArrayList</span> &#123;</span><br><span class="line">publid &lt;E&gt; <span class="function"><span class="type">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">obj[size] = e;</span><br><span class="line">size++;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型接口">泛型接口</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="symbol">List</span>&lt;<span class="symbol">E</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法：<br>1.实现类给出具体类型<br>2.实现类延续泛型，创建对象时再确定</p><h3 id="泛型通配符">泛型通配符</h3><p>在使用泛型时，虽然不确定类型，但是有时会希望只能传递某一个继承链中的数据类型，此时可以使用泛型通配符<br>? 表示不确定的类型<br>? extends E 表示可以传递E或E的所有子类类型<br>? super E 表示可以传递E或E的所有父类类型</p><h2 id="Collection的常见API">Collection的常见API</h2><p>Collection是一个接口，不能直接创建其对象<br><img src="/post-img/Pasted image 20230710140041.png" alt="图片损坏" style="zoom:100%;" /></p><h3 id="部分方法的细节">部分方法的细节</h3><p><strong>1.添加元素 add()</strong><br>如果我们要往List系列集合中添加数据，那么方法永远返回true，因为List系列的是允许元素重复的。<br>如果我们受往Set系列集合中添加数据，如果当前要添加元素不存在，方法返回true，表示添加成功。<br>如果当前要添加的元素已经存在。方法返回false。表示添加失败。因为Set系列的集合不允许重复。<br><strong>2…删除元素 remove()</strong><br>因为Collection里面定义的是共性的方法，所以此时不能通过索引进行剧除。只能通过元素的对象进行删除。<br>方法会有一个布尔类型的返回值。删除成功返回true，删除失败返回false；如果要剧除的元素不存在，剧除失败。<br><strong>3.判断集合是否包含 contains（）</strong><br>底层是依赖equals方法进行刘断是否存在的。所以，如果集合中存储的是自定义对象，也想通过contains方法来判断是否包含，那么在javabean类中，一定要重写equals方法。</p><h2 id="集合的遍历">集合的遍历</h2><h3 id="迭代器遍历">迭代器遍历</h3><h4 id="迭代器的三个方法">迭代器的三个方法</h4><p><strong>Iterator&lt; E &gt; iterator() :</strong> 获取一个迭代器对象<br><strong>boolean hasNext() :</strong> 判断当前指向的位置是否有元素<br><strong>E next() :</strong> 获取当前指向的元素并移动指针</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; it <span class="operator">=</span> coll.iterator()<span class="comment">;</span></span><br><span class="line">while(it.hasNext())&#123;</span><br><span class="line">string str <span class="operator">=</span> it.next()<span class="comment">;</span></span><br><span class="line">System.out.println(str)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错NoSuchElementException指针已经指向集合最后没有元素的位置<br>迭代器遍历完毕，指针不会复位（要第二次遍历，只能获取新的迭代器对象）<br>循环中只能用一次next方法（元素数目为奇数时报错NoSuchElementException）<br>迭代器遍历时，不能用集合的方法进行增加或者删除（迭代器有remove方法删除指向的元素）</p><h3 id="增强for遍历">增强for遍历</h3><p>其本质是迭代器遍历，更便于书写,单列集合和数组才可以使用</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//idea中的快速生成方法，集合名字.for</span></span><br><span class="line"><span class="built_in">for</span>(string s: list) &#123;<span class="comment">//s是一个第三方变量，在循环的过程中依次表示集合中的每一个数据</span></span><br><span class="line">system<span class="selector-class">.out</span><span class="selector-class">.println</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在for中修改变量的值，修改的是第三方变量的值，不会影响原来的值</p><h3 id="lambda表达式">lambda表达式</h3><h4 id="匿名内部类方式：">匿名内部类方式：</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历集合依次得到每一个元素,把得到的每一个元素,传递给下面的accept方法</span></span><br><span class="line"><span class="comment">//s依次表示集合中的每一个数据</span></span><br><span class="line">coll.<span class="title function_">forEach</span>(<span class="keyword">new</span> consumer&lt;<span class="title class_">String</span>&gt;()&#123;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">accept</span>(<span class="params"><span class="built_in">String</span> s</span>) &#123;</span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lambda表达式方式：">lambda表达式方式：</h4><p>删除格式部分，加上箭头，数据类型省略，只有一个变量时小括号省略，方法体只有一行代码时大括号省略</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coll.<span class="keyword">forEach</span>(s -&gt;<span class="keyword">System</span>.<span class="keyword">out</span>.println(s));</span><br></pre></td></tr></table></figure><p>总结：在遍历过程中想要删除元素，用迭代器，仅仅想要遍历，用增强for或lambda表达式</p><h2 id="List">List</h2><h3 id="特有方法（索引相关）">特有方法（索引相关）</h3><img src="/post-img/Pasted image 20230710145358.png" alt="图片损坏" style="zoom:100%;" /><p>1.添加元素 add（）<br>在指定位置插入元素，原来位置上的元素后移<br>2.删除元素 remove（）<br>删除指定索引处的元素，返回被删除的元素<br>重载方法remove（object o）；删除指定元素，返回是否删除成功<br>3.修改元素 set（）<br>修改指定索引处的元素，返回被修改的元素<br>4.获取元素 get（）<br>返回指定索引处的元素</p><h3 id="遍历方法">遍历方法</h3><p>1.迭代器遍历<br>2.增强for遍历<br>3.lambda表达式<br>4.普通for遍历<br>5.列表迭代器遍历<br>获取一个列表迭代器对象，里面的指针默认指向0<br>add，next，hasnext，remove<br>添加和修改时要用迭代器的方法</p><h4 id="五种遍历方式对比">五种遍历方式对比</h4><p>迭代器遍历         在遍历的过程中需要删除元素，请使用迭代器。<br>列表迭代器         在遍历的过程中需要添加元素，请使用列表迭代器。<br>增强for遍历、Lambda表达式       仅仅想遍历，那么使用增强for或Lambda表达式。<br>普通for          如果遍历的时候想操作索引，可以用普通for。</p><h3 id="ArrayList">ArrayList</h3><h4 id="创建">创建</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;?&gt; list = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;<span class="keyword">String</span>&gt;();</span><br></pre></td></tr></table></figure><p>打印ArrayList中的数据时，由于java底层对其进行了处理<br>打印出的不是地址值，而是集合中存储的数据，展示时会用[ ]把所有的数据进行包裹，并在数据间加上”，“</p><h4 id="常用方法">常用方法</h4><img src="/post-img/Pasted image 20230719141133.png" alt="图片损坏" style="zoom:100%;" /><h4 id="底层原理">底层原理</h4><p>1.利用空参创建的集合，在底层创建一个默认长度为0的数组<br>2.添加第一个元素时，底层会创建一个新的长度为10的数组<br>3.存满时，会扩容1.5倍<br>4.如果一次添加多个元素，1.5倍还放不下，则新创建数组的长度以实际为准<br><a href="https://www.bilibili.com/video/BV17F411T7Ao?p=190&amp;vd_source=ed6c39835b03d1fda588ce43bc8a16e6">集合进阶-06-ArrayList源码分析_哔哩哔哩_bilibili</a></p><h3 id="LinkedList">LinkedList</h3><h4 id="常用方法-2">常用方法</h4><img src="/post-img/Pasted image 20230719143752.png" alt="图片损坏" style="zoom:100%;" /><h4 id="底层原理-2">底层原理</h4><p>底层是双链表，查询慢，增删快，如果操作的是首尾元素，速度也是极快的<br><a href="https://www.bilibili.com/video/BV17F411T7Ao?p=191&amp;vd_source=ed6c39835b03d1fda588ce43bc8a16e6">集合进阶07-LinkedList和迭代器的源码分析_哔哩哔哩_bilibili</a></p><h2 id="数据结构：树">数据结构：树</h2><h3 id="二叉树">二叉树</h3><p>度:每一个节点的子节点数量<br>树高:树的总层数<br>根节点:最顶层的节点<br>左子节点:左下方的节点<br>右子节点:右下方的节点<br>根节点的左子树:蓝色虚线<br>根节点的右子树:绿色虚线</p><h4 id="二叉查找树">二叉查找树</h4><p>每一个节点上最多有两个子节点<br>任意节点左子树上的值都小于当前节点<br>任意节点右子树上的值都大于当前节点</p><h4 id="二叉树的遍历">二叉树的遍历</h4><p>前序遍历：当前-&gt;左-&gt;右<br>中序遍历：左-&gt;当前-&gt;右<br>后序遍历：左-&gt;右-&gt;当前<br>层序遍历：从根节点开始一层一层遍历</p><h4 id="平衡二叉树">平衡二叉树</h4><p>任意节点的左右子树高度差不超过1</p><h5 id="左旋和右旋">左旋和右旋</h5><p>触发时机，当添加一个节点后，该树不再是一棵平衡二叉树<br>左旋：<br>1.从添加的节点开始，不断的往父节点找不平衡的节点，以不平衡的点作为支点<br>2.把支点左旋降级，变成左子节点<br>3.原先的右子节点变成新的父节点，并把多余的左子节点出让，给已经降级的根节点当右子节点<br>右旋：<br>1.从添加的节点开始，不断的往父节点找不平衡的节点，以不平衡的点作为支点<br>2.把支点右旋降级，变成右子节点<br>3.原先的左子节点变成新的父节点，并把多余的右子节点出让，给已经降级的根节点当左子节点</p><h3 id="红黑树">红黑树</h3><p>1.红黑树是一种自平衡的二叉查找树，是计算机科学中用到的一种数据结构<br>2.它是一种特殊的二叉查找树，红黑树的每一个节点上都有存储位表示节点的颜色<br>3.每一个节点可以是红或者黑;红黑树不是高度平衡的，它的平衡是通过&quot;红黑规则&quot;进行实现的</p><h4 id="红黑规则">红黑规则</h4><p>1.每一个节点或是红色的，或者是黑色的<br>2.根节点必须是黑色<br>3.如果一个节点没有子节点或者父节点，则该节点相应的指针属性值为Nil，这些Nil视为叶节点，每个叶节点(Nil)是黑色的<br>4.如果某一个节点是红色，那么它的子节点必须是黑色(不能出现两个红色节点相连的情况)<br>5.对每一个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点;</p><h4 id="添加节点的规则">添加节点的规则</h4><img src="/post-img/Pasted image 20230719163729.png" alt="图片损坏" style="zoom:100%;" /><h2 id="Set">Set</h2><p>特点：<br>1.无序：存取顺序不一致<br>2.不重复：可以去除重复<br>3.无索引：没有带索引的方法，所以不能使用普通for循环遍历，也不能通过索引获取元素<br>Set接口中的方法基本与collection中的API一致（没有自己的方法）</p><h3 id="HashSet">HashSet</h3><p>无序、不重复、无索引</p><h4 id="底层原理-3">底层原理</h4><p>1.HashSet集合底层采取哈希表存储数据<br>2.哈希表是一种对于增删改查数据性能都较好的结构<br>在JDK8之前，采用数组+链表<br>从JDK8开始，采用数组+链表+红黑树</p><h4 id="创建过程">创建过程</h4><p>1.创建一个默认长度16，默认加载因子为0.75的数组，数组名table<br>2.根据元素的哈希值跟数组的长度计算出应存入的位置<br>3.判断当前位置是否为null，如果是null直接存入<br>如果位置不为null，表示有元素，则调用equals方法比较属性值<br>一样:不存；不一样:存入数组，形成链表<br>JDK8以前:新元素存入数组，老元素挂在新元素下面<br>JDK8以后:新元素直接挂在老元素下面</p><h5 id="哈希值">哈希值</h5><p>1.根据hashcode方法算出来的int类型的整数<br>2.该方法定义在Object类中，所有对象都可以调用，默认使用地址值进行计算<br>3.一般情况下，会重写hashCode方法，利用对象内部的属性值计算哈希值<br>如果没有重写hashCode方法，不同对象计算出的哈希值是不同的<br>如果已经重写hashcode方法，不同的对象只要属性值相同，计算出的哈希值就是一样的<br>在小部分情况下，不同的属性值或者不同的地址值计算出来的哈希值也有可能一样。(哈希碰撞)</p><h4 id="一些问题">一些问题</h4><p>1.HashSet集合的底层数据结构是什么样的?<br>数组+链表（+红黑树）<br>2.HashSet添加元素的过程?<br>数组-&gt;链表-&gt;红黑树<br>3.HashSet为什么存和取的顺序不一样?<br>哈希值计算出来的数组序号不是按顺序排列的<br>4.HashSet为什么没有索引?<br>数组每个索引下都有链表，链表中每个数据在数组中的索引是相同的<br>5.HashSet是利用什么机制保证去重的?<br>利用hashcode和equals方法<br>因此如果向HashSet中存储自定义对象时，必须要重写这两个方法以达到去重的目的</p><h3 id="LinkedHashSet">LinkedHashSet</h3><p>有序、不重复、无索引</p><h4 id="底层原理-4">底层原理</h4><p>底层数据结构依然是哈希表，只是每个元素又额外的多了一个双链表的机制记录存储的顺序</p><h3 id="TreeSet">TreeSet</h3><p>可排序、不重复、无索引</p><h4 id="底层原理-5">底层原理</h4><p>底层是基于红黑树的数据结构实现排序的，增删改查性能都较好</p><h4 id="排序方式">排序方式</h4><h5 id="默认排序方式">默认排序方式</h5><p>使用TreeSet存储数据后读取时，如果不指定排序方式，java会按照默认的顺序排序后输出<br>对于数值类型: Integer , Double，默认按照从小到大的顺序进行排序。对于字符、字符串类型:按照字符在ASCII码表中的数字升序进行排序。</p><h5 id="实现Comparable接口">实现Comparable接口</h5><p>对于自定义对象或者想要指定排序方式的数值、字符类型的对象，可以通过实现Comparable接口来指定排序方式</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line"><span class="comment">//指定排序的规则</span></span><br><span class="line"><span class="comment">//只看年龄，我想要按照年龄的升序进行排列</span></span><br><span class="line"><span class="comment">//this表示当前要添加的元素；o表示已经在红黑树中存在的元素</span></span><br><span class="line"><span class="comment">//返回值为负数，认为当前添加的元素是小的，存左边</span></span><br><span class="line"><span class="comment">//返回值为正数，认为当前添加的元素是大的，存右边</span></span><br><span class="line"><span class="comment">//0，当前元素已经存在，舍弃</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.getAge() - o.getAge();</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="传递比较器Comparator">传递比较器Comparator</h5><p>当实现Comparable接口无法满足需求时，可以在创建TreeSet对象的时候，传递比较器Comparator(匿名内部类对象)指定规则</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后续可以简化为Lambda表达式</span></span><br><span class="line"><span class="title class_">TreeSet</span>&lt;<span class="built_in">string</span>&gt; ts = <span class="keyword">new</span> <span class="title class_">Treeset</span>&lt;&gt;(<span class="keyword">new</span> comparator&lt;<span class="title class_">String</span>&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> int <span class="title function_">compare</span>(<span class="params"><span class="built_in">string</span> o1，<span class="built_in">string</span> o2</span>)&#123;</span><br><span class="line"><span class="comment">//按照长度排序</span></span><br><span class="line">int i = o1.<span class="title function_">length</span>() - o2.<span class="title function_">length</span>();</span><br><span class="line"><span class="comment">//如果一样长则按照首字母排序</span></span><br><span class="line">i = i == <span class="number">0</span> ? o1.<span class="title function_">compareTo</span>(o2) : i;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="对比选择">对比选择</h3><p><strong>1.如果想要集合中的元素可重复</strong><br>用ArrayList集合，基于数组的。(用的最多)<br><strong>2.如果想要集合中的元素可重复，而且当前的增删操作明显多于查询</strong><br>用LinkedList集合，基于链表的。<br><strong>3.如果想对集合中的元素去重</strong><br>用HashSet集合，基于哈希表的。(用的最多)<br><strong>4.如果想对集合中的元素去重，而且保证存取顺序</strong><br>用LinkedHashSet集合，基于哈希表和双链表，效率低于HashSet。<br><strong>5.如果想对集合中的元素进行排序</strong><br>用TreeSet集合，基于红黑树。后续也可以用List集合实现排序。</p><h1>双列集合</h1><h2 id="双列集合的特点">双列集合的特点</h2><p>1.双列集合一次需要存一对数据,分别为键和值<br>2.键不能重复，值可以重复<br>3.键和值是一一对应的，每一个键只能找到自己对应的值<br>4.键＋值这个整体我们称之为“键值对”或者“键值对对象”，在Java中叫做“Entry对象”</p><h2 id="Map的常见API">Map的常见API</h2><img src="/post-img/Pasted image 20230719164300.png" alt="图片损坏" style="zoom:100%;" /><h3 id="部分方法的细节-2">部分方法的细节</h3><p><strong>put() 添加或覆盖</strong><br>在添加数据的时候，如果键不存在，那么直接把键值对对象添加到map集合当中,方法返回null<br>在添加数据的时候，如果键是存在的，那么会把原有的键值对对象覆盖，会把被覆盖的值进行返回。</p><h2 id="Map的遍历">Map的遍历</h2><h3 id="键找值">键找值</h3><p>先通过keySet()方法获取每一个键，再通过键寻找到每一个值，从而遍历<br>可以采用增强for，迭代器和lambda表达式的方法</p><h3 id="键值对">键值对</h3><p>通过entrySet()方法获取所有的键值对对象，返回一个Set集合<br>可以采用增强for，迭代器和lambda表达式的方法</p><h3 id="Lambda表达式">Lambda表达式</h3><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//forEach的底层就是利用键值对的方法遍历的</span></span><br><span class="line"><span class="built_in">map</span>.forEach(<span class="literal">new</span> BiC onsumer&lt;<span class="built_in">String</span>,<span class="built_in">String</span>&gt;()&#123;</span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="literal">void</span> accept(<span class="built_in">String</span> key,<span class="built_in">String</span> value)&#123;</span><br><span class="line">System.out.println(key + <span class="string">&quot;=” + value);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">//可以简化为Lambda表达式</span></span><br><span class="line"><span class="string">map.forEach((key,value)-&gt;System.out.println(key+ &quot;</span>=<span class="string">&quot; +value));</span></span><br></pre></td></tr></table></figure><h2 id="HashMap">HashMap</h2><p>1.HashMap是Map里面的一个实现类。<br>2.没有额外需要学习的特有方法，直接使用Map里面的方法就可以了。<br>3.特点都是由键决定的:<strong>无序、不重复、无索引</strong><br>4.HashMap跟HashSet底层原理是一模一样的，都是哈希表结构<br>链表长度超过8且数组长度超过64时，会自动转为红黑树<br>5.依赖hashcode方法和equals方法保证键的唯一<br>如果键存储的是自定义对象，需要重写hashCode和equals方法<br>如果值存储的是自定义对象,，不需要重写hashCode和equals方法</p><h2 id="LinkedHashMap">LinkedHashMap</h2><p>1.由键决定:<strong>有序、不重复、无索引</strong><br>2.这里的有序指的是保证存储和取出的元素顺序一致<br>3.原理︰底层数据结构是依然哈希表，只是每个键值对元素又额外的多了一个双链表的机制记录存储的顺序。</p><h2 id="TreeMap">TreeMap</h2><p>1.TreeMap跟TreeSet底层原理一样，都是红黑树结构的，增删改查性能好<br>2.由键决定特性:<strong>不重复、无索引、可排序</strong><br>3.可排序:对键进行排序<br>默认按照键的从小到大进行排序，也可以自己规定键的排序规则（实现Comparable接口、传递比较器Comparator）</p><h2 id="可变参数">可变参数</h2><p>方法形参的个数可以发生变化<br>格式：属性类型…名字（int…args）<br>它的底层就是一个数组，只不过不用我们自己创建<br>注意：<br>1.方法的形参中最多只能写一个可变参数<br>2.在方法参数中，如果除了可变参数还有其他参数，可变参数要作为最后一个参数</p><h2 id="Collections">Collections</h2><p>不是集合，是一个工具类</p><h3 id="常用API：">常用API：</h3><img src="/post-img/Pasted image 20230719171244.png" alt="图片损坏" style="zoom:100%;" />]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合底层</title>
      <link href="/posts/9c3dc02c.html"/>
      <url>/posts/9c3dc02c.html</url>
      
        <content type="html"><![CDATA[<h1>ArrayList</h1><h2 id="继承结构和层次关系">继承结构和层次关系</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;  </span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></table></figure><ol><li>可以看出ArratList是继承了AbstractList，这是因为抽象类中可以有抽象方法，还可以有具体的实现方法，AbstractList是实现List接口中一些通用的方法，而ArrayList就继承这个AbstractList类，拿到一些通用的方法，然后自己再实现一些自己特有的方法，这样一来，让代码更简洁，并且如果需要实现其它List，也可以使其继承AbstractList从而实现代码复用</li><li>实现List接口作用不明，可能是为了查看代码方便，使观看者了解到其是List的一种实现（尽管是通过继承AbstractList间接实现）</li><li>RandomAccess 是一个标记接口，用于表明一个类的实例支持随机访问。具体来说，实现了 <code>RandomAccess</code> 接口的类可以通过索引直接访问其元素，而不需要进行迭代<code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口，因为它内部使用数组实现，可以快速随机访问元素。</li><li>Cloneable 是一个标记接口，用于表示类的实例可以被克隆。实现了 <code>Cloneable</code> 接口的类，可以通过 <code>Object</code> 类中的 <code>clone()</code> 方法创建该类的副本。<code>ArrayList</code> 实现了 <code>Cloneable</code> 接口，因此可以通过 <code>clone()</code> 方法复制 <code>ArrayList</code> 的实例。</li><li>Serializable是一个标记接口，用于表示类的实例可以被序列化。序列化是将对象转换为字节流的过程，可以用于对象的存储和网络传输。<code>ArrayList</code> 实现了 <code>Serializable</code> 接口，因此可以通过 Java 序列化机制将 <code>ArrayList</code> 的实例转换为字节流进行存储和传输。</li></ol><h2 id="构造方法">构造方法</h2><p>ArrayList提供了三种构造方法：</p><ol><li>public ArrayList()</li><li>public ArrayList(int initialCapacity)</li><li>public ArrayList(Collection&lt;? extends E&gt; c)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过无参构造可以发现ArrayList底层就是一个<strong>Object[]数组</strong>，并且初始化时是空的，这说明它其实是<strong>懒加载</strong></p><h2 id="添加元素：add">添加元素：add</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `E e`：要添加到 `ArrayList` 的元素。</span></span><br><span class="line"><span class="comment">// `Object[] elementData`：`ArrayList` 内部用于存储元素的数组。</span></span><br><span class="line"><span class="comment">// `int s`：当前 `ArrayList` 中已经存储的元素数量（即大小）。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E e, Object[] elementData, <span class="type">int</span> s)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (s == elementData.length)  </span><br><span class="line">        elementData = grow();  </span><br><span class="line">    elementData[s] = e;  </span><br><span class="line">    size = s + <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加元素的add方法按如下流程执行：</p><ol><li>方法检查当前 <code>ArrayList</code> 中是否有足够的容量来存储新的元素。如果内部数组 <code>elementData</code> 的长度 <code>s</code> 等于 <code>elementData.length</code>，意味着数组已经满了，需要调用 <code>grow()</code> 方法来扩容。</li><li>将元素 <code>e</code> 添加到内部数组的第 <code>s</code> 个位置（数组索引从0开始）。</li><li>更新 <code>ArrayList</code> 的大小 <code>size</code>，将其设为 <code>s + 1</code>，表示添加了一个新元素。</li></ol><h2 id="动态扩容：grow">动态扩容：grow</h2><p>通过上述观察add源码，我们可以发现ArrayList动态扩容的关键方法就是grow方法，其实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object[] grow(<span class="type">int</span> minCapacity) &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;  </span><br><span class="line">    <span class="keyword">if</span> (oldCapacity &gt; <span class="number">0</span> || elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> ArraysSupport.newLength(oldCapacity,  </span><br><span class="line">                minCapacity - oldCapacity, <span class="comment">/* minimum growth */</span>  </span><br><span class="line">                oldCapacity &gt;&gt; <span class="number">1</span>           <span class="comment">/* preferred growth */</span>);  </span><br><span class="line">        <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> Arrays.copyOf(elementData, newCapacity);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="type">return</span> <span class="variable">elementData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>[Math.max(DEFAULT_CAPACITY, minCapacity)];  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法按以下流程对ArrayList进行扩容：</p><ol><li>获取当前内部数组 <code>elementData</code> 的旧容量 <code>oldCapacity</code>。</li><li>检查旧容量是否大于0，或者 <code>elementData</code> 是否等于 <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>（即之前提到的懒加载初始化的空数组）</li><li>如果上述条件成立，计算出新容量 <code>newCapacity</code>，这里使用了一个辅助方法 <code>ArraysSupport.newLength()</code> 来确定新容量的大小。该方法会根据旧容量、最小增长量和首选增长量来计算新的容量。</li><li>使用 <code>Arrays.copyOf()</code> 方法创建一个新的数组，并将旧数组中的元素拷贝到新数组中，最后返回新数组。</li><li>如果上述条件不成立（即当前内部数组为空），则直接创建一个新的 <code>Object</code> 类型数组，其长度为 <code>DEFAULT_CAPACITY</code> 和 <code>minCapacity</code> 中的较大值，并返回该数组。 <code>DEFAULT_CAPACITY</code> 是 <code>ArrayList</code> 内部的默认初始容量10。<br>也就是说，<strong>当第一次添加元素时，ArrayList会给一个初始容量为10的数组；后续每次添加元素时如果数组长度不够，会动态计算出新的数组长度，并采用复制的方法进行元素转移完成添加元素时的扩容</strong></li></ol><h2 id="计算新数组长度：newLength和hugeLength">计算新数组长度：newLength和hugeLength</h2><p>它们都是ArraysSupport中的静态方法，作用是根据旧数组的长度以及最小增长量和首选增长量来确定新数组的长度。</p><ul><li><strong>最小增长量（minGrowth）</strong>：这个值表示在确定新数组长度时，至少需要增加的元素数量。即使在当前情况下并不需要这么多的增长，但至少会增加这么多的容量。这个值通常用于确保扩容操作不会频繁地触发，以提高性能。</li><li><strong>首选增长量（prefGrowth）</strong>：这个值表示在确定新数组长度时的首选增长数量。当需要扩容时，新数组的长度会增加至少这个值，但如果需求更大，那么新数组的长度会相应地增加更多。这个值通常用于平衡内存的使用和性能之间的权衡，以及减少扩容操作的次数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">newLength</span><span class="params">(<span class="type">int</span> oldLength, <span class="type">int</span> minGrowth, <span class="type">int</span> prefGrowth)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">prefLength</span> <span class="operator">=</span> oldLength + Math.max(minGrowth, prefGrowth); </span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &lt; prefLength &amp;&amp; prefLength &lt;= SOFT_MAX_ARRAY_LENGTH) &#123;  </span><br><span class="line">        <span class="keyword">return</span> prefLength;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">// put code cold in a separate method  </span></span><br><span class="line">        <span class="keyword">return</span> hugeLength(oldLength, minGrowth);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hugeLength</span><span class="params">(<span class="type">int</span> oldLength, <span class="type">int</span> minGrowth)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">minLength</span> <span class="operator">=</span> oldLength + minGrowth;  </span><br><span class="line">    <span class="keyword">if</span> (minLength &lt; <span class="number">0</span>) &#123; <span class="comment">// overflow  </span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>(  </span><br><span class="line">            <span class="string">&quot;Required array length &quot;</span> + oldLength + </span><br><span class="line">            <span class="string">&quot; + &quot;</span> + minGrowth + <span class="string">&quot; is too large&quot;</span>);  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minLength &lt;= SOFT_MAX_ARRAY_LENGTH) &#123;  </span><br><span class="line">        <span class="keyword">return</span> SOFT_MAX_ARRAY_LENGTH;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> minLength;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newLength方法中的步骤如下：</p><ol><li>计算出首选长度 <code>prefLength</code>，它等于旧长度加上最小增长量和首选增长量中的较大值。这里的 <code>prefLength</code> 可能会溢出，但是因为这个方法是内联的，所以预先条件没有被检查。</li><li>检查 <code>prefLength</code> 是否在 0 到 <code>SOFT_MAX_ARRAY_LENGTH</code> 之间（<code>SOFT_MAX_ARRAY_LENGTH</code> 是一个软限制，表示数组的最大长度）。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在保留了足够大的数组长度的同时，为额外的元数据留出了一些空间。这样做的目的是为了在不同的 JVM 实现中都能保证数组长度不会超出最大值并且不会发生溢出</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SOFT_MAX_ARRAY_LENGTH</span> <span class="operator">=</span> Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>如果 <code>prefLength</code> 符合条件，则直接返回该值作为新数组的长度。</li><li>如果 <code>prefLength</code> 超出范围，则调用另一个方法 <code>hugeLength()</code>，这个方法会针对超出软限制的情况进行处理，并返回新数组的长度。<br>hugeLength方法中的步骤如下：</li><li>计算出最小长度 <code>minLength</code>，它等于旧长度加上最小增长量。这里的 <code>minLength</code> 可能会溢出，但是在溢出之前会先进行判断。</li><li>检查 <code>minLength</code> 是否小于0，如果小于0，则表示溢出了，抛出 <code>OutOfMemoryError</code> 异常。</li><li>如果 <code>minLength</code> 小于等于软限制 <code>SOFT_MAX_ARRAY_LENGTH</code>，则返回软限制作为新数组的长度。</li><li>如果 <code>minLength</code> 超出了软限制，则直接返回 <code>minLength</code> 作为新数组的长度。<br><strong>综上我们可以总结出ArrayList扩容后新数组与旧数组之间的长度关系，有几种可能：</strong></li><li><strong>如果原数组长度的1.5倍仍在软限制范围内，则直接返回1.5倍</strong></li><li><strong>如果原数组长度的1.5倍已经超过限制，比较现在所需的最小长度与软限制之间的关系</strong><ul><li><strong>若最小长度已经为负数，表明元素数目已经超出int最大值，抛异常</strong></li><li><strong>若最小长度小于软限制，返回软限制（无法达到1.5倍，就尽可能大）</strong></li><li><strong>若最小长度大于软限制，返回最小长度</strong></li></ul></li></ol><h1>LinkedList</h1><h2 id="继承结构和层次关系-2">继承结构和层次关系</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractSequentialList</span>&lt;E&gt; </span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123;</span><br></pre></td></tr></table></figure><ul><li><code>List</code> : 表明它是一个列表，支持添加、删除、查找等操作，并且可以通过下标进行访问。</li><li><code>Deque</code> ：继承自 <code>Queue</code> 接口，具有双端队列的特性，支持从两端插入和删除元素，方便实现栈和队列等数据结构。</li><li><code>Cloneable</code> ：表明它具有拷贝能力，可以进行深拷贝或浅拷贝操作。</li><li><code>Serializable</code> : 表明它可以进行序列化操作，也就是可以将对象转换为字节流进行持久化存储或网络传输，非常方便。</li></ul><h2 id="节点：node">节点：node</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;  </span><br><span class="line">    E item;  </span><br><span class="line">    Node&lt;E&gt; next;  </span><br><span class="line">    Node&lt;E&gt; prev;  </span><br><span class="line">  </span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;  </span><br><span class="line">        <span class="built_in">this</span>.item = element;  </span><br><span class="line">        <span class="built_in">this</span>.next = next;  </span><br><span class="line">        <span class="built_in">this</span>.prev = prev;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，LinkedList每个元素都保存着前一个和后一个元素的指针，因此它是一个双向链表<br>除此之外，它还维护了头节点和尾节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><h2 id="构造方法-2">构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个空的链表对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">()</span> &#123; &#125; </span><br><span class="line"><span class="comment">// 接收一个集合类型作为参数，会创建一个与传入集合相同元素的链表对象 </span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123; </span><br><span class="line"><span class="built_in">this</span>(); </span><br><span class="line">addAll(c); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加、插入元素：add">添加、插入元素：add</h2><p>LinkedList提供了重载的两个add方法，分别支持直接在尾部添加元素和在指定索引前面插入元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;  </span><br><span class="line">    linkLast(e);  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;  </span><br><span class="line">    checkPositionIndex(index);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (index == size)  </span><br><span class="line">        linkLast(element);  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    <span class="comment">//node(index) 用于指向第index个节点并返回它</span></span><br><span class="line">        linkBefore(element, node(index));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取元素">获取元素</h2><ol><li><code>getFirst()</code>：获取链表的第一个元素。</li><li><code>getLast()</code>：获取链表的最后一个元素。</li><li><code>get(int index)</code>：获取链表指定位置的元素。</li></ol><h2 id="删除元素">删除元素</h2><ul><li><code>removeFirst()</code>：删除并返回链表的第一个元素。</li><li><code>removeLast()</code>：删除并返回链表的最后一个元素。</li><li><code>remove(E e)</code>：删除链表中首次出现的指定元素，如果不存在该元素则返回 false。</li><li><code>remove(int index)</code>：删除指定索引处的元素，并返回该元素的值。</li><li><code>void clear()</code>：移除此链表中的所有元素。</li></ul><h1>HashMap</h1><h2 id="继承结构和层次关系-3">继承结构和层次关系</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;  </span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable </span><br></pre></td></tr></table></figure><h2 id="底层数据结构">底层数据结构</h2><p>HashMap底层的数据结构是数组+链表+红黑树</p><h3 id="数组">数组</h3><p>HashMap维护了成员变量Node数组来存储元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><h3 id="链表">链表</h3><p>数组中存放链表的头节点，各节点组成链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;  </span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;  </span><br><span class="line">    <span class="keyword">final</span> K key;  </span><br><span class="line">    V value;  </span><br><span class="line">    Node&lt;K,V&gt; next;  </span><br><span class="line">  </span><br><span class="line">    Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;  </span><br><span class="line">        <span class="built_in">this</span>.hash = hash;  </span><br><span class="line">        <span class="built_in">this</span>.key = key;  </span><br><span class="line">        <span class="built_in">this</span>.value = value;  </span><br><span class="line">        <span class="built_in">this</span>.next = next;  </span><br><span class="line">    &#125;</span><br><span class="line">    ···（其它方法）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="红黑树">红黑树</h3><p>jdk8之后的优化，当链表长度过长时，会将链表转化为红黑树以增加元素插入和查询的效率</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;  </span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links  </span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;  </span><br><span class="line">    TreeNode&lt;K,V&gt; right;  </span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion  </span></span><br><span class="line">    <span class="type">boolean</span> red;  </span><br><span class="line">    TreeNode(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;  </span><br><span class="line">        <span class="built_in">super</span>(hash, key, val, next);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * Returns root of tree containing this node.     </span></span><br><span class="line"><span class="comment">     * */</span>    </span><br><span class="line">    <span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title function_">root</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="built_in">this</span>, p;;) &#123;  </span><br><span class="line">            <span class="keyword">if</span> ((p = r.parent) == <span class="literal">null</span>)  </span><br><span class="line">                <span class="keyword">return</span> r;  </span><br><span class="line">            r = p;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    ···（其它方法）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造方法-3">构造方法</h2><p>HashMap提供了四种构造方法：</p><ol><li>public HashMap(int initialCapacity, float loadFactor)</li><li>public HashMap(int initialCapacity)</li><li>public HashMap()</li><li>public HashMap(Map&lt;? extends K, ? extends V&gt; m)<br>使用构造方法时，为初始容量赋值时，尽量赋为2的次幂，这有利于提升底层hash的效率；<br>不过就算没有这么做，HashMap进行初始化时也会取小于给定容量的最大2的次幂，例如，赋值20，最终得到的是长度为16的HashMap<br>负载因子（loadFactor）的默认值为0.75，当已用空间/总空间大于等于该值时，会进行扩容为原来的两倍，例如，当长度为16的HashMap存放了12个以上元素时，会扩容为32</li></ol><h2 id="添加元素">添加元素</h2><p>HashMap中的元素是无序的（添加顺序和存储顺序不一致），这与它添加元素时的操作有关</p><h3 id="hash">hash</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> h;  </span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过该方法可以看出，当传入元素（key）不为null时，进行了两步来进行hash</p><ol><li>调用对象的 <code>hashCode()</code> 方法获取哈希码，并将结果保存到变量 <code>h</code> 中。</li><li>执行一个位运算，将 <code>h</code> 右移 16 位，并与 <code>h</code> 进行异或操作（^）。这一步是为了增加哈希值的随机性，以减少哈希冲突的可能性。</li></ol><h3 id="putVal">putVal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,  </span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;  </span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;  </span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)  </span><br><span class="line">        n = (tab = resize()).length;  </span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)  </span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);  </span><br><span class="line">    <span class="keyword">else</span> &#123;  </span><br><span class="line">        Node&lt;K,V&gt; e; K k;  </span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;  </span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))  </span><br><span class="line">            e = p;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)  </span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);  </span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;  </span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;  </span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);  </span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st  </span></span><br><span class="line">                        treeifyBin(tab, hash);  </span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;  </span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))  </span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                p = e;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key  </span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;  </span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)  </span><br><span class="line">                e.value = value;  </span><br><span class="line">            afterNodeAccess(e);  </span><br><span class="line">            <span class="keyword">return</span> oldValue;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ++modCount;  </span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)  </span><br><span class="line">        resize();  </span><br><span class="line">    afterNodeInsertion(evict);  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先，获取当前 HashMap 的数组 <code>table</code>，并获取数组长度 <code>n</code>。</li><li>判断数组是否为空，若为空，调用 <code>resize()</code> 方法进行初始化，并重新获取数组长度 <code>n</code>。</li><li>计算键在数组中的位置 <code>i</code>。（hash方法计算出的值与数组长度-1进行<code>&amp;</code>运算）</li><li>判断该位置是否为空，如果为空，则直接在该位置插入新节点。</li><li>如果该位置不为空，且节点的哈希值和键与要插入的相同，则更新该节点的值。</li><li>如果该位置的节点是树节点，则调用树节点的 <code>putTreeVal</code> 方法进行插入。</li><li>否则，遍历链表，查找是否存在相同的键。<strong>如果存在，则更新值；如果不存在，则将新节点插入到链表尾部</strong>，并根据链表长度进行相应的处理（是否需要转化为红黑树，调用treeifyBin方法转换，这里的阈值TREEIFY_THRESHOLD - 1为7，由于长度从0开始计数，因此<strong>当链表长度为8时进行转换</strong>）。</li><li>如果找到了相同的键，则更新值，并返回旧值；否则，返回 null。</li><li>更新 HashMap 的修改次数 <code>modCount</code>，并根据大小阈值判断是否需要进行 resize 操作。</li><li>调用 <code>afterNodeInsertion</code> 方法，进行插入后的操作。</li><li>返回旧值（如果存在）或 null。</li></ol><h2 id="扩容：resize">扩容：resize</h2><p>resize方法源码过长，这里不再展示，仅进行说明</p><ol><li>数组的初始化以及扩容均通过resize进行，都是通过创建一个新的数组，长度为默认长度或原数组的两倍</li><li>获取旧的数组 <code>oldTab</code>、旧的数组长度 <code>oldCap</code> 和阈值 <code>oldThr</code>。</li><li>根据旧数组的情况确定新数组的大小 <code>newCap</code> 和新的阈值 <code>newThr</code>。<ul><li>如果当前数组长度为0，创建默认长为16的数组</li><li>如果当前数组长度大于2的30次方（扩大两倍后超出int最大值），创建长为int最大值的数组</li><li>创建长度为原数组长度两倍的数组</li></ul></li><li>将旧数组中的元素重新分配到新数组中（复制），涉及到链表节点、红黑树节点等情况的处理。</li><li>扩容过程会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。</li></ol><h1>ConcurrentHashMap</h1><p>ConcurrentHashMap1.7与1.8的实现有点区别，下面主要是解析1.8之后的实现</p><h2 id="继承结构和层次关系-4">继承结构和层次关系</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrentHashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;  </span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">ConcurrentMap</span>&lt;K,V&gt;, Serializable </span><br></pre></td></tr></table></figure><p>ConcurrentMap 接口是一个扩展了 Map 接口的并发安全的接口，它提供了一些<strong>支持并发访问</strong>的方法。</p><h2 id="构造方法-4">构造方法</h2><ol><li>public ConcurrentHashMap()</li><li>public ConcurrentHashMap(int initialCapacity)</li><li>public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m)</li><li>public ConcurrentHashMap(int initialCapacity, float loadFactor)</li><li>public ConcurrentHashMap(int initialCapacity,  float loadFactor, int concurrencyLevel)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> initialCapacity 初始容量  </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> loadFactor 负载因子  </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> concurrencyLevel 并发级别</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity,  </span></span><br><span class="line"><span class="params">                         <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();  </span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel)   <span class="comment">// Use at least as many bins  </span></span><br><span class="line">        initialCapacity = concurrencyLevel;   <span class="comment">// as estimated threads  </span></span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">long</span>)(<span class="number">1.0</span> + (<span class="type">long</span>)initialCapacity / loadFactor);  </span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> (size &gt;= (<span class="type">long</span>)MAXIMUM_CAPACITY) ?  </span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="type">int</span>)size);  </span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = cap;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有几个细节需要注意：</p><ol><li>并发级别指的是 ConcurrentHashMap 在内部使用的分段锁的数量，也就是内部数据结构中的桶（bins）的数量。在 ConcurrentHashMap 中，数据被分成多个段（segments），每个段上都有一把锁，这样不同的线程可以同时对不同的段进行操作，从而提高了并发性能。</li><li>初始容量必须大于并发级别</li><li>参数initialCapacity并不是指定最终的数组大小，内部经过了计算，最终的值一定是2的幂（通过tableSizeFor方法保证）</li></ol><h3 id="关于sizeCtl">关于sizeCtl</h3><p><code>sizeCtl</code> 的作用是作为一个控制参数，用于监控 ConcurrentHashMap 的状态并在需要时触发扩容、收缩或其他调整大小的操作。</p><ol><li><strong>负数值</strong>:<ul><li>当 <code>sizeCtl</code> 的值为负数时，表示 ConcurrentHashMap 正在进行初始化，扩容或收缩等操作。具体的值代表了当前操作的状态和进度。</li><li>例如，如果 <code>sizeCtl</code> 的值为 <code>-1</code>，表示 ConcurrentHashMap 正在进行初始化。</li><li>如果 <code>sizeCtl</code> 的值为 <code>-N</code>（N 大于 1），表示 ConcurrentHashMap 正在进行扩容操作，其中 <code>-N</code> 代表当前正在进行扩容的阶段（比如 <code>-2</code> 表示第二阶段扩容）。</li></ul></li><li><strong>零值</strong>:<ul><li>当 <code>sizeCtl</code> 的值为零时，表示 ConcurrentHashMap 的初始化已经完成，且当前没有扩容或收缩操作在进行。</li></ul></li><li><strong>正数值</strong>:<ul><li>当 <code>sizeCtl</code> 的值为正数时，表示 ConcurrentHashMap 中的有效元素数量的估计值。这个值是通过哈希表中的节点数量和状态信息计算得出的，并且可能会用于触发扩容操作。</li><li>如果 <code>sizeCtl</code> 的值大于等于 <code>MIN_TREEIFY_CAPACITY</code>，则表示需要将桶（bucket）转换为红黑树结构。</li><li>如果 <code>sizeCtl</code> 的值小于零但不是负数，并且不是 <code>MIN_TREEIFY_CAPACITY</code>，则表示 ConcurrentHashMap 正在进行收缩操作。</li></ul></li></ol><h2 id="初始化initTable">初始化initTable</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes table, using the size recorded in sizeCtl.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//　如果 sizeCtl &lt; 0 ,说明另外的线程执行CAS 成功，正在进行初始化。</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 让出 CPU 使用权</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>初始化是通过<strong>自旋和 CAS</strong> 操作完成的。</li><li>返回的结果是node数组（并且这里的node实现自Map.Entry）</li><li>通过sizeCtl控制当前的初始化状态</li></ol><h2 id="加入元素putVal">加入元素putVal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span>  </span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();  </span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());  </span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;  </span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh; K fk; V fv;  </span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)  </span><br><span class="line">        <span class="comment">//数组桶为空，初始化数组桶（自旋+CAS)</span></span><br><span class="line">            tab = initTable();  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;  </span><br><span class="line"><span class="comment">// 桶内为空，CAS 放入，不加锁，成功了就直接 break 跳出</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value)))  </span><br><span class="line">                <span class="keyword">break</span>;                <span class="comment">// no lock when adding to empty bin  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)  </span><br><span class="line">            tab = helpTransfer(tab, f);  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (onlyIfAbsent <span class="comment">// check first node without acquiring lock  </span></span><br><span class="line">                 &amp;&amp; fh == hash  </span><br><span class="line">                 &amp;&amp; ((fk = f.key) == key || (fk != <span class="literal">null</span> &amp;&amp; key.equals(fk)))  </span><br><span class="line">                 &amp;&amp; (fv = f.val) != <span class="literal">null</span>)  </span><br><span class="line">            <span class="keyword">return</span> fv;  </span><br><span class="line">        <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line"><span class="comment">//使用 synchronized 加锁加入节点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;  </span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">                        binCount = <span class="number">1</span>;  </span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;  </span><br><span class="line">                            K ek;  </span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;  </span><br><span class="line">                                ((ek = e.key) == key ||  </span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;  </span><br><span class="line">                                oldVal = e.val;  </span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)  </span><br><span class="line">                                    e.val = value;  </span><br><span class="line">                                <span class="keyword">break</span>;  </span><br><span class="line">                            &#125;  </span><br><span class="line">                            Node&lt;K,V&gt; pred = e;  </span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;  </span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value);  </span><br><span class="line">                                <span class="keyword">break</span>;  </span><br><span class="line">                            &#125;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;  </span><br><span class="line">                        Node&lt;K,V&gt; p;  </span><br><span class="line">                        binCount = <span class="number">2</span>;  </span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,  </span><br><span class="line">                                                       value)) != <span class="literal">null</span>) &#123;  </span><br><span class="line">                            oldVal = p.val;  </span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)  </span><br><span class="line">                                p.val = value;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ReservationNode)  </span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Recursive update&quot;</span>);  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)  </span><br><span class="line">                    treeifyBin(tab, i);  </span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)  </span><br><span class="line">                    <span class="keyword">return</span> oldVal;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>putVal方法中的步骤如下:</p><ol><li>检查键值对中的键和值是否为空，如果为空则抛出 NullPointerException 异常。</li><li>计算键的哈希值，并调用 <code>spread</code> 方法对哈希值进行扩散。</li><li>进入无限循环，每次循环都会进行插入操作，直到成功插入元素或者发生了扩容操作。</li><li>在循环中，首先检查哈希表是否为空，如果为空则进行初始化操作，确保哈希表的正确创建。</li><li>然后，通过哈希值找到对应的桶（bucket）。如果桶为空，则尝试原子地(CAS)插入新节点到桶中。如果成功插入，则跳出循环。</li><li>如果桶不为空，进一步判断桶的状态：<ul><li>如果桶状态为 <code>MOVED</code>，则帮助进行数据迁移操作，并继续循环。</li><li>如果插入操作为 <code>putIfAbsent</code>，则尝试在不获取锁的情况下检查第一个节点是否匹配，如果匹配则返回节点值。</li><li>否则，使用同步块锁定桶，进行插入操作。具体插入操作取决于桶的状态：<ul><li>如果桶中为普通节点，则遍历链表进行插入。</li><li>如果桶中为树节点，则调用树节点的插入方法进行插入。</li><li>如果桶中为 <code>ReservationNode</code>，则抛出异常。</li></ul></li><li>插入完成后，如果插入的节点数超过了 <code>TREEIFY_THRESHOLD</code>，则将链表转换为树结构。</li></ul></li><li>最后，更新计数器并返回插入前的旧值（如果存在）。<br>有几个值得注意的点：</li><li>ConcurrentHashMap也是与hashMap一样，使用了数组+链表+红黑树三种数组结构</li><li>ConcurrentHashMap使用了CAS和Sychornized两种方法来支持并发<ul><li>CAS操作用于数组桶为空时，无论哪个线程先进行操作都是可以的，不会出现并发问题，并且它是乐观锁的思想，更轻量级</li><li>Sychornized是悲观锁的思想，针对每个桶（bucket），即node数组的一个索引位置，的操作都是在获取锁后进行的。具体来说，使用了同步块来锁定当前操作的桶，以确保在多线程环境下对桶内元素的修改操作是线程安全的。</li></ul></li></ol><h2 id="获取元素get">获取元素get</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="type">int</span> n, eh; K ek;</span><br><span class="line">    <span class="comment">// key 所在的 hash 位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果指定位置元素存在，头结点hash值相同</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="comment">// key hash 值相等，key值相同，直接返回元素 value</span></span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 头结点hash值小于0，说明正在扩容或者是红黑树，find查找</span></span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="literal">null</span> ? p.val : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 是链表，遍历查找</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>get方法中的步骤如下:</p><ol><li>通过 <code>spread(key.hashCode())</code> 方法计算出 key 的哈希值，以便确定该 key 在哈希表中的位置。</li><li>检查哈希表是否已经初始化并且不为空，以及指定位置的桶是否包含元素。</li><li>如果指定位置的桶不为空，则进一步遍历该桶中的元素：<ul><li>如果头结点的哈希值与给定的 key 的哈希值相等，并且头结点的 key 与给定的 key 相等，则直接返回头结点的值。</li><li>如果头结点的哈希值小于 0，说明该桶正在进行扩容或者已经是一个红黑树结构，则调用头结点的 find 方法来进行查找操作。</li><li>如果不满足以上两种情况，则遍历该桶中的链表，查找与给定 key 相等的元素。</li></ul></li><li>如果遍历结束仍然没有找到匹配的元素，则返回 null。</li></ol><h1>总结</h1><ol><li>ArratList：动态数组，可扩容</li><li>LinkedList：链表</li><li>HashMap：数组+链表+红黑树，可扩容</li><li>ConcurrentHashMap：数组+链表+红黑树，可扩容，通过CAS+Sychornized支持并发</li></ol><h1>补充</h1><h2 id="问题">问题</h2><p>Q：HashMap数组中存放指针指向链表或红黑树头节点，为什么数组可以存放两种指针呢？<br>A：可以看到TreeNode继承自LinkedHashMap.Entry&lt;K,V&gt;，稍微跟进一下就能发现，LinkedHashMap.Entry&lt;K,V&gt;继承自HashMap.Node&lt;K,V&gt;！也就是说，TreeNode实际上是Node的孙子，这也就解释了为什么数组中可以同时存放Node和TreeNode两种对象</p><p>Q：为什么HashMap计算元素索引时使用(n - 1) &amp; hash而非n&amp;hash？<br>A：用一个具体的例子来说明。<br>假设数组长度 <code>n</code> 是 16，即 <code>n = 16</code>，而键的哈希值 <code>hash</code> 是 20，即 <code>hash = 20</code>。<br>如果使用 <code>n &amp; hash</code> 来计算键在数组中的位置，那么计算结果是16，但是数组的长度只有 16，超出了数组的范围；<br>现在使用 <code>(n - 1) &amp; hash</code> 来计算键在数组中的位置，即 <code>(16 - 1) &amp; 20</code>：结果是4，这样计算可以确保结果在数组范围内，并且能够均匀地分布在数组的不同位置。</p>]]></content>
      
      
      <categories>
          
          <category> 源码解析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串</title>
      <link href="/posts/fc81fbfd.html"/>
      <url>/posts/fc81fbfd.html</url>
      
        <content type="html"><![CDATA[<h1>字符串的特点</h1><p>字符串的内容是不会改变的，它的对象在创建后不能被更改<br>（当给字符串变量赋值时，产生了一个新的字符串，两个字符串相加一共有三个字符串参与）</p><h1>构造方式</h1><h2 id="直接赋值">直接赋值</h2><h2 id="new构造函数">new构造函数</h2><p>（参数为空，字符串，字节数组，字符数组（string，byte【】，char【】））</p><h1>字符串的方法</h1><p>equals(string)  ,<br>equalsIgnoreCase(string)  ，<br>String  substring(int beginIndex, int endInde）包头不包尾，包左不包右   返回值是截取的小串<br>String  substring(int beginIndex)  截取到末尾<br>public char charAt(int index)根据索引返回字符<br>public int length()返回字符串的长度<br>public String replace(String target,String replacement)将target替换为replacement</p><h1>字符串拼接</h1><p>”+“从左至右拼接，与&quot;&quot;（空字符串）拼接可以达到将单个字符拼接成字符串的效果</p><h1>StringBuilder</h1><p>一个容器，里面的内容是可变的，提高字符串的操作效率<br>有一个空参构造和形参是一个字符串的构造方法<br>public StringBuilder append (任意类型)      添加数据，并返回对象本身<br>public StringBuilder reverse()      反转容器中的内容<br>public int length()  返回长度（字符出现的个数)<br>public String toString(）把StringBuilder转换为String</p><h1>StringJoiner</h1><p>public StringJoiner (间隔符号)      创建一个StringJoiner对象，指定拼接时的间隔符号<br>public StringJoiner (间隔符号，开始符号，结束符号)     创建一个StringJoiner对象，指定拼接时的间隔符号、开始符号、结束符号<br>add（）<br>length（）<br>toString（）</p><img src="/post-img/Pasted image 20230331170824.png" alt="图片损坏" style="zoom:100%;" /><h1>修改字符串</h1><h2 id="substring">substring</h2><p>用substring进行截取，把左边的字符截取出来拼接到右侧去。</p><h2 id="字符数组">字符数组</h2><p>把字符串先变成一个字符数组，然后调整字符数组里面数据，最后再把字符数组变成字符串。</p><h1>字符串原理小结</h1><p>1.<strong>字符串存储的内存原理</strong><br>直接赋值会复用字符串常量池中的<br>new出来不会复用，而是开辟一个新的空间<br>2.<strong>== 号比较的到底是什么?</strong><br>基本数据类型比较数据值<br>引用数据类型比较地址值<br>3.<strong>字符串拼接的底层原理</strong><br>如果没有变量参与，都是字符串直接相加，编译之后就是拼接之后的结果，会复用串池中的字符串。如果有变量参与，会创建新的字符串，浪费内存。<br>4.<strong>StringBuilder提高效率原理</strong><br>所有要拼接的内容都会往StringBuilder中放，不会创建很多无用的空间，节约内存<br>5.<strong>StringBuilder源码分析</strong><br>默认创建一个长度为16的字节数组<br>添加的内容长度小于16，直接存<br>添加的内容大于16会扩容（原来的容量* 2+2)<br>如果扩容之后还不够，以实际长度为准</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/posts/28239a8d.html"/>
      <url>/posts/28239a8d.html</url>
      
        <content type="html"><![CDATA[<h1>类</h1><h2 id="类的组成部分">类的组成部分</h2><p>成员变量，成员方法，构造器，（内部类，代码块）</p><h2 id="标准的javabean类">标准的javabean类</h2><p>1.类名需要见名知意<br>2.成员变量使用private修饰<br>3.提供至少两个构造方法（无参构造方法和带全部参数的构造方法成员方法）<br>4.提供每一个成员变量对应的setXxx（）/getXxx（）如果还有其他行为，也需要写上</p><h3 id="构造方法">构造方法</h3><p>方法名与类名需完全一致，没有返回值，创建对象时系统自动调用进行对象的初始化<br>没有构造方法时默认调用无参构造方法</p><h3 id="成员变量和局部变量">成员变量和局部变量</h3><img src="/post-img/Pasted image 20230331163238.png" alt="图片损坏" style="zoom:100%;" /><h4 id="this">this</h4><p>可以区分成员变量和局部变量，存储的是所在方法调用者的地址值，采用就近原则</p><h2 id="代码块：">代码块：</h2><h3 id="局部代码块">局部代码块</h3><p>变量的作用范围是一对大括号内，提前结束变量的生命周期</p><h3 id="构造代码块">构造代码块</h3><p>写在成员位置的代码块，可以把多个构造方法中重复的代码抽取出来；创建本类对象的时候会先执行构造代码块，再执行构造方法</p><h3 id="静态代码块">静态代码块</h3><p>通过static关键字修饰，随类的加载而加载，并且自动触发，只执行一次，在类加载的时候，做一些数据初始化的时候使用</p><h2 id="内部类">内部类</h2><h3 id="定义">定义</h3><p>定义在一个类里面的类就是内部类，<br>当B表示的事物是A的一部分，且B单独存在没有意义时，可以将B定义为A的内部类</p><h3 id="分类">分类</h3><h4 id="成员内部类">成员内部类</h4><p>写在成员位置的，属于外部类的成员</p><h5 id="获取方法">获取方法</h5><p>1.当成员内部类被private修饰时。在外部类编写方法，对外提供内部类对象<br>2.当成员内部类被非私有修饰时，直接创建对象。<br>outer.Inner oi = new Outer().new Inner();<br>3.外部类成员变量和内部类成员变量重名时，用”Outer.this.变量名“访问</p><h4 id="静态内部类">静态内部类</h4><p>是一种特殊的成员内部类</p><h5 id="创建对象方式">创建对象方式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Outer.Inner oi=<span class="keyword">new</span> <span class="title class_">Outer</span>.Inner();</span><br></pre></td></tr></table></figure><h5 id="调用其中方法">调用其中方法</h5><p>非静态方法：先创建对象，用对象调用<br>静态方法：外部类名.内部类名.方法名（）；</p><h4 id="局部内部类">局部内部类</h4><p>1.将内部类定义在方法里面就叫做局部内部类，类似于方法里面的局部变量。<br>2.外界无法直接使用，需要在方法内部创建对象并使用。<br>3.该类可以直接访问外部类的成员，也可以访问方法内的局部变量。</p><h4 id="匿名内部类">匿名内部类</h4><p>隐藏了名字的内部类，可以写在成员位置，也可以写在局部位置</p><h5 id="格式">格式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包含了继承或实现，方法重写，创建对象</span></span><br><span class="line"><span class="comment">//整体就是一个类的子类对象或接口的实现对象</span></span><br><span class="line"><span class="comment">//常用于构造函数式接口的实现对象并作为参数传递给方法</span></span><br><span class="line"><span class="comment">//可以理解为一个一次性对象，简化代码，还可以利用lambda表达式进一步简化</span></span><br><span class="line"><span class="keyword">new</span> 类名或接口名()&#123;</span><br><span class="line">重写方法；</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1>修饰符</h1><h2 id="static">static</h2><h3 id="静态变量">静态变量</h3><p>被该类所有对象共享，不属于对象属于类，随着类的加载而加载，优先于对象存在</p><h3 id="静态方法">静态方法</h3><p>多用在测试类和工具类中，javabean类很少使用</p><h4 id="调用方式">调用方式</h4><p>类名调用，对象调用</p><h4 id="工具类">工具类</h4><p>1.类名见名知意<br>2.私有化构造方法<br>3.成员方法用static修饰<br>4.外部无法创建其对象，但是可以调用其中的方法</p><h4 id="注意事项">注意事项</h4><p>静态方法中，只能访问静态变量;    非静态方法可以访问所有;     静态方法中没有this关键字<br><img src="/post-img/Pasted image 20230331172501.png" alt="图片损坏" style="zoom:100%;" /></p><h2 id="final">final</h2><p>修饰方法：不能被重写；<br>修饰类：不能被继承；<br>修饰变量：常量，只能被赋值一次<br>常量：全部大写，多个单词间用下划线隔开<br>修饰基本数据类型，变量存储的数据值不能发生改变<br>修饰引用数据类型，变量存储的地址值不能发生改变，对象内部的值可以改变</p><h2 id="权限修饰符">权限修饰符</h2><img src="/post-img/Pasted image 20230403112615.png" alt="图片损坏" style="zoom:100%;" /><h1>包</h1><p>包就是文件夹，用来管理各种不同功能的java类，方便后期代码维护<br>包名：公司域名反写加包的作用，全英文小写，见名知意<br>使用同一个包中的类时，不需要导包，使用java.lang包中的类时，不需要导包，其他情况需要<br>同时使用两个包中的同名类，需要用全类名（包名.类名）</p><h1>接口</h1><h2 id="接口的定义和使用">接口的定义和使用</h2><p>1.接口是一种规则，是对行为的抽象<br>2.接口用关键字interface来定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><p>3.接口不能实例化<br>4.接口和类之间是实现关系，通过implements关键字表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements接口名&#123;&#125;</span><br></pre></td></tr></table></figure><p>5.接口的子类（实现类)<br>要么重写接口中的所有抽象方法<br>要么是抽象类<br>6.注意:<br>1.接口和类的实现关系，可以单实现，也可以多实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口名<span class="number">1</span>，接口名<span class="number">2</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>2.实现类可以在继承一个类的同时实现多个接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 extends父类 implements 接口名<span class="number">1</span>，接口名<span class="number">2</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>7.接口代表规则，是行为的抽象，想让哪个类拥有一个行为，就让这个类实现对应的接口<br>8.当一个方法的参数是接口时，可以传递接口所有实现类的对象，称为接口多态</p><h2 id="接口中成员的特点：">接口中成员的特点：</h2><p>1.成员变量只能是常量（默认修饰符public static final）<br>2.没有构造方法<br>3.（JDK7）成员方法只能是抽象方法（默认修饰符public abstract）<br>4.（JDK8）接口中可以定义有方法体的方法（default，static）<br>5.（JDK9）接口中可以定义私有方法</p><h2 id="抽象方法">抽象方法</h2><p>将共性的行为（方法）抽取到父类之后。由于每一个子类执行的内容不一样，所以在父类中不能确定具体的方法体。该方法就可以定义为抽象方法。如果一个类中存在抽象方法，那么该类就必须声明为抽象类。</p><h3 id="抽象类和抽象方法的注意事项">抽象类和抽象方法的注意事项</h3><p>1.抽象类不能实例化<br>2.抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类可以有构造方法<br>3.抽象类的子类要么重写抽象类中的所有抽象方法，要么是抽象类<br>意义：实现格式的统一<br><img src="/post-img/Pasted image 20230403114457.png" alt="图片损坏" style="zoom:100%;" /><br><img src="/post-img/Pasted image 20230403114858.png" alt="图片损坏" style="zoom:100%;" /><br><img src="/post-img/Pasted image 20230403114950.png" alt="图片损坏" style="zoom:100%;" /><br><img src="/post-img/Pasted image 20230403115048.png" alt="图片损坏" style="zoom:100%;" /></p><h1>面向对象三大特征</h1><h2 id="封装">封装</h2><p>对象代表什么，就得封装对应的数据，并提供数据对应的行为<br>在java中体现为类的构建</p><h2 id="继承">继承</h2><h3 id="继承的作用">继承的作用</h3><p>是面向对象三大特征之一（封装，继承，多态），可以让类与类之间产生子与父的联系<br>子类可以得到父类的属性和行为并可以使用<br><img src="/post-img/Pasted image 20230403085024.png" alt="图片损坏" style="zoom:100%;" /><br>当类与类之间,存在相同(共性)的内容,并满足子类是父类的一种,就可以考虑使用继承来优化代码</p><h3 id="继承的特点">继承的特点</h3><p>1.java只支持单继承，不支持多继承，但支持多层继承（每个子类只有一个父类，每个父类可有多个子类，父类也可作为子类）<br>2.java中所有的类都直接或间接地继承于object类<br>3.子类只能访问父类中非私有的成员<br>4.成员方法的继承采用虚方法表的形式：<br>虚方法是指不是由private，static，final修饰的方法，子类得到父类中的这些方法后，可以直接使用<br>子类可以将自己的虚方法添加到自己的虚方法表中，传递给自己的子类，如果有重写的方法，会覆盖</p><h3 id="方法的重写">方法的重写</h3><p>当父类的方法不能满足子类现在的需求时，需要进行方法重写<br>书写格式：<br>在继承体系中，子类出现了和父类中一模一样的方法声明（方法名，参数），我们就称子类这个方法是重写的方法。<br>用”@override“检验重写方法时是否有语法错误<br>注意：<br>1．重写方法的名称、形参列表必须与父类中的一致。<br>2．子类重写父类方法时，访问权限子类必须大于等于父类（空着不写 &lt; protected &lt; public )<br>3．子类重写父类方法时，返回值类型子类必须小于等于父类<br>4．建议:重写的方法尽量和父类保持一致<br>5．只有被添加到虚方法表中的方法才能被重写</p><h3 id="继承中方法的访问特点">继承中方法的访问特点</h3><h4 id="继承中成员方法的访问特点">继承中成员方法的访问特点</h4><p>this就近原则，super直接调用父类</p><h4 id="继承中构造方法的访问特点">继承中构造方法的访问特点</h4><p>1.父类的构造方法不能被子类继承<br>2.子类中所有的构造方法默认先执行父类的无参构造方法，再执行自己<br>这是因为子类在初始化的时候，有可能会使用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据。子类初始化之前，一定要调用父类构造方法先完成父类数据空间的初始化。<br>因此子类构造方法的第一行默认是super（），不写也存在，且必须在第一行；如果想调用父类的有参构造，必须手动调用（super（形参））</p><h4 id="this和super">this和super</h4><p>this理解为一个变量，表示方法调用者的地址值，super代表父类存储空间<br><img src="/post-img/Pasted image 20230403091147.png" alt="图片损坏" style="zoom:100%;" /></p><p>多态：同类型的对象表现出的不同形态（同一个父类的不同子类）<br>格式：父类类型 对象名称=子类对象；<br>前提：有继承（或实现）关系，有方法重写，有父类引用指向子类对象</p><h2 id="多态">多态</h2><h3 id="多态调用成员的特点">多态调用成员的特点</h3><h4 id="变量调用">变量调用</h4><p>编译看左边，运行也看左边<br>编译代码的时候，会看左边的父类中有没有这个变量，有则编译成功，否则编译失败<br>运行代码的时候，实际获取的是左边父类中成员变量的值</p><h4 id="方法调用">方法调用</h4><p>编译看左边，运行看右边<br>编译代码的时候，会看左边的父类中有没有这个方法，如果有编译成功，否则编译失败<br>运行的时候实际运行的是子类中的方法<br>（Animal a =new Dog(),  a.name.sout=动物，a.show=Dog—showf）<br><img src="/post-img/Pasted image 20230403111104.png" alt="图片损坏" style="zoom:100%;" /></p><h3 id="优势和弊端">优势和弊端</h3><p>优势：使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性与便利性<br>弊端：不能调用子类的特有功能（父类中没有的方法编译时直接报错）<br>解决方法：将父类类型强转成子类类型，但不能转换成其他类的类型</p><h3 id="instanceof关键字">instanceof关键字</h3><p>检验类型是否正确<br>格式：变量 instanceof 类名  返回一个boolean</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程基础</title>
      <link href="/posts/adcb768c.html"/>
      <url>/posts/adcb768c.html</url>
      
        <content type="html"><![CDATA[<h1>网络编程简介</h1><p>网络编程是在网络通信协议下，计算机与计算机之间通过网络进行数据传输<br>java是使用Java.net包下的技术开发出常用的网络应用程序<br>常见的软件架构有B/S和C/S两种：<br>其中B/S是浏览器/服务器架构，它不需要开发客户端，只需要页面+服务端，并且用户不需要下载，打开浏览器就能使用，但是如果应用过大，用户体验就会收到影响；它适合移动互联网应用，可以在任何地方随时访问的系统<br>而C/S是客户端/服务器架构，它的画面可以做的非常精美，用户体验好；但是需要开发客户端，也需要开发服务端，并且用户需要下载和更新的时候太麻烦；它适合定制专业化的办公类软件</p><h1>网络编程三要素</h1><p>IP：设备在网络中的地址，是唯一的标识<br>端口号：是应用程序在设备中唯一的标识<br>协议：是数据在网络中传输的规则</p><h2 id="IP">IP</h2><p>是分配给上网设备的数字标签<br>通俗理解为上网设备在网络中的地址，是唯一的；分为IPv4、IPv6<br>其中IPv4采用32位地址长度，分成4组，简写为点分十进制<br>IPv6是在IPv4的地址总数不够后出现的，采用128位地址长度，分为8组，简写为冒分十六进制</p><h3 id="IPv4的地址分类形式">IPv4的地址分类形式</h3><p>公网地址(万维网使用)和私有地址(局域网使用)。<br>192.168.开头的就是私有址址，范围即为192.168.0.0–192.168.255.255，专门为组织机构内部使用，以此节省IP<br>特殊IP地址:127.0.0.1，也可以是localhost:是回送地址也称本地回环地址，也称本机IP，永远只会寻找当前所在本机。<br>但是它不同于本机当前IP地址，因为本机当前IP地址可能会随着网络环境的变化而改变，通过它向自己发送信息是通过路由器的，而127.0.0.1不通过路由器</p><h3 id="常用的CMD命令">常用的CMD命令</h3><p>ipconfig：查看本机IP地址<br>ping：检查网络是否畅通</p><h3 id="InetAddress类">InetAddress类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//static InetAddress getByName(String host)  确定主机名称的IP地址，主机名称可以是机器名称，也可以是IP地址</span></span><br><span class="line"><span class="comment">//string getHostName()  获取此IP地址的主机名</span></span><br><span class="line"><span class="comment">//string getHostAddress()   返回文本显示中的IP地址字符串</span></span><br><span class="line"><span class="comment">//1.获取InetAddress的对象</span></span><br><span class="line"><span class="comment">//IP的对象   一台电脑的对象</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;主机名&quot;</span>);</span><br><span class="line">system.out.println(address);</span><br><span class="line"></span><br><span class="line"><span class="type">string</span> <span class="variable">name</span> <span class="operator">=</span> address.getHostName();</span><br><span class="line">System.out.println(name);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">ip</span> <span class="operator">=</span> address.getHostAddress();</span><br><span class="line">system.out.println(ip);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="端口号">端口号</h2><p>应用程序在设备中唯一的标识。<br>端口号:由两个字节表示的整数，取值范围:0~65535<br>其中0~1023之间的端口号用于一些知名的网络服务或者应用。<br>我们自己使用1024以上的端口号就可以了。<br>注意:一个端口号只能被一个应用程序使用。</p><h2 id="协议">协议</h2><p>计算机网络中，连接和通信的规则被称为网络通信协议<br>OSl参考模型:世界互联协议标准，全球通信规范，单模型过于理想化，未能在因特网上进行广泛推广TCP/IP参考模型(或TCP/IP协议):事实上的国际标准。<br><img src="/post-img/Pasted image 20230718172327.png" alt="图片损坏" style="zoom:100%;" /></p><h3 id="UDP协议">UDP协议</h3><p>用户数据报协议(User Datagram Protocol)<br>UDP是面向无连接通信协议。<br>速度快，有大小限制一次最多发送64K，数据不安全，易丢失数据</p><h4 id="代码实现">代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.创建DatagramSocket对象(快递公司)</span></span><br><span class="line"><span class="comment">//细节:</span></span><br><span class="line"><span class="comment">//绑定端口。以后我们就是通过这个端口往外发送</span></span><br><span class="line"><span class="comment">//空参:所有可用的端口中随机一个进行使用</span></span><br><span class="line"><span class="comment">//有参:指定端口号进行绑定</span></span><br><span class="line"><span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.打包数据</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span><span class="string">&quot;你好威啊!!!&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] bytes = str.getBytes();</span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">10086</span>;</span><br><span class="line"><span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes,bytes.length,address,port);</span><br><span class="line"><span class="comment">//3.发送数据</span></span><br><span class="line">ds.send(dp);</span><br><span class="line"><span class="comment">//4.释放资源</span></span><br><span class="line">ds.close();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建DatagramSocket对象(快递公司)</span></span><br><span class="line"><span class="comment">//细节:</span></span><br><span class="line">/在接收的时候,一定要绑定端口,而且绑定的端口一定要跟发送的滑口保持一致</span><br><span class="line"><span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">10086</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.接收数据包</span></span><br><span class="line"><span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes,bytes.length);</span><br><span class="line"><span class="comment">//receive是阻塞的，会一直等待发送端发送数据（后面的代码不会执行）</span></span><br><span class="line">ds.receive(dp);</span><br><span class="line"><span class="comment">//3.解析数据包</span></span><br><span class="line"><span class="type">byte</span>[]data = dp.getData();</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> dp.getLength();</span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> dp.getAddress();</span><br><span class="line"><span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> dp.getPort();</span><br><span class="line">system.out.println(<span class="string">&quot;接收到数据 +new string(data, offset e,len));</span></span><br><span class="line"><span class="string">System.out.print1n(&quot;</span>该数据是从”+ address +这台电脑中的<span class="string">&quot;+port +&quot;</span>这个端口发出的<span class="string">&quot;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//4.释放资源</span></span><br><span class="line"><span class="string">ds.close();</span></span><br></pre></td></tr></table></figure><p>运行时应该先运行接收端，再运行发送端，否则发送端会报错（找不到接收的端口）</p><h4 id="三种通信方式">三种通信方式</h4><p>1.单播<br>2.组播<br>地址:224.0.0.0~239.255.255.255<br>其中224.0.0.0~224.0.0.255为预留的组播地址<br>比单播多一步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将接收端当前本机添加到224.0.0.1的这一组当中</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">address</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;&quot;</span><span class="number">224.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">&quot;);</span></span><br><span class="line"><span class="string">ms.joinGroup( address);</span></span><br></pre></td></tr></table></figure><p>3.广播 地址255.255.255.255<br>将单播的接收地址改为255.255.255.255</p><h3 id="TCP协议">TCP协议</h3><p>传输控制协议TCP(Transmission Control Protocol)<br>TCP协议是面向连接的通信协议。<br>速度慢，没有大小限制，数据安全。<br>TCP通信协议是一种可靠的网络协议，它在通信的两端各建立一个Socket对象,通信之前要保证连接已经建立通过Socket产生IO流来进行网络通信<br><img src="/post-img/Pasted image 20230718173645.png" alt="图片损坏" style="zoom:100%;" /><br><img src="/post-img/Pasted image 20230718173745.png" alt="图片损坏" style="zoom:100%;" /><br><img src="/post-img/Pasted image 20230718173854.png" alt="图片损坏" style="zoom:100%;" /><br><img src="/post-img/Pasted image 20230718173838.png" alt="图片损坏" style="zoom:100%;" /></p><h1>UUID</h1><p>生成随机且唯一的一串序列号，可用于文件名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> UUID.randomUUID( ).toString().replace(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语法基础</title>
      <link href="/posts/36d3508b.html"/>
      <url>/posts/36d3508b.html</url>
      
        <content type="html"><![CDATA[<h1>JDK,JRE,JVM</h1><p>1.JDK是什么?有哪些内容组成?<br>JDK是Java开发工具包<br>JVM虚拟机:Java程序运行的地方<br>核心类库:Java已经写好的东西，我们可以直接用。<br>开发工具:javac、 java、jdb、 jhat…<br>2.JRE是什么?有哪些内容组成?<br>JRE是Java运行环境<br>JVM、核心类库、运行工具<br>3.JDK，JRE，JVM三者的包含关系<br>JDK包含了JRE<br>JRE包含了JVM</p><h1>数据类型</h1><h2 id="字面量">字面量</h2><p>字面量（数据在程序中的书写格式）：整数，小数，字符串，字符，布尔，空<br>特殊字面量的书写：制表符\t，空null</p><h2 id="基本数据类型">基本数据类型</h2><p>八种基本数据类型：byte（Byte）,short(Short),int(Integer),long(Long)，float(Float),double(Double),char(Character),boolean(Boolean)<br>大小关系：double，float，long（8），int（4），short（2），byte（1）</p><h2 id="引用数据类型">引用数据类型</h2><p>类、数组、接口、枚举、泛型</p><h1>标识符命名规则</h1><p>1.由数字，字母，下划线，$组成<br>2.不能由数字开头，不能是关键字，区分大小写<br>3.最好见名知意<br>4.方法、变量小驼峰：一个单词全小写，多个单词第一个首字母小写，后面大写<br>5.类名大驼峰：每个单词的首字母大写</p><h1>项目结构</h1><p>project，module，package，class（测试类，定义类）</p><h1>隐式转换和强制转换</h1><p>1.隐式转换：小的数据类型和大的数据类型进行运算时，会先转化为大的数据类型如byte，short，char在进行运算时，会直接转化为int（char+char=int）<br>2.强制转换：大的数据类型转化为小的，有可能造成数据丢失</p><h1>运算符</h1><p>1.“+”操作中出现字符串时，这个“+”是字符串连接符，而不是算术运算符了。会将前后的数据进行拼接，并产生一个新的字符串。连续进行&quot;＋&quot;操作时，从左到右逐个执行。<br>2.<em><em>扩展运算符+=，-=，</em> =，/=，%=  隐含了强制类型转换</em>*<br>3.自增和自减运算符（++和–）：<br>单独放在一行时，放在前面和后面得到的结果都一样；参与运算时，放前面时先自增（减）再参与运算，放后面时先参与运算，再自增（减）<br>4.四种逻辑运算符：  &amp;   都真才真,    |   都假才假,   ^   相同为假，不同为真,   !   取反<br>5.短路逻辑运算符：  &amp;&amp;前假即假，||前真即真，提高运行效率，可连接三个判断<br>6.三元运算符：关系表达式？表达式1：表达式2（等价于if-else、可以级联但不建议）</p><h1>if-else和switch-case</h1><p>if    if-else     if-else if-else判断范围<br>switch-case将数据一一列举出来从中选择一个</p><h1>数组</h1><h2 id="数组动态初始化和静态初始化的区别">数组动态初始化和静态初始化的区别</h2><p>动态初始化:手动指定数组长度，由系统给出默认初始化值。<br>只明确元素个数，不明确具体数值，推荐使用动态初始化<br>静态初始化∶手动指定数组元素，系统会根据元素个数，计算出数组的长度。<br>需求中已经明确了要操作的具体数据，直接静态初始化即可。</p><h2 id="数组的内存">数组的内存</h2><img src="/post-img/Pasted image 20230331095110.png" alt="图片损坏" style="zoom:100%;" />new出来的是在堆内存中开辟了一块新的内存空间，基本数据类型直接存值，引用数据类型存地址值基本数据类型:  数据值是存储在自己的空间中  特点:  赋值给其他变量，也是赋的真实的值。引用数据类型:  数据值是存储在其他空间中,自己空间中存储的是地址值。特点:  赋值给其他变量，赋的地址值。## 数组间的赋值将一个数组赋值给另一个数组，实际上是将地址值传递，因此对其中任一数组中元素的改变都会影响另一个数组，本质上这两个数组除了名字以外没什么不同<h1>方法</h1><h2 id="方法的定义">方法的定义</h2><p>1.方法是程序中最小的执行单元。<br>2.实际开发中遇到重复的代码、具有独立功能的代码可以抽取到方法中。<br>3.方法可以提高代码的复用性可以提高代码的可维护性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式：</span></span><br><span class="line">修饰符 返回值 方法名（形式参数）&#123;</span><br><span class="line">方法体；</span><br><span class="line"><span class="keyword">return</span> 返回值；</span><br></pre></td></tr></table></figure><h2 id="方法的特点">方法的特点</h2><p><strong>方法不调用就不执行，互相间是平级关系，不能嵌套定义</strong>（一个方法不能定义在另一个方法的里面）</p><h2 id="方法重载">方法重载</h2><p>方法名相同（实现相似的功能），而形参不同（个数，类型，顺序），与返回值无关</p><h2 id="方法内存">方法内存</h2><img src="/post-img/Pasted image 20230331100315.png" alt="图片损坏" style="zoom:50%;" />方法被调用后进栈，执行完出栈，并将返回值返回至调用处<h2 id="方法的值传递">方法的值传递</h2><p>传递基本数据类型时，传递的是真实的数据，形参的改变，不影响实际参数的值（方法中对参数的重新赋值只作用于方法中）<br>传递引用数据类型时，传递的是地址值，形参的改变，影响实际参数的值</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT</title>
      <link href="/posts/1bb08f7a.html"/>
      <url>/posts/1bb08f7a.html</url>
      
        <content type="html"><![CDATA[<h1>什么是JWT</h1><p>JWT（JSON Web Token）是一种开放标准（RFC 7519），顾名思义，它是token的一种，<br>用于在网络应用间安全地传输信息。它以JSON对象的形式安全地传输声明和信息，但需要注意的是，它只能保证数据的完整性，但任何人都可以获取到JWT中所携带的信息，所以通常被用作身份验证和授权的方式。</p><h1>JWT的组成</h1><p>JWT由3部分组成：标头(Header)、有效载荷(Payload)和签名(Signature)。在传输的时候，会将JWT的3部分分别进行Base64编码后用  ‘.’  进行连接形成最终传输的字符串。<br><img src="/post-img/Pasted image 20240414194705.png" alt="图片损坏" style="zoom:100%;" /></p><ol><li><strong>头部（Header）</strong>：包含了JWT的元数据和加密算法。通常包括两部分信息：令牌的类型（比如JWT）和所使用的加密算法（比如HMAC SHA256或RSA）。</li><li><strong>载荷（Payload）</strong>：即需要传递的信息，例如用户的身份信息等。</li><li><strong>签名（Signature）</strong>：对于前两部分使用Base64编码后的结果进行签名，以确保JWT的完整性和验证发送者的身份。签名的生成通常需要使用密钥，确保只有持有密钥的一方能够创建和验证JWT。</li></ol><h1>种类</h1><p>JWT(JSON Web Token)指的是一种规范，它允许我们使用JWT在两个组织之间传递安全可靠的信息，针对不同的加密或生成算法，JWT的具体实现可以分为以下几种：</p><ol><li>nonsecure JWT：未经过签名（header部分没有指定签名算法），不安全的JWT</li><li>JWS：经过特殊的签名算法生成了签名的JWT</li><li>JWE：payload部分经过加密（对称加密或非对称加密）的JWT，确保其在传输过程中的保密性。JWE 由五个部分组成：<ul><li><strong>头部（Header）</strong>：包含了加密算法、加密密钥等信息，用于指示如何对 payload 进行加密。</li><li><strong>加密密钥（Encrypted Key）</strong>：可选项，用于对 payload 进行加密的密钥，如果使用对称加密算法则会使用此项。</li><li><strong>初始化向量（Initialization Vector）</strong>：用于对 payload 进行加密时的初始化向量，如果使用对称加密算法则会使用此项。</li><li><strong>加密的内容（Encrypted Content）</strong>：加密后的 payload 内容。</li><li><strong>认证标签（Authentication Tag）</strong>：用于验证加密内容的完整性和真实性，如果使用 AEAD 加密模式则会使用此项。</li></ul></li></ol><h1>对比JWT，cookie，session</h1><ol><li><strong>JWT (JSON Web Token)</strong>:<ul><li><strong>特点</strong>:<ul><li>无状态（Stateless）：JWT本身包含了用户信息和声明，服务器不需要在数据库或其他存储中保存会话状态，因此无需在多个服务器之间共享会话信息。</li><li>自包含性（Self-contained）：JWT中包含了所有需要的信息，使得客户端可以直接解析和使用，减少了对服务器的查询压力。</li><li>跨域（Cross-Origin）：JWT可以在不同域之间安全传输，并且可以通过设置适当的跨域策略来实现跨域通信。</li></ul></li><li><strong>适用场景</strong>:<ul><li>适用于分布式系统或微服务架构，无需服务器端保存会话状态。</li><li>适用于需要无状态认证的场景。</li></ul></li></ul></li><li><strong>Cookie</strong>:<ul><li><strong>特点</strong>:<ul><li>存储在客户端：Cookie是由服务器发送到客户端，并存储在客户端的浏览器中。</li><li>可设置过期时间：可以通过设置Cookie的过期时间来控制用户会话的有效期。</li><li>自动发送：浏览器在每次向服务器发送请求时都会自动携带相应的Cookie。</li></ul></li><li><strong>适用场景</strong>:<ul><li>适用于传统的Web应用程序，可以通过设置Cookie来维持用户的会话状态。</li><li>可以用于存储少量敏感信息，但需要注意安全性。</li></ul></li></ul></li><li><strong>Session</strong>:<ul><li><strong>特点</strong>:<ul><li>存储在服务器：Session数据存储在服务器端，客户端只保存了Session ID。</li><li>可以存储更多信息：相比Cookie，Session可以存储更多的用户信息，但会增加服务器端的存储压力。</li><li>可以根据需要进行管理：服务器可以根据需要对Session进行管理，包括设置过期时间、销毁Session等。</li></ul></li><li><strong>适用场景</strong>:<ul><li>适用于需要存储大量用户信息或敏感信息的场景。</li><li>在需要对会话进行更多控制和管理的情况下使用。</li></ul></li></ul></li></ol><h1>JWT使用示例（身份校验）</h1><p>在实际的SpringBoot项目中，一般我们可以用如下流程做登录：</p><ol><li>在登录验证通过后，给用户生成一个对应的随机token(注意这个token不是指jwt，可以用uuid等算法生成)，然后将这个token作为key的一部分，用户信息作为value存入Redis，并设置过期时间，这个过期时间就是登录失效的时间</li><li>将第1步中生成的随机token作为JWT的payload生成JWT字符串返回给前端</li><li>前端之后每次请求都在请求头中的Authorization字段中携带JWT字符串</li><li>后端定义一个拦截器，每次收到前端请求时，都先从请求头中的Authorization字段中取出JWT字符串并进行验证，验证通过后解析出payload中的随机token，然后再用这个随机token得到key，从Redis中获取用户信息，如果能获取到就说明用户已经登录</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JWTInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">JWT</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.校验JWT字符串</span></span><br><span class="line">            <span class="type">DecodedJWT</span> <span class="variable">decodedJWT</span> <span class="operator">=</span> JWTUtils.decode(JWT);</span><br><span class="line">            <span class="comment">// 2.取出JWT字符串载荷中的随机token，从Redis中获取用户信息</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (SignatureVerificationException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;无效签名&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (TokenExpiredException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;token已经过期&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (AlgorithmMismatchException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;算法不一致&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;token无效&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际开发中可以用下列手段来增加JWT的安全性：</p><ol><li>使用HTTPS来传输，更加安全，因为JWT是在请求头中传递的，可以避免网络劫持</li><li>保证服务器的安全，JWT的哈希签名的密钥是存放在服务端的，所以只要服务器不被攻破，理论上JWT是安全的。</li><li>定期更换服务端的哈希签名密钥(相当于盐值)，避免JWT被暴力穷举破解。</li></ol><h1>补充</h1><h2 id="对称加密与非对称加密">对称加密与非对称加密</h2><ol><li><strong>对称加密</strong>:<ul><li><strong>特点</strong>:<ul><li>使用相同的密钥进行加密和解密。</li><li>加密和解密速度快，效率高。</li><li>密钥的管理相对简单，但需要确保密钥的安全性。</li></ul></li><li><strong>应用场景</strong>:<ul><li>适用于需要高效加密和解密的场景，如数据传输过程中的加密。</li><li>通常用于对称加密的算法有DES、3DES、AES等。</li></ul></li></ul></li><li><strong>非对称加密</strong>:<ul><li><strong>特点</strong>:<ul><li>使用一对密钥（公钥和私钥）进行加密和解密，公钥用于加密，私钥用于解密。</li><li>加密速度相对较慢，安全性高。</li><li>密钥的管理相对复杂，需要保护私钥的安全性。</li></ul></li><li><strong>应用场景</strong>:<ul><li>适用于安全性要求较高的场景，如数字签名、身份认证等。</li><li>通常用于非对称加密的算法有RSA、DSA、ECC等。</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法与外挂标签写法汇总</title>
      <link href="/posts/2013454d.html"/>
      <url>/posts/2013454d.html</url>
      
        <content type="html"><![CDATA[<h1>1.Markdown语法自带格式</h1><div class="note info flat"><p>参考：<a href="https://blog.csdn.net/u014061630/article/details/81359144">Markdown语法图文全面详解(10分钟学会)</a></p></div><div class="note warning flat"><p>注意：此页面偶尔会存在CSS冲突问题!</p></div><h2 id="1-1-代码块">1.1 代码块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\```shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br><span class="line">\```</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-2-多级标题">1.2 多级标题</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>见本文章标题!</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-3-文字样式">1.3 文字样式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线演示<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">文字<span class="strong">**加粗**</span>演示</span><br><span class="line"></span><br><span class="line">文字<span class="emphasis">*斜体*</span>演示</span><br><span class="line"></span><br><span class="line">文本<span class="code">`高亮`</span>演示</span><br><span class="line"></span><br><span class="line">文本~~删除~~线演示</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">5</span>&gt;</span></span>5号字<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span></span>黑体<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span></span>蓝色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">MistyRose</span>&gt;</span></span>这里的背景色是：MistyRosen，此处输入任意想输入的内容<span class="language-xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p><u>下划线演示</u></p><p>文字<strong>加粗</strong>演示</p><p>文字<em>斜体</em>演示</p><p>文本<code>高亮</code>演示</p><p>文本<s>删除</s>线演示</p><p><font size = 5>5号字</font><br><font face="黑体">黑体</font><br><font color=blue>蓝色</font></p><table><tr><td bgcolor=MistyRose>这里的背景色是：MistyRosen，此处输入任意想输入的内容</td></tr></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="note info flat"><p>上述要点可参考:<a href="https://blog.csdn.net/qq_43732429/article/details/108034518">【Markdown语法】字体颜色大小及文字底色设置</a></p></div><h2 id="1-4-引用">1.4 引用</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt;  Java</span></span><br><span class="line"><span class="quote">&gt; 二级引用演示</span></span><br><span class="line"><span class="quote">&gt; MySQL</span></span><br><span class="line"><span class="quote">&gt; &gt;外键</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;事务</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;<span class="strong">**行级锁**</span>(引用内部一样可以用格式)</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; ....</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><blockquote><p>Java<br>二级引用演示<br>MySQL</p><blockquote><p>外键</p><p>事务</p><p><strong>行级锁</strong>(引用内部一样可以用格式)</p></blockquote><p>…</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-5-分割线">1.5 分割线</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><hr><hr><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-6-列表-跟空格都可以">1.6 列表(*,+,-跟空格都可以)</h2><h3 id="1-6-1-无序列表">1.6.1 无序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> Java</span><br><span class="line"><span class="bullet">*</span> Python</span><br><span class="line"><span class="bullet">*</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> Java</span><br><span class="line"><span class="bullet">+</span> Python</span><br><span class="line"><span class="bullet">+</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Java</span><br><span class="line"><span class="bullet">-</span> Python</span><br><span class="line"><span class="bullet">-</span> ...</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="1-6-2-有序列表">1.6.2 有序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 注意后面有空格</span></span><br><span class="line"><span class="bullet">1.</span> </span><br><span class="line"><span class="bullet">2.</span> </span><br><span class="line"><span class="bullet">3.</span> </span><br><span class="line"><span class="bullet">4.</span> </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li></li><li></li><li></li><li></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-7-图片">1.7 图片</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 本地图片</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/assets/pusheencode.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="section"># 在线图片</span></span><br><span class="line">![<span class="string">code</span>](<span class="link">https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>本地图片:<br><img src="/assets/pusheencode.webp" alt="示例图片" style="zoom:50%;" /><br>在线图片:<br><img src="https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png" alt="code"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-8-表格">1.8 表格</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 项目标号 | 资金     | 备注 |</span><br><span class="line">| -------- | -------- | ---- |</span><br><span class="line">| 1        | 100，000 | 无   |</span><br><span class="line">| 2        | 200，000 | 无   |</span><br><span class="line">| 3        | 300,600  | 重要 |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th>项目标号</th><th>资金</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>100，000</td><td>无</td></tr><tr><td>2</td><td>200，000</td><td>无</td></tr><tr><td>3</td><td>300,600</td><td>重要</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-9-公式">1.9 公式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\Gamma(z)=\int<span class="emphasis">_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt.</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>$$<br>\Gamma(z)=\int_0^\infty t^{z-1}e^{-t}dt.<br>$$</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1>2.Butterfly外挂标签</h1><div class="note info flat"><p>这部分参考安知鱼:<a href="https://anzhiy.cn/posts/7d58.html">基于Butterfly的外挂标签引入</a></p></div><h2 id="2-1-行内文本样式-text">2.1 行内文本样式 text</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% u 文本内容 %&#125;</span><br><span class="line">&#123;% emp 文本内容 %&#125;</span><br><span class="line">&#123;% wavy 文本内容 %&#125;</span><br><span class="line">&#123;% del 文本内容 %&#125;</span><br><span class="line">&#123;% kbd 文本内容 %&#125;</span><br><span class="line">&#123;% psw 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 带 &#123;% u 下划线 %&#125; 的文本</span><br><span class="line"><span class="bullet">2.</span> 带 &#123;% emp 着重号 %&#125; 的文本</span><br><span class="line"><span class="bullet">3.</span> 带 &#123;% wavy 波浪线 %&#125; 的文本</span><br><span class="line"><span class="bullet">4.</span> 带 &#123;% del 删除线 %&#125; 的文本</span><br><span class="line"><span class="bullet">5.</span> 键盘样式的文本 &#123;% kbd command %&#125; + &#123;% kbd D %&#125;</span><br><span class="line"><span class="bullet">6.</span> 密码样式的文本：&#123;% psw 这里没有验证码 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><ol><li>带 <u>下划线</u> 的文本</li><li>带 <emp>着重号</emp> 的文本</li><li>带 <wavy>波浪线</wavy> 的文本</li><li>带 <del>删除线</del> 的文本</li><li>键盘样式的文本 <kbd>command</kbd> + <kbd>D</kbd></li><li>密码样式的文本：<psw>这里没有验证码</psw></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-2-行内文本-span">2.2 行内文本 span</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% span 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% span red, 红色 %&#125;、&#123;% span yellow, 黄色 %&#125;、&#123;% span green, 绿色 %&#125;、&#123;% span cyan, 青色 %&#125;、&#123;% span blue, 蓝色 %&#125;、&#123;% span gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% span center logo large, Volantis %&#125;</span><br><span class="line">&#123;% span center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<span class='p red'>红色</span>、<span class='p yellow'>黄色</span>、<span class='p green'>绿色</span>、<span class='p cyan'>青色</span>、<span class='p blue'>蓝色</span>、<span class='p gray'>灰色</span>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。<br><span class='p center logo large'>Volantis</span><br><span class='p center small'>A Wonderful Theme for Hexo</span></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-3-段落文本-p">2.3 段落文本 p</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% p 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% p red, 红色 %&#125;、&#123;% p yellow, 黄色 %&#125;、&#123;% p green, 绿色 %&#125;、&#123;% p cyan, 青色 %&#125;、&#123;% p blue, 蓝色 %&#125;、&#123;% p gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% p center logo large, Volantis %&#125;</span><br><span class="line">&#123;% p center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<p class='p red'>红色</p>、<p class='p yellow'>黄色</p>、<p class='p green'>绿色</p>、<p class='p cyan'>青色</p>、<p class='p blue'>蓝色</p>、<p class='p gray'>灰色</p>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。</li></ul><p class='p center logo large'>Volantis</p><p class='p center small'>A Wonderful Theme for Hexo</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-4-引用note">2.4 引用note</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">通用配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">语法格式</button></li><li class="tab"><button type="button" data-href="#分栏-3">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-4">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-5">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">note:</span><br><span class="line">  # Note tag style values:</span><br><span class="line">  #  - simple    bs-callout old alert style. Default.</span><br><span class="line">  #  - modern    bs-callout new (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br><span class="line">  #  - disabled  disable all CSS styles import of note tag.</span><br><span class="line">  style: simple</span><br><span class="line">  icons: false</span><br><span class="line">  border<span class="emphasis">_radius: 3</span></span><br><span class="line"><span class="emphasis">  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line"><span class="emphasis">  # Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line"><span class="emphasis">  light_</span>bg<span class="emphasis">_offset: 0</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 自带icon</span></span><br><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"><span class="section"># 外部icon</span></span><br><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.自带icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / primary / success / info / warning / danger ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】不显示 icon</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><p>2.外部icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / blue / pink / red / purple / orange / green ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note simple %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note modern %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note flat %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note disabled %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default disabled %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary disabled %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success disabled %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info disabled %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning disabled %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger disabled %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default no-icon %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary no-icon %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success no-icon %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info no-icon %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning no-icon %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger no-icon %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; simple %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; simple %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; simple%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; simple %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; simple %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; modern %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; modern%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; modern %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; modern %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; flat %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; flat %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; flat%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; flat %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; flat %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; disabled %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; disabled %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; disabled %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; disabled %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; disabled %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue no-icon %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink no-icon %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red no-icon %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple no-icon %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green no-icon %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-5"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note simple"><p>默认 提示块标签</p></div><div class="note default simple"><p>default 提示块标签</p></div><div class="note primary simple"><p>primary 提示块标签</p></div><div class="note success simple"><p>success 提示块标签</p></div><div class="note info simple"><p>info 提示块标签</p></div><div class="note warning simple"><p>warning 提示块标签</p></div><div class="note danger simple"><p>danger 提示块标签</p></div>2.`modern`样式<div class="note modern"><p>默认 提示块标签</p></div><div class="note default modern"><p>default 提示块标签</p></div><div class="note primary modern"><p>primary 提示块标签</p></div><div class="note success modern"><p>success 提示块标签</p></div><div class="note info modern"><p>info 提示块标签</p></div><div class="note warning modern"><p>warning 提示块标签</p></div><div class="note danger modern"><p>danger 提示块标签</p></div><p>3.<code>flat</code>样式</p><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><p>4.<code>disabled</code>样式</p><div class="note disabled"><p>默认 提示块标签</p></div><div class="note default disabled"><p>default 提示块标签</p></div><div class="note primary disabled"><p>primary 提示块标签</p></div><div class="note success disabled"><p>success 提示块标签</p></div><div class="note info disabled"><p>info 提示块标签</p></div><div class="note warning disabled"><p>warning 提示块标签</p></div><div class="note danger disabled"><p>danger 提示块标签</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>默认 提示块标签</p></div><div class="note default no-icon flat"><p>default 提示块标签</p></div><div class="note primary no-icon flat"><p>primary 提示块标签</p></div><div class="note success no-icon flat"><p>success 提示块标签</p></div><div class="note info no-icon flat"><p>info 提示块标签</p></div><div class="note warning no-icon flat"><p>warning 提示块标签</p></div><div class="note danger no-icon flat"><p>danger 提示块标签</p></div>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note icon-padding simple"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding simple"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding simple"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding simple"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding simple"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding simple"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>2.<code>modern</code>样式</p><div class="note icon-padding modern"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding modern"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding modern"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding modern"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>3.<code>flat</code>样式</p><div class="note icon-padding flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>4.<code>disabled</code>样式</p><div class="note icon-padding disabled"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding disabled"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding disabled"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding disabled"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding disabled"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding disabled"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding disabled"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue no-icon flat"><p>2021年快到了…</p></div><div class="note pink no-icon flat"><p>小心开车 安全至上</p></div><div class="note red no-icon flat"><p>这是三片呢？还是四片？</p></div><div class="note orange no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple no-icon flat"><p>剪刀石头布</p></div><div class="note green no-icon flat"><p>前端最讨厌的浏览器</p></div>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-5-上标标签-tip">2.5 上标标签 tip</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: success,error,warning,bolt,ban,home,sync,cogs,key,bell</li><li><code>自定义图标</code>: 支持fontawesome。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip %&#125;default&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip info %&#125;info&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip success %&#125;success&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip error %&#125;error&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip warning %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bolt %&#125;bolt&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban %&#125;ban&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip home %&#125;home&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip sync %&#125;sync&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip cogs %&#125;cogs&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip key %&#125;key&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bell %&#125;bell&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip fa-atom %&#125;自定义font awesome图标&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="tip "><p>default</p></div><div class="tip info"><p>info</p></div><div class="tip success"><p>success</p></div><div class="tip error"><p>error</p></div><div class="tip warning"><p>warning</p></div><div class="tip bolt"><p>bolt</p></div><div class="tip ban"><p>ban</p></div><div class="tip home"><p>home</p></div><div class="tip sync"><p>sync</p></div><div class="tip cogs"><p>cogs</p></div><div class="tip key"><p>key</p></div><div class="tip bell"><p>bell</p></div><div class="tip fa-atom"><p>自定义font awesome图标</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-6-动态标签-anima">2.6 动态标签 anima</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><div class="note info flat"><ol><li>将所需的CSS类添加到图标（或DOM中的任何元素）。</li><li>对于父级悬停样式，需要给目标元素添加指定CSS类，同时还要给目标元素的父级元素添加CSS类<code>faa-parent animated-hover</code>。（详情见示例及示例源码）<br>You can regulate the speed of the animation by adding the CSS class or . faa-fastfaa-slow</li><li>可以通过给目标元素添加CSS类<code>faa-fast</code>或<code>faa-slow</code>来控制动画快慢。</li></ol></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.On DOM load（当页面加载时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>2.调整动画速度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated faa-fast %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated faa-slow %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>3.On hover（当鼠标悬停时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated-hover %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated-hover %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>4.On parent hover（当鼠标悬停在父级元素时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-horizontal&quot;</span>&gt;</span></span>warning<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-flash&quot;</span>&gt;</span></span>ban<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.On DOM load（当页面加载时显示动画）</p><div class="tip warning faa-horizontal animated"><p>warning</p></div><div class="tip ban faa-flash animated"><p>ban</p></div>2.调整动画速度<div class="tip warning faa-horizontal animated faa-fast"><p>warning</p></div><div class="tip ban faa-flash animated faa-slow"><p>ban</p></div>3.On hover（当鼠标悬停时显示动画）<div class="tip warning faa-horizontal animated-hover"><p>warning</p></div><div class="tip ban faa-flash animated-hover"><p>ban</p></div>4.On parent hover（当鼠标悬停在父级元素时显示动画）<div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">warning</p></div><div class="tip ban faa-parent animated-hover"><p class="faa-flash">ban</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-7-复选列表-checkbox">2.7 复选列表 checkbox</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: plus, minus, times</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 纯文本测试 %&#125;</span><br><span class="line">&#123;% checkbox checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% checkbox red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% checkbox green checked, 绿色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox yellow checked, 黄色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox cyan checked, 青色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox blue checked, 蓝色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox plus green checked, 增加 %&#125;</span><br><span class="line">&#123;% checkbox minus yellow checked, 减少 %&#125;</span><br><span class="line">&#123;% checkbox times red checked, 叉 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="checkbox" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>支持自定义颜色</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>绿色 + 默认选中</p>            </div><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>黄色 + 默认选中</p>            </div><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>青色 + 默认选中</p>            </div><div class='checkbox blue checked'><input type="checkbox" checked="checked"/>            <p>蓝色 + 默认选中</p>            </div><div class='checkbox plus green checked'><input type="checkbox" checked="checked"/>            <p>增加</p>            </div><div class='checkbox minus yellow checked'><input type="checkbox" checked="checked"/>            <p>减少</p>            </div><div class='checkbox times red checked'><input type="checkbox" checked="checked"/>            <p>叉</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-8-单选列表-radio">2.8 单选列表 radio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 纯文本测试 %&#125;</span><br><span class="line">&#123;% radio checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% radio red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% radio green, 绿色 %&#125;</span><br><span class="line">&#123;% radio yellow, 黄色 %&#125;</span><br><span class="line">&#123;% radio cyan, 青色 %&#125;</span><br><span class="line">&#123;% radio blue, 蓝色 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="radio" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="radio" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="radio" />            <p>支持自定义颜色</p>            </div><div class='checkbox green'><input type="radio" />            <p>绿色</p>            </div><div class='checkbox yellow'><input type="radio" />            <p>黄色</p>            </div><div class='checkbox cyan'><input type="radio" />            <p>青色</p>            </div><div class='checkbox blue'><input type="radio" />            <p>蓝色</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-9-时间轴-timeline">2.9 时间轴 timeline</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间线标题（可选）[,color] %&#125;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>title</code>:标题/时间线</li><li><code>color</code>:<code>timeline</code>颜色:default(留空) / blue / pink / red / purple / orange / green</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间轴样式,blue %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-07-24 [<span class="string">2.6.6 -&gt; 3.0</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 如果有 <span class="code">`hexo-lazyload-image`</span> 插件，需要删除并重新安装最新版本，设置 <span class="code">`lazyload.isSPA: true`</span>。</span><br><span class="line"><span class="bullet">2.</span> 2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <span class="code">`use_cdn: true`</span> 则需要删除。</span><br><span class="line"><span class="bullet">3.</span> 2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</span><br><span class="line"><span class="bullet">4.</span> 2.x 版本的置顶 <span class="code">`top: true`</span> 改为了 <span class="code">`pin: true`</span>，并且同样适用于 <span class="code">`layout: page`</span> 的页面。</span><br><span class="line"><span class="bullet">5.</span> 如果使用了 <span class="code">`hexo-offline`</span> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-05-15 [<span class="string">2.6.3 -&gt; 2.6.6</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6</span>) --&gt;</span><br><span class="line"></span><br><span class="line">不需要额外处理。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-04-20 [<span class="string">2.6.2 -&gt; 2.6.3</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 全局搜索 <span class="code">`seotitle`</span> 并替换为 <span class="code">`seo_title`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的索引规则有变，使用 group 组件的文章内，<span class="code">`group: group_name`</span> 对应的组件名必须是 <span class="code">`group_name`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的列表名优先显示文章的 <span class="code">`short_title`</span> 其次是 <span class="code">`title`</span>。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴样式</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p></div></div><div class='timeline-item-content'><ol><li>如果有 <code>hexo-lazyload-image</code> 插件，需要删除并重新安装最新版本，设置 <code>lazyload.isSPA: true</code>。</li><li>2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <code>use_cdn: true</code> 则需要删除。</li><li>2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</li><li>2.x 版本的置顶 <code>top: true</code> 改为了 <code>pin: true</code>，并且同样适用于 <code>layout: page</code> 的页面。</li><li>如果使用了 <code>hexo-offline</code> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p></div></div><div class='timeline-item-content'><p>不需要额外处理。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-04-20 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.6.2 -&gt; 2.6.3</a></p></div></div><div class='timeline-item-content'><ol><li>全局搜索 <code>seotitle</code> 并替换为 <code>seo_title</code>。</li><li>group 组件的索引规则有变，使用 group 组件的文章内，<code>group: group_name</code> 对应的组件名必须是 <code>group_name</code>。</li><li>group 组件的列表名优先显示文章的 <code>short_title</code> 其次是 <code>title</code>。</li></ol></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-10-链接卡片-link">2.10 链接卡片 link</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 标题, 链接, 图片链接（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 糖果屋教程贴, https://akilar.top/posts/615e2dec/, https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="tag link"><a class="link-card" title="糖果屋教程贴" href="https://akilar.top/posts/615e2dec/"><div class="left"><img src="https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico"/></div><div class="right"><p class="text">糖果屋教程贴</p><p class="url">https://akilar.top/posts/615e2dec/</p></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-11-按钮-btns">2.11 按钮 btns</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns 样式参数 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>圆角样式：rounded, circle</li><li>增加文字样式：可以在容器内增加 <code>&lt;b&gt;</code>标题<code>&lt;/b&gt;</code>和<code>&lt;p&gt;</code>描述文字<code>&lt;/p&gt;</code></li><li>布局方式：<br>默认为自动宽度，适合视野内只有一两个的情况。</li></ol><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>wide</td><td>宽一点的按钮</td></tr><tr><td>fill</td><td>填充布局，自动铺满至少一行，多了会换行</td></tr><tr><td>center</td><td>居中，按钮之间是固定间距</td></tr><tr><td>around</td><td>居中分散</td></tr><tr><td>grid2</td><td>等宽最多2列，屏幕变窄会适当减少列数</td></tr><tr><td>grid3</td><td>等宽最多3列，屏幕变窄会适当减少列数</td></tr><tr><td>grid4</td><td>等宽最多4列，屏幕变窄会适当减少列数</td></tr><tr><td>grid5</td><td>等宽最多5列，屏幕变窄会适当减少列数</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle grid5 %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>2.或者含有图标的按钮</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns rounded grid5 %&#125;</span><br><span class="line">&#123;% cell 下载源码, /, fas fa-download %&#125;</span><br><span class="line">&#123;% cell 查看文档, /, fas fa-book-open %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle center grid5 %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p red, 专业版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p green, 免费版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><div class="btns circle grid5">            <a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a>          </div>2.或者含有图标的按钮<div class="btns rounded grid5">            <a class="button" href='/' title='下载源码'><i class='fas fa-download'></i>下载源码</a><a class="button" href='/' title='查看文档'><i class='fas fa-book-open'></i>查看文档</a>          </div>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中<div class="btns circle center grid5">            <a href='https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p red'>专业版</p>  <img src='https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png'></a><a href='https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p green'>免费版</p>  <img src='https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png'></a>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-12-github卡片-ghcard">2.12 github卡片 ghcard</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% ghcard 用户名, 其它参数（可选） %&#125;</span><br><span class="line">&#123;% ghcard 用户名/仓库, 其它参数（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>使用<code>,</code>分割各个参数。写法为：<code>参数名=参数值</code><br>以下只写几个常用参数值。</p><table><thead><tr><th><strong>参数名</strong></th><th>取值</th><th>释义</th></tr></thead><tbody><tr><td>hide</td><td>stars,commits,prs,issues,contribs</td><td>隐藏指定统计</td></tr><tr><td>count_private</td><td>true</td><td>将私人项目贡献添加到总提交计数中</td></tr><tr><td>show_icons</td><td>true</td><td>显示图标</td></tr><tr><td>theme</td><td>查阅:<a href="https://github.com/anuraghazra/github-readme-stats/blob/master/themes/README.md">Available Themes</a></td><td>主题</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.用户信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard fomalhaut1998 %&#125; | &#123;% ghcard fomalhaut1998, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=buefy %&#125; | &#123;% ghcard fomalhaut1998, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=onedark %&#125; | &#123;% ghcard fomalhaut1998, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=algolia %&#125; | &#123;% ghcard fomalhaut1998, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><p>2.仓库信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=buefy %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=onedark %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=algolia %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.用户信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=calm&show_owner=true"/></a></td></tr></tbody></table><p>2.仓库信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=calm&show_owner=true"/></a></td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-13-github徽标-ghbdage">2.13 github徽标 ghbdage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage [right],[left],[logo]||[color],[link],[title]||[option] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>left</code>：徽标左边的信息，必选参数。</li><li><code>right</code>: 徽标右边的信息，必选参数，</li><li><code>logo</code>：徽标图标，图标名称详见<a href="https://simpleicons.org/">simpleicons</a>，可选参数。</li><li><code>color</code>：徽标右边的颜色，可选参数。</li><li><code>link</code>：指向的链接，可选参数。</li><li><code>title</code>：徽标的额外信息，可选参数。主要用于优化SEO，但<code>object</code>标签不会像<code>a</code>标签一样在鼠标悬停显示<code>title</code>信息。</li><li><code>option</code>：自定义参数，支持<a href="https://shields.io/">shields.io</a>的全部API参数支持，具体参数可以参看上文中的拓展写法示例。形式为<code>name1=value2&amp;name2=value2</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.基本参数,定义徽标左右文字和图标</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Theme,Butterfly %&#125;</span><br><span class="line">&#123;% bdage Frame,Hexo,hexo %&#125;</span><br></pre></td></tr></table></figure><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage CDN,JsDelivr,jsDelivr||abcdef,https://metroui.org.ua/index.html,本站使用JsDelivr为静态资源提供CDN加速 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割</span><br><span class="line">&#123;% bdage Source,GitHub,GitHub||,https://github.com/ %&#125;</span><br></pre></td></tr></table></figure><p>3.拓展参数，支持shields的API的全部参数内容</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Hosted,Vercel,Vercel||brightgreen,https://vercel.com/,本站采用双线部署，默认线路托管于Vercel||style=social&amp;logoWidth=20 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割</span><br><span class="line">&#123;% bdage Hosted,Vercel,Vercel||||style=social&amp;logoWidth=20&amp;logoColor=violet %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.基本参数,定义徽标左右文字和图标</p><p><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Butterfly-Theme-orange?logo=&color=orange&link=&"></object><br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Hexo-Frame-orange?logo=hexo&color=orange&link=&"></object></p><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><p><object class="ghbdage" style="margin-inline:5px" title="本站使用JsDelivr为静态资源提供CDN加速" standby="loading..." data="https://img.shields.io/badge/JsDelivr-CDN-orange?logo=jsDelivr&color=abcdef&link=https://metroui.org.ua/index.html&"></object><br>//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割<br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/GitHub-Source-orange?logo=GitHub&color=orange&link=https://github.com/&"></object></p><p>3.拓展参数，支持shields的API的全部参数内容</p><p><object class="ghbdage" style="margin-inline:5px" title="本站采用双线部署，默认线路托管于Vercel" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=brightgreen&link=https://vercel.com/&style=social&logoWidth=20"></object><br>//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割<br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=orange&link=&style=social&logoWidth=20&logoColor=violet"></object></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-14-网站卡片-sites">2.14 网站卡片 sites</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site xaoxuu, url=https://xaoxuu.com, screenshot=https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg, avatar=https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/avatar/avatar.png, description=简约风格 %&#125;</span><br><span class="line">&#123;% site inkss, url=https://inkss.cn, screenshot=https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg, avatar=https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site MHuiG, url=https://blog.mhuig.top, screenshot=https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png, avatar=https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Colsrch, url=https://colsrch.top, screenshot=https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png, avatar=https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Linhk1606, url=https://linhk1606.github.io, screenshot=https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png, avatar=https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="site-card-group"><a class="site-card" href="https://fomalhaut1998.com"><div class="img"><img src="https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/avatar/avatar.png"/><span class="title">fomalhaut1998</span><span class="desc">简约风格</span></div></a><a class="site-card" href="https://inkss.cn"><div class="img"><img src="https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg"/><span class="title">inkss</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://blog.mhuig.top"><div class="img"><img src="https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png"/><span class="title">MHuiG</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://colsrch.top"><div class="img"><img src="https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg"/><span class="title">Colsrch</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://linhk1606.github.io"><div class="img"><img src="https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png"/></div><div class="info"><img src="https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png"/><span class="title">Linhk1606</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-15-行内图片-inlineimage">2.15 行内图片 inlineimage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% inlineimage 图片链接, height=高度（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>高度</code>：height=20px</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif %&#125; 一段话。</span><br><span class="line"></span><br><span class="line">这又是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif, height=40px %&#125; 一段话。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>这是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif" style="height:1.5em"/> 一段话。</p><p>这又是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif" style="height:40px;"/> 一段话。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-16-单张图片-image">2.16 单张图片 image</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image 链接, width=宽度（可选）, height=高度（可选）, alt=描述（可选）, bg=占位颜色（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>图片宽度高度：width=300px, height=32px</li><li>图片描述：alt=图片描述（butterfly需要在主题配置文件中开启图片描述）</li><li>占位背景色：bg=#f2f2f2</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>2.指定宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px %&#125;</span><br></pre></td></tr></table></figure><p>3.指定宽度并添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>4.设置占位背景色：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, bg=#1D0C04, alt=优化不同宽度浏览的观感 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.添加描述：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>2..指定宽度<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" style="width:400px;"/></div></div>3.指定宽度并添加描述：<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。" style="width:400px;"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>4.设置占位背景色：<div class="img-wrap"><div class="img-bg" style="background:#1D0C04"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="优化不同宽度浏览的观感" style="width:400px;"/></div><span class="image-caption">优化不同宽度浏览的观感</span></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-17-音频-audio">2.17 音频 audio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio 音频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="audio"><audio controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3' type='audio/mp3'>Your browser does not support the audio tag.</audio></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-18-视频-video">2.18 视频 video</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video 视频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>对齐方向</code>：left, center, right</li><li><code>列数</code>：逗号后面直接写列数，支持 1 ～ 4 列。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.100%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br></pre></td></tr></table></figure><p>2.50%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 2 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><p>3.25%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 4 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.100%宽度</p><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div>2.50%宽度<div class="videos" col='2'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div>3.25%宽度<div class="videos" col='4'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-19-相册-gallery">2.19 相册 gallery</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 圖片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>gallerygroup 相册图库</li></ul><table><thead><tr><th>参数名</th><th>释义</th></tr></thead><tbody><tr><td>name</td><td>图库名字</td></tr><tr><td>description</td><td>图库描述</td></tr><tr><td>link</td><td>链接到对应相册的地址</td></tr><tr><td>img-url</td><td>图库封面</td></tr></tbody></table><ul><li><p>gallery 相册</p><p>区别于旧版的Gallery相册,新的Gallery相册会自动根据图片长度进行排版，书写也更加方便，与markdown格式一样。可根据需要插入到相应的md。无需再自己配置长宽。<strong>建议在粘贴时故意使用长短、大小、横竖不一的图片</strong>，会有更好的效果。（尺寸完全相同的图片只会平铺输出，效果很糟糕）</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup MC 在Rikkaの六花服务器里留下的足迹 &#x27;/gallery/MC/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg %&#125;</span><br><span class="line">&#123;% galleryGroup Gundam 哦咧哇gundam哒！ &#x27;/gallery/Gundam/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png %&#125;</span><br><span class="line">&#123;% galleryGroup I-am-Akilar 某种意义上也算自拍吧 &#x27;/gallery/I-am-Akilar/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg</span>)</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg</span>)</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.gallerygroup 相册图库</p><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">MC</div>  <p>在Rikkaの六花服务器里留下的足迹</p>  <a href='/gallery/MC/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">Gundam</div>  <p>哦咧哇gundam哒！</p>  <a href='/gallery/Gundam/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">I-am-Akilar</div>  <p>某种意义上也算自拍吧</p>  <a href='/gallery/I-am-Akilar/'></a>  </figcaption>  </figure></div>2.gallery 相册<div class="fj-gallery"><p><img src="https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg" alt=""><br><img src="https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg" alt=""></p>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-20-折叠框-folding">2.20 折叠框 folding</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 参数（可选）, 标题 %&#125;</span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><!-- tab 参数配置 --><ol><li><p><code>颜色</code>：blue, cyan, green, yellow, red</p></li><li><p><code>状态</code>：状态填写 open 代表默认打开。</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 查看图片测试 %&#125;</span><br><span class="line"></span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding cyan open, 查看默认打开的折叠框 %&#125;</span><br><span class="line"></span><br><span class="line">这是一个默认打开的折叠框。</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding green, 查看代码测试 %&#125;</span><br><span class="line">假装这里有代码块（代码块没法嵌套代码块）</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding yellow, 查看列表测试 %&#125;</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> haha</span><br><span class="line"><span class="bullet">-</span> hehe</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding red, 查看嵌套测试 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding blue, 查看嵌套测试2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding 查看嵌套测试3 %&#125;</span><br><span class="line"></span><br><span class="line">hahaha <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png&#x27;</span> <span class="attr">style</span>=<span class="string">&#x27;height:24px&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><details class="folding-tag" ><summary> 查看图片测试 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg" alt=""></p>              </div>            </details><details class="folding-tag" cyan open><summary> 查看默认打开的折叠框 </summary>              <div class='content'>              <p>这是一个默认打开的折叠框。</p>              </div>            </details><details class="folding-tag" green><summary> 查看代码测试 </summary>              <div class='content'>              <p>假装这里有代码块（代码块没法嵌套代码块）</p>              </div>            </details><details class="folding-tag" yellow><summary> 查看列表测试 </summary>              <div class='content'>              <ul><li>haha</li><li>hehe</li></ul>              </div>            </details><details class="folding-tag" red><summary> 查看嵌套测试 </summary>              <div class='content'>              <details class="folding-tag" blue><summary> 查看嵌套测试2 </summary>              <div class='content'>              <details class="folding-tag" ><summary> 查看嵌套测试3 </summary>              <div class='content'>              <p>hahaha <span><img src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png' style='height:24px'></span></p>              </div>            </details>              </div>            </details>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-21-分栏-tab">2.21 分栏 tab</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>Unique name :</p><ul><li><p>选项卡块标签的唯一名称，不带逗号。</p></li><li><p>将在#id中用作每个标签及其索引号的前缀。</p></li><li><p>如果名称中包含空格，则对于生成#id，所有空格将由破折号代替。</p></li><li><p>仅当前帖子/页面的URL必须是唯一的！</p></li></ul></li><li><p>[index]:</p><ul><li><p>活动选项卡的索引号。</p></li><li><p>如果未指定，将选择第一个标签（1）。</p></li><li><p>如果index为-1，则不会选择任何选项卡。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[Tab caption]:</p><ul><li><p>当前选项卡的标题。</p></li><li><p>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。</p></li><li><p>如果未指定标题，但指定了图标，则标题将为空。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[@icon]:</p><ul><li><p>FontAwesome图标名称（全名，看起来像“ fas fa-font”）</p></li><li><p>可以指定带空格或不带空格；</p></li><li><p>例如’Tab caption @icon’ 和 ‘Tab caption@icon’.</p></li><li><p>可选参数。</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.Demo 1 - 预设选择第一个【默认】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>2.Demo 2 - 预设选择tabs</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test2, 3 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>3.Demo 3 - 没有预设值</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test3, -1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line"><span class="strong">**tab名字为第一个Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"><span class="strong">**只有图标 没有Tab名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.Demo 1 - 预设选择第一个【默认】</p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>2.Demo 2 - 预设选择tabs</p><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test2-1">test2 1</button></li><li class="tab"><button type="button" data-href="#test2-2">test2 2</button></li><li class="tab active"><button type="button" data-href="#test2-3">test2 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>3.Demo 3 - 没有预设值</p><div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test3-1">test3 1</button></li><li class="tab"><button type="button" data-href="#test3-2">test3 2</button></li><li class="tab"><button type="button" data-href="#test3-3">test3 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test3-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一个Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>炸弹</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-22-诗词标签-poem">2.22 诗词标签 poem</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><ol><li><code>title</code>：诗词标题</li><li><code>author</code>：作者，可以不写</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% poem 水调歌头,苏轼 %&#125;</span><br><span class="line">丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。</span><br><span class="line">明月几时有？把酒问青天。</span><br><span class="line">不知天上宫阙，今夕是何年？</span><br><span class="line">我欲乘风归去，又恐琼楼玉宇，高处不胜寒。</span><br><span class="line">起舞弄清影，何似在人间？</span><br><span class="line"></span><br><span class="line">转朱阁，低绮户，照无眠。</span><br><span class="line">不应有恨，何事长向别时圆？</span><br><span class="line">人有悲欢离合，月有阴晴圆缺，此事古难全。</span><br><span class="line">但愿人长久，千里共婵娟。</span><br><span class="line">&#123;% endpoem %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class='poem'><div class='poem-title'>水调歌头</div><div class='poem-author'>苏轼</div><p>丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。<br>明月几时有？把酒问青天。<br>不知天上宫阙，今夕是何年？<br>我欲乘风归去，又恐琼楼玉宇，高处不胜寒。<br>起舞弄清影，何似在人间？</p><p>转朱阁，低绮户，照无眠。<br>不应有恨，何事长向别时圆？<br>人有悲欢离合，月有阴晴圆缺，此事古难全。<br>但愿人长久，千里共婵娟。</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-23-阿里图标-icon">2.23 阿里图标 icon</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon [icon-xxxx],[font-size] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>icon-xxxx</code>：表示图标<code>font-class</code>,可以在自己的阿里矢量图标库项目的<code>font-class</code>引用方案内查询并复制。</li><li><code>font-size</code>：表示图标大小，直接填写数字即可，单位为<code>em</code>。图标大小默认值为<code>1em</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon icon-rat<span class="emphasis">_zi %&#125;&#123;% icon icon-rat,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-ox_</span>chou,3 %&#125;&#123;% icon icon-ox,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-tiger<span class="emphasis">_yin,5 %&#125;&#123;% icon icon-tiger,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rabbit_</span>mao,1 %&#125;&#123;% icon icon-rabbit,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dragon<span class="emphasis">_chen,3 %&#125;&#123;% icon icon-dragon,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-snake_</span>si,5 %&#125;&#123;% icon icon-snake,6 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-horse<span class="emphasis">_wu %&#125;&#123;% icon icon-horse,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-goat_</span>wei,3 %&#125;&#123;% icon icon-goat,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-monkey<span class="emphasis">_shen,5 %&#125;&#123;% icon icon-monkey,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rooster_</span>you %&#125;&#123;% icon icon-rooster,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dog<span class="emphasis">_xu,3 %&#125;&#123;% icon icon-dog,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-boar_</span>hai,5 %&#125;&#123;% icon icon-boar,6 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rat_zi"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rat"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-ox_chou"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-ox"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-tiger_yin"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-tiger"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rabbit_mao"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rabbit"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dragon_chen"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dragon"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-snake_si"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-snake"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-horse_wu"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-horse"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-goat_wei"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-goat"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-monkey_shen"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-monkey"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rooster_you"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rooster"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dog_xu"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dog"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-boar_hai"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-boar"></use></svg></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-24-特效标签wow">2.24 特效标签wow</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow [animete],[duration],[delay],[offset],[iteration] %&#125;</span><br><span class="line">内容</span><br><span class="line">&#123;% endwow %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>animate</code>: 动画样式，效果详见<a href="https://animate.style/">animate.css参考文档</a></li><li><code>duration</code>: 选填项，动画持续时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>delay</code>: 选填项，动画开始的延迟时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>offset</code>: 选填项，开始动画的距离（相对浏览器底部）</li><li><code>iteration</code>: 选填项，动画重复的次数</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.flip动画效果。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>3.slideInRight动画效果，持续5s，延时5s</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__slideInRight,5s,5s %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note orange &#x27;fas fa-car&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`slideInRight`动画效果，持续`5s`，延时`5s`。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__heartBeat,,5s,,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note red &#x27;fas fa-battery-half&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`heartBeat`动画效果，延时`5s`，重复`10`次。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.flip动画效果。</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>3.slideInRight动画效果，持续5s，延时5s</p><div class='wow animate__slideInRight' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='' ><div class="note orange icon-padding modern"><i class="note-icon fas fa-car"></i><p><code>slideInRight</code>动画效果，持续<code>5s</code>，延时<code>5s</code>。</p></div></div><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><div class='wow animate__heartBeat' data-wow-duration='' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='10' ><div class="note red icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p><code>heartBeat</code>动画效果，延时<code>5s</code>，重复<code>10</code>次。</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-25-进度条-progress">2.25  进度条 progress</h2><div class="note info flat"><p>进度条标签参考<a href="https://rongbuqiu.com/jdt.html">沂佰孜猫-给HEXO文章添加彩色进度条</a>。<br>源样式提取自<a href="https://zwying0814.gitbook.io/cuteen/">Cuteen</a>主题。</p></div><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress [width] [color] [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>width</code>: 0到100的阿拉伯数字</li><li><code>color</code>: 颜色，取值有red,yellow,green,cyan,blue,gray</li><li><code>text</code>:进度条上的文字内容</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress 10 red 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 30 yellow 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 50 green 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 70 cyan 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 90 blue 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 100 gray 进度条样式预览 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-red"  style="width: 10%" aria-valuenow="10" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-yellow"  style="width: 30%" aria-valuenow="30" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-green"  style="width: 50%" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-cyan"  style="width: 70%" aria-valuenow="70" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-blue"  style="width: 90%" aria-valuenow="90" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-gray"  style="width: 100%" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-26-注释-notation">2.26 注释 notation</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota [label] , [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p><code>label</code>: 注释词汇</p></li><li><p><code>text</code>: 悬停显示的注解内容</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota 把鼠标移动到我上面试试 ,可以看到注解内容出现在顶栏 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><span class='nota' data-nota='可以看到注解内容出现在顶栏'>把鼠标移动到我上面试试</span></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-27-气泡注释-bubble">2.27 气泡注释 bubble</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bubble [content] , [notation] ,[background-color] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>content</code>: 注释词汇</li><li><code>notation</code>: 悬停显示的注解内容</li><li><code>background-color</code>: 可选，气泡背景色。默认为“#71a4e3”</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的&#123;% bubble 兄弟相邻选择器,&quot;例如 h1 + p &#123;margin-top:50px;&#125;&quot; %&#125;，&#123;% bubble flex布局,&quot;Flex 是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;,&quot;#ec5830&quot; %&#125;，&#123;% bubble transform变换,&quot;transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。&quot;,&quot;#1db675&quot; %&#125;，animation的&#123;% bubble 贝塞尔速度曲线,&quot;贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋&quot;,&quot;#de4489&quot; %&#125;写法，还有今天刚看到的&#123;% bubble clip-path,&quot;clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。&quot;,&quot;#868fd7&quot; %&#125;属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的<span class="bubble-content">兄弟相邻选择器</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#71a4e3;">例如 h1 + p {margin-top:50px;}</span></span>，<span class="bubble-content">flex布局</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#ec5830;">Flex 是 Flexible Box 的缩写，意为弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;</span></span>，<span class="bubble-content">transform变换</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#1db675;">transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。</span></span>，animation的<span class="bubble-content">贝塞尔速度曲线</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#de4489;">贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋</span></span>写法，还有今天刚看到的<span class="bubble-content">clip-path</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#868fd7;">clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。</span></span>属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-28-引用文献-reference">2.28 引用文献 reference</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% referto [id] , [literature] %&#125;</span><br><span class="line">&#123;% referfrom [id] , [literature] , [url] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>referto 引用上标</p><ul><li><p><code>id</code>: 上标序号内容，需与referfrom标签的id对应才能实现跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li></ul></li><li><p>referfrom 引用出处</p><ul><li><p><code>id</code>: 序号内容，需与referto标签的id对应才能实现 跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li><li><p><code>url</code>: 引用的参考文献链接，可省略</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Akilarの糖果屋(akilar.top)是一个私人性质的博客&#123;% referto &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27; %&#125;，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架&#123;% referto &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27; %&#125;，Butterfly主题&#123;% referto &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">本项目参考了Volantis&#123;% referto &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27; %&#125;的标签样式。引入<span class="code">`[tag].js`</span>，并针对<span class="code">`butterfly`</span>主题修改了相应的<span class="code">`[tag].styl`</span>。在此鸣谢<span class="code">`Volantis`</span>主题众开发者。</span><br><span class="line">主要参考内容包括各个volantis的内置标签插件文档&#123;% referto &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27; %&#125;</span><br><span class="line">Butterfly主题的各个衍生魔改&#123;% referto &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27; %&#125;&#123;% referto &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27; %&#125;&#123;% referto &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27; %&#125;&#123;% referto &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% referfrom &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27;,&#x27;https://jq.qq.com/?<span class="emphasis">_wv=1027&amp;k=pGLB2C0N&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27;,&#x27;https://hexo.io/zh-cn/docs/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27;,&#x27;https://butterfly.js.org/posts/21cfbf15/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27;,&#x27;https://volantis.js.org/v5/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27;,&#x27;https://volantis.js.org/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27;,&#x27;https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27;,&#x27;https://lovelijunyi.gitee.io/posts/c898.html&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27;,&#x27;https://github.com/l-lin/font-awesome-animation&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27;,&#x27;https://www.antmoe.com/posts/3b43914f/&#x27; %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>Akilarの糖果屋(akilar.top)是一个私人性质的博客<span class="hidden-anchor" id="referto_[1]"></span><sup class="reference"><a href="#referfrom_[1]">[1]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Akilarの糖果屋群聊简介</span><span class="reference-title">参考资料</span></span></span>，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架<span class="hidden-anchor" id="referto_[2]"></span><sup class="reference"><a href="#referfrom_[2]">[2]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Hexo中文文档</span><span class="reference-title">参考资料</span></span></span>，Butterfly主题<span class="hidden-anchor" id="referto_[3]"></span><sup class="reference"><a href="#referfrom_[3]">[3]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档(一) 快速开始</span><span class="reference-title">参考资料</span></span></span></p><p>本项目参考了Volantis<span class="hidden-anchor" id="referto_[4]"></span><sup class="reference"><a href="#referfrom_[4]">[4]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">hexo-theme-volantis 标签插件</span><span class="reference-title">参考资料</span></span></span>的标签样式。引入<code>[tag].js</code>，并针对<code>butterfly</code>主题修改了相应的<code>[tag].styl</code>。在此鸣谢<code>Volantis</code>主题众开发者。<br>主要参考内容包括各个volantis的内置标签插件文档<span class="hidden-anchor" id="referto_[5]"></span><sup class="reference"><a href="#referfrom_[5]">[5]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Volantis文档:内置标签插件</span><span class="reference-title">参考资料</span></span></span><br>Butterfly主题的各个衍生魔改<span class="hidden-anchor" id="referto_[6]"></span><sup class="reference"><a href="#referfrom_[6]">[6]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档:标签外挂（Tag Plugins</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[7]"></span><sup class="reference"><a href="#referfrom_[7]">[7]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小弋の生活馆全样式预览</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[8]"></span><sup class="reference"><a href="#referfrom_[8]">[8]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">l-lin-font-awesome-animation</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[9]"></span><sup class="reference"><a href="#referfrom_[9]">[9]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小康的butterfly主题使用文档</span><span class="reference-title">参考资料</span></span></span></p><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://jq.qq.com/?_wv=1027&k=pGLB2C0N">Akilarの糖果屋群聊简介</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://hexo.io/zh-cn/docs/">Hexo中文文档</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[3]"></span><a class="reference-anchor" href="#referto_[3]">[3]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安装文档(一) 快速开始</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[4]"></span><a class="reference-anchor" href="#referto_[4]">[4]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/v5/tag-plugins/">hexo-theme-volantis 标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[5]"></span><a class="reference-anchor" href="#referto_[5]">[5]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/tag-plugins/">Volantis文档:内置标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[6]"></span><a class="reference-anchor" href="#referto_[6]">[6]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89">Butterfly 安装文档:标签外挂（Tag Plugins</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[7]"></span><a class="reference-anchor" href="#referto_[7]">[7]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://lovelijunyi.gitee.io/posts/c898.html">小弋の生活馆全样式预览</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[8]"></span><a class="reference-anchor" href="#referto_[8]">[8]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://github.com/l-lin/font-awesome-animation">l-lin-font-awesome-animation</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[9]"></span><a class="reference-anchor" href="#referto_[9]">[9]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://www.antmoe.com/posts/3b43914f/">小康的butterfly主题使用文档</a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-29-PDF展示">2.29 PDF展示</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf 文件路径 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>文件路径</code>: 可以是相对路径或者是在线链接</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.本地文件:在md文件路径下创建一个同名文件夹，其内放pdf文件名为xxx.pdf的文件</span></span><br><span class="line">&#123;% pdf xxx.pdf %&#125;</span><br><span class="line"><span class="section"># 2.在线链接</span></span><br><span class="line">&#123;% pdf https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>2.在线链接(要放到最外层才能起作用)</p><pre><code>&lt;div class=&quot;row&quot;&gt;&lt;embed src=&quot;https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf&quot; width=&quot;100%&quot; height=&quot;550&quot; type=&quot;application/pdf&quot;&gt;&lt;/div&gt;</code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-30-Hexo-tag-map-插件">2.30 Hexo-tag-map 插件</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% + 标签值 + 经度 + 纬度 + 文本 + 缩放等级 + 宽 + 高 + 默认图层 + %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th style="text-align:center">地图名</th><th style="text-align:center">标签值 &lt;必填&gt;</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">缩放等级 (默认 14)</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">默认图层 (默认 1)</th></tr></thead><tbody><tr><td style="text-align:center">混合地图</td><td style="text-align:center">map</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~7</td></tr><tr><td style="text-align:center">谷歌地图</td><td style="text-align:center">googleMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~20</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">高德地图</td><td style="text-align:center">gaodeMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">百度地图</td><td style="text-align:center">baiduMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 4~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~2</td></tr><tr><td style="text-align:center">Geoq 地图</td><td style="text-align:center">geoqMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~5</td></tr><tr><td style="text-align:center">openstreet 地图</td><td style="text-align:center">openstreetMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">不支持此参数</td></tr></tbody></table><ol><li>参数之间，用英文逗号相隔</li><li>参数必须按上述事例顺序输入，不得为空</li><li>同一个页面，同一组经纬度值，只能插入一个相同标签值的地图 (若有需要，可以将第二个地图上，经度或纬度末尾删除一两个数)</li><li>参数取值必须在上述范围内</li><li>默认图层：即地图叠加层的值，默认常规地图还是卫星地图，可按地图显示顺序取值</li><li>缩放等级，数字越大，地图比例尺越小，显示的越精细</li><li>除标签值外，其他参数选填，但 每个参数的左边的参数必填</li><li>谷歌地图需要外网才能加载查看</li></ol><p>坐标获取：<a href="https://lbs.amap.com/tools/picker">高德地图坐标拾取系统</a> 、<a href="https://api.map.baidu.com/lbsapi/getpoint/index.html">百度地图坐标拾取系统</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% map 120.101101,30.239119 %&#125;</span><br><span class="line">&#123;% googleMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！ %&#125;</span><br><span class="line">&#123;% geoqMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！, 13, 90%, 320px, 3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="map-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:20,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'});routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1,attribution:'Google Maps'});var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:21,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"智图地图":normalm1,"谷歌地图":normalMap,"高德卫星地图":imgm,"谷歌卫星地图":satelliteMap,"高德卫星标注":image,"谷歌卫星标注":routeMap};var mymap=L.map('map-120.101101-30.239119',{center:[30.239119,120.101101],zoom:14,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);</script><br><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="googleMap-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:22,minZoom:1,attribution:'Google Maps'});var baseLayers={"谷歌地图":normalMap,"谷歌卫星图":satelliteMap,"谷歌卫星标注": routeMap};var overlayLayers={};var mymap=L.map("googleMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:14,layers:[normalMap],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="geoqMap-120.101101-30.239119" style="max-width:90%; height:320px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm2=L.tileLayer.chinaProvider('Geoq.Normal.PurplishBlue',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm3=L.tileLayer.chinaProvider('Geoq.Normal.Gray',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm4=L.tileLayer.chinaProvider('Geoq.Normal.Warm',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm5=L.tileLayer.chinaProvider('Geoq.Theme.Hydro',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm1,normalm2,normalm3,normalm4,normalm5]);var baseLayers={"智图地图":normalm1,"午夜蓝":normalm2,"灰色":normalm3,"暖色":normalm4,"水系":normalm5};var mymap=L.map("geoqMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:13,layers:[normalm3],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-31-隐藏块">2.31 隐藏块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>content：要隐藏的内容</li><li>display：展示前按钮显示的文字（可选）</li><li>bg：按钮的背景颜色（可选）</li><li>color：按钮显示的文字的颜色（可选）</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock 点我预览, blue %&#125;</span><br><span class="line">这里有张图片：</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image (1)&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:67%;&quot;</span> /&gt;</span></span></span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="hide-block"><button type="button" class="hide-button" style="background-color:  blue;">点我预览    </button><div class="hide-content"><p>这里有张图片：<br><img src="https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb" alt="image (1)" style="zoom:67%;" /></p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
